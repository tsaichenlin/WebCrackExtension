{"ast":null,"code":"const typeSchemas = ['aboutpage', 'checkoutpage', 'collectionpage', 'contactpage', 'faqpage', 'itempage', 'medicalwebpage', 'profilepage', 'qapage', 'realestatelisting', 'searchresultspage', 'webpage', 'website', 'article', 'advertisercontentarticle', 'newsarticle', 'analysisnewsarticle', 'askpublicnewsarticle', 'backgroundnewsarticle', 'opinionnewsarticle', 'reportagenewsarticle', 'reviewnewsarticle', 'report', 'satiricalarticle', 'scholarlyarticle', 'medicalscholarlyarticle'];\nconst attributeLists = {\n  description: 'description',\n  image: 'image',\n  author: 'author',\n  published: 'datePublished',\n  type: '@type'\n};\nconst parseJson = text => {\n  try {\n    return JSON.parse(text);\n  } catch {\n    return null;\n  }\n};\n\n/**\n * Parses JSON-LD data from a document and populates an entry object.\n * Only populates if the original entry object is empty or undefined.\n *\n * @param {Document} document - The HTML Document\n * @param {Object} entry - The entry object to merge/populate with JSON-LD.\n * @returns {Object} The entry object after being merged/populated with data.\n */\nexport default ((document, entry) => {\n  const ldSchema = document.querySelector('script[type=\"application/ld+json\"]')?.textContent;\n  const ldJson = ldSchema ? parseJson(ldSchema) : null;\n  if (ldJson) {\n    Object.entries(attributeLists).forEach(([key, attr]) => {\n      if ((typeof entry[key] === 'undefined' || entry[key] === '') && ldJson[attr]) {\n        if (key === 'type' && typeof ldJson[attr] === 'string') {\n          return entry[key] = typeSchemas.includes(ldJson[attr].toLowerCase()) ? ldJson[attr].toLowerCase() : '';\n        }\n        if (typeof ldJson[attr] === 'string') {\n          return entry[key] = ldJson[attr].toLowerCase();\n        }\n        if (Array.isArray(ldJson[attr]) && typeof ldJson[attr][0] === 'string') {\n          return entry[key] = ldJson[attr][0].toLowerCase();\n        }\n      }\n    });\n  }\n  return entry;\n});","map":{"version":3,"names":["typeSchemas","attributeLists","description","image","author","published","type","parseJson","text","JSON","parse","document","entry","ldSchema","querySelector","textContent","ldJson","Object","entries","forEach","key","attr","includes","toLowerCase","Array","isArray"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@extractus/article-extractor/src/utils/extractLdSchema.js"],"sourcesContent":["const typeSchemas = [\n  'aboutpage',\n  'checkoutpage',\n  'collectionpage',\n  'contactpage',\n  'faqpage',\n  'itempage',\n  'medicalwebpage',\n  'profilepage',\n  'qapage',\n  'realestatelisting',\n  'searchresultspage',\n  'webpage',\n  'website',\n  'article',\n  'advertisercontentarticle',\n  'newsarticle',\n  'analysisnewsarticle',\n  'askpublicnewsarticle',\n  'backgroundnewsarticle',\n  'opinionnewsarticle',\n  'reportagenewsarticle',\n  'reviewnewsarticle',\n  'report',\n  'satiricalarticle',\n  'scholarlyarticle',\n  'medicalscholarlyarticle',\n]\n\nconst attributeLists = {\n  description: 'description',\n  image: 'image',\n  author: 'author',\n  published: 'datePublished',\n  type: '@type',\n}\n\nconst parseJson = (text) => {\n  try {\n    return JSON.parse(text)\n  } catch {\n    return null\n  }\n}\n\n/**\n * Parses JSON-LD data from a document and populates an entry object.\n * Only populates if the original entry object is empty or undefined.\n *\n * @param {Document} document - The HTML Document\n * @param {Object} entry - The entry object to merge/populate with JSON-LD.\n * @returns {Object} The entry object after being merged/populated with data.\n */\nexport default (document, entry) => {\n  const ldSchema = document.querySelector('script[type=\"application/ld+json\"]')?.textContent\n\n  const ldJson = ldSchema ? parseJson(ldSchema) : null\n\n  if (ldJson) {\n    Object.entries(attributeLists).forEach(([key, attr]) => {\n      if ((typeof entry[key] === 'undefined' || entry[key] === '') && ldJson[attr]) {\n        if (key === 'type' && typeof ldJson[attr] === 'string') {\n          return entry[key] = typeSchemas.includes(ldJson[attr].toLowerCase()) ? ldJson[attr].toLowerCase() : ''\n        }\n\n        if (typeof ldJson[attr] === 'string') {\n          return entry[key] = ldJson[attr].toLowerCase()\n        }\n\n        if (Array.isArray(ldJson[attr]) && typeof ldJson[attr][0] === 'string') {\n          return entry[key] = ldJson[attr][0].toLowerCase()\n        }\n      }\n    })\n  }\n\n  return entry\n}\n"],"mappings":"AAAA,MAAMA,WAAW,GAAG,CAClB,WAAW,EACX,cAAc,EACd,gBAAgB,EAChB,aAAa,EACb,SAAS,EACT,UAAU,EACV,gBAAgB,EAChB,aAAa,EACb,QAAQ,EACR,mBAAmB,EACnB,mBAAmB,EACnB,SAAS,EACT,SAAS,EACT,SAAS,EACT,0BAA0B,EAC1B,aAAa,EACb,qBAAqB,EACrB,sBAAsB,EACtB,uBAAuB,EACvB,oBAAoB,EACpB,sBAAsB,EACtB,mBAAmB,EACnB,QAAQ,EACR,kBAAkB,EAClB,kBAAkB,EAClB,yBAAyB,CAC1B;AAED,MAAMC,cAAc,GAAG;EACrBC,WAAW,EAAE,aAAa;EAC1BC,KAAK,EAAE,OAAO;EACdC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE,eAAe;EAC1BC,IAAI,EAAE;AACR,CAAC;AAED,MAAMC,SAAS,GAAIC,IAAI,IAAK;EAC1B,IAAI;IACF,OAAOC,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;EACzB,CAAC,CAAC,MAAM;IACN,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,CAACG,QAAQ,EAAEC,KAAK,KAAK;EAClC,MAAMC,QAAQ,GAAGF,QAAQ,CAACG,aAAa,CAAC,oCAAoC,CAAC,EAAEC,WAAW;EAE1F,MAAMC,MAAM,GAAGH,QAAQ,GAAGN,SAAS,CAACM,QAAQ,CAAC,GAAG,IAAI;EAEpD,IAAIG,MAAM,EAAE;IACVC,MAAM,CAACC,OAAO,CAACjB,cAAc,CAAC,CAACkB,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,IAAI,CAAC,KAAK;MACtD,IAAI,CAAC,OAAOT,KAAK,CAACQ,GAAG,CAAC,KAAK,WAAW,IAAIR,KAAK,CAACQ,GAAG,CAAC,KAAK,EAAE,KAAKJ,MAAM,CAACK,IAAI,CAAC,EAAE;QAC5E,IAAID,GAAG,KAAK,MAAM,IAAI,OAAOJ,MAAM,CAACK,IAAI,CAAC,KAAK,QAAQ,EAAE;UACtD,OAAOT,KAAK,CAACQ,GAAG,CAAC,GAAGpB,WAAW,CAACsB,QAAQ,CAACN,MAAM,CAACK,IAAI,CAAC,CAACE,WAAW,CAAC,CAAC,CAAC,GAAGP,MAAM,CAACK,IAAI,CAAC,CAACE,WAAW,CAAC,CAAC,GAAG,EAAE;QACxG;QAEA,IAAI,OAAOP,MAAM,CAACK,IAAI,CAAC,KAAK,QAAQ,EAAE;UACpC,OAAOT,KAAK,CAACQ,GAAG,CAAC,GAAGJ,MAAM,CAACK,IAAI,CAAC,CAACE,WAAW,CAAC,CAAC;QAChD;QAEA,IAAIC,KAAK,CAACC,OAAO,CAACT,MAAM,CAACK,IAAI,CAAC,CAAC,IAAI,OAAOL,MAAM,CAACK,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;UACtE,OAAOT,KAAK,CAACQ,GAAG,CAAC,GAAGJ,MAAM,CAACK,IAAI,CAAC,CAAC,CAAC,CAAC,CAACE,WAAW,CAAC,CAAC;QACnD;MACF;IACF,CAAC,CAAC;EACJ;EAEA,OAAOX,KAAK;AACd,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}