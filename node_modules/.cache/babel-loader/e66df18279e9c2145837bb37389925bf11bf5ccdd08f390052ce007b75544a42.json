{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n  const runtimeEnv = await getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  return runs.map(run => {\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n      ...extra,\n      runtime: {\n        ...runtimeEnv,\n        ...extra?.runtime\n      },\n      metadata: {\n        ...envVars,\n        ...(envVars.revision_id || run.revision_id ? {\n          revision_id: run.revision_id ?? envVars.revision_id\n        } : {}),\n        ...metadata\n      }\n    };\n    return run;\n  });\n}\nconst getTracingSamplingRate = () => {\n  const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n  if (!uuid.validate(str)) {\n    throw new Error(`Invalid UUID: ${str}`);\n  }\n}\nexport class Queue {\n  constructor() {\n    Object.defineProperty(this, \"items\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  get size() {\n    return this.items.length;\n  }\n  push(item) {\n    // this.items.push is synchronous with promise creation:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n    return new Promise(resolve => {\n      this.items.push([item, resolve]);\n    });\n  }\n  pop(upToN) {\n    if (upToN < 1) {\n      throw new Error(\"Number of items to pop off may not be less than 1.\");\n    }\n    const popped = [];\n    while (popped.length < upToN && this.items.length) {\n      const item = this.items.shift();\n      if (item) {\n        popped.push(item);\n      } else {\n        break;\n      }\n    }\n    return [popped.map(it => it[0]), () => popped.forEach(it => it[1]())];\n  }\n}\nexport class Client {\n  constructor(config = {}) {\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sampledPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"batchEndpointSupported\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchQueue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Queue()\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 50\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate();\n    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n    this.validateApiKeyIfHosted();\n    this.timeout_ms = config.timeout_ms ?? 12000;\n    this.caller = new AsyncCaller(config.callerOptions ?? {});\n    this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n    this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n    this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n  }\n  static getDefaultClientConfig() {\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n    const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  validateApiKeyIfHosted() {\n    const isLocal = isLocalhost(this.apiUrl);\n    if (!isLocal && !this.apiKey) {\n      throw new Error(\"API key must be provided when using hosted LangSmith API\");\n    }\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost\";\n      return \"http://localhost\";\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return \"https://dev.smith.langchain.com\";\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return \"https://smith.langchain.com\";\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": `langsmith-js/${__version__}`\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = `${this.apiKey}`;\n    }\n    return headers;\n  }\n  processInputs(inputs) {\n    if (this.hideInputs) {\n      return {};\n    }\n    return inputs;\n  }\n  processOutputs(outputs) {\n    if (this.hideOutputs) {\n      return {};\n    }\n    return outputs;\n  }\n  prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    const paramsString = queryParams?.toString() ?? \"\";\n    const url = `${this.apiUrl}${path}?${paramsString}`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n    }\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  async *_getPaginated(path, queryParams = new URLSearchParams()) {\n    let offset = Number(queryParams.get(\"offset\")) || 0;\n    const limit = Number(queryParams.get(\"limit\")) || 100;\n    while (true) {\n      queryParams.set(\"offset\", String(offset));\n      queryParams.set(\"limit\", String(limit));\n      const url = `${this.apiUrl}${path}?${queryParams}`;\n      const response = await this.caller.call(fetch, url, {\n        method: \"GET\",\n        headers: this.headers,\n        signal: AbortSignal.timeout(this.timeout_ms)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n      }\n      const items = await response.json();\n      if (items.length === 0) {\n        break;\n      }\n      yield items;\n      if (items.length < limit) {\n        break;\n      }\n      offset += items.length;\n    }\n  }\n  async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n    const bodyParams = body ? {\n      ...body\n    } : {};\n    while (true) {\n      const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n        method: requestMethod,\n        headers: {\n          ...this.headers,\n          \"Content-Type\": \"application/json\"\n        },\n        signal: AbortSignal.timeout(this.timeout_ms),\n        body: JSON.stringify(bodyParams)\n      });\n      const responseBody = await response.json();\n      if (!responseBody) {\n        break;\n      }\n      if (!responseBody[dataKey]) {\n        break;\n      }\n      yield responseBody[dataKey];\n      const cursors = responseBody.cursors;\n      if (!cursors) {\n        break;\n      }\n      if (!cursors.next) {\n        break;\n      }\n      bodyParams.cursor = cursors.next;\n    }\n  }\n  _filterForSampling(runs, patch = false) {\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (this.sampledPostUuids.has(run.id)) {\n          sampled.push(run);\n          this.sampledPostUuids.delete(run.id);\n        }\n      }\n      return sampled;\n    } else {\n      const sampled = [];\n      for (const run of runs) {\n        if (Math.random() < this.tracingSampleRate) {\n          sampled.push(run);\n          this.sampledPostUuids.add(run.id);\n        }\n      }\n      return sampled;\n    }\n  }\n  async drainAutoBatchQueue() {\n    while (this.autoBatchQueue.size >= 0) {\n      const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n      if (!batch.length) {\n        done();\n        return;\n      }\n      try {\n        await this.batchIngestRuns({\n          runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n          runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n        });\n      } finally {\n        done();\n      }\n    }\n  }\n  async processRunOperation(item, immediatelyTriggerBatch) {\n    const oldTimeout = this.autoBatchTimeout;\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    const itemPromise = this.autoBatchQueue.push(item);\n    if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n      await this.drainAutoBatchQueue();\n    }\n    if (this.autoBatchQueue.size > 0) {\n      this.autoBatchTimeout = setTimeout(() => {\n        this.autoBatchTimeout = undefined;\n        void this.drainAutoBatchQueue();\n      }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n    }\n    return itemPromise;\n  }\n  async batchEndpointIsSupported() {\n    const response = await fetch(`${this.apiUrl}/info`, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      // consume the response body to release the connection\n      // https://undici.nodejs.org/#/?id=garbage-collection\n      await response.text();\n      return false;\n    }\n    return true;\n  }\n  async createRun(run) {\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: run.start_time ?? Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      void this.processRunOperation({\n        action: \"create\",\n        item: runCreate\n      });\n      return;\n    }\n    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([runCreate]);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(mergedRunCreateParams[0]),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns({\n    runCreates,\n    runUpdates\n  }) {\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = runCreates?.map(create => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n    let preparedUpdateParams = runUpdates?.map(update => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const body = {\n      post: this._filterForSampling(preparedCreateParams),\n      patch: this._filterForSampling(preparedUpdateParams, true)\n    };\n    if (!body.post.length && !body.patch.length) {\n      return;\n    }\n    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n    if (this.batchEndpointSupported === undefined) {\n      this.batchEndpointSupported = await this.batchEndpointIsSupported();\n    }\n    if (!this.batchEndpointSupported) {\n      this.autoBatchTracing = false;\n      for (const preparedCreateParam of body.post) {\n        await this.createRun(preparedCreateParam);\n      }\n      for (const preparedUpdateParam of body.patch) {\n        if (preparedUpdateParam.id !== undefined) {\n          await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n        }\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"batch create run\");\n  }\n  async updateRun(runId, run) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      if (run.end_time !== undefined && data.parent_run_id === undefined) {\n        // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n        // in serverless environments.\n        await this.processRunOperation({\n          action: \"update\",\n          item: data\n        }, true);\n        return;\n      } else {\n        void this.processRunOperation({\n          action: \"update\",\n          item: data\n        });\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId, {\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    assertUuid(runId);\n    let run = await this._get(`/runs/${runId}`);\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl({\n    runId,\n    run,\n    projectOpts\n  }) {\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts?.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts?.projectName\n        })).id;\n      } else if (projectOpts?.projectId) {\n        sessionId = projectOpts?.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(`Run ${runId} has no app_path`);\n      }\n      const baseUrl = this.getHostUrl();\n      return `${baseUrl}${run_.app_path}`;\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(`Child run ${childRun.id} has no parent`);\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  async *listRuns({\n    projectId,\n    projectName,\n    parentRunId,\n    traceId,\n    referenceExampleId,\n    startTime,\n    executionOrder,\n    runType,\n    error,\n    id,\n    query,\n    filter,\n    limit\n  }) {\n    let projectIds = [];\n    if (projectId) {\n      projectIds = Array.isArray(projectId) ? projectId : [projectId];\n    }\n    if (projectName) {\n      const projectNames = Array.isArray(projectName) ? projectName : [projectName];\n      const projectIds_ = await Promise.all(projectNames.map(name => this.readProject({\n        projectName: name\n      }).then(project => project.id)));\n      projectIds.push(...projectIds_);\n    }\n    const body = {\n      session: projectIds.length ? projectIds : null,\n      run_type: runType,\n      reference_example: referenceExampleId,\n      query,\n      filter,\n      execution_order: executionOrder,\n      parent_run: parentRunId ? [parentRunId] : null,\n      start_time: startTime ? startTime.toISOString() : null,\n      error,\n      id,\n      limit,\n      trace: traceId\n    };\n    for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n      yield* runs;\n    }\n  }\n  async shareRun(runId, {\n    shareId\n  } = {}) {\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async listSharedRuns(shareToken, {\n    runIds\n  } = {}) {\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare dataset\");\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  async createProject({\n    projectName,\n    description = null,\n    metadata = null,\n    upsert = false,\n    projectExtra = null,\n    referenceDatasetId = null\n  }) {\n    const upsert_ = upsert ? `?upsert=true` : \"\";\n    const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async updateProject(projectId, {\n    name = null,\n    description = null,\n    metadata = null,\n    projectExtra = null,\n    endTime = null\n  }) {\n    const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async hasProject({\n    projectId,\n    projectName\n  }) {\n    // TODO: Add a head request\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    try {\n      const result = await response.json();\n      if (!response.ok) {\n        return false;\n      }\n      // If it's OK and we're querying by name, need to check the list is not empty\n      if (Array.isArray(result)) {\n        return result.length > 0;\n      }\n      // projectId querying\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async readProject({\n    projectId,\n    projectName,\n    includeStats\n  }) {\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  async *listProjects({\n    projectIds,\n    name,\n    nameContains,\n    referenceDatasetId,\n    referenceDatasetName,\n    referenceFree\n  } = {}) {\n    const params = new URLSearchParams();\n    if (projectIds !== undefined) {\n      for (const projectId of projectIds) {\n        params.append(\"id\", projectId);\n      }\n    }\n    if (name !== undefined) {\n      params.append(\"name\", name);\n    }\n    if (nameContains !== undefined) {\n      params.append(\"name_contains\", nameContains);\n    }\n    if (referenceDatasetId !== undefined) {\n      params.append(\"reference_dataset\", referenceDatasetId);\n    } else if (referenceDatasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName: referenceDatasetName\n      });\n      params.append(\"reference_dataset\", dataset.id);\n    }\n    if (referenceFree !== undefined) {\n      params.append(\"reference_free\", referenceFree.toString());\n    }\n    for await (const projects of this._getPaginated(\"/sessions\", params)) {\n      yield* projects;\n    }\n  }\n  async deleteProject({\n    projectId,\n    projectName\n  }) {\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n  }\n  async uploadCsv({\n    csvFile,\n    fileName,\n    inputKeys,\n    outputKeys,\n    description,\n    dataType,\n    name\n  }) {\n    const url = `${this.apiUrl}/datasets/upload`;\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${fileName} already exists`);\n      }\n      throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name, {\n    description,\n    dataType\n  } = {}) {\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${name} already exists`);\n      }\n      throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      assertUuid(datasetId);\n      path += `/${datasetId}`;\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async readDatasetOpenaiFinetuning({\n    datasetId,\n    datasetName\n  }) {\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  async *listDatasets({\n    limit = 100,\n    offset = 0,\n    datasetIds,\n    datasetName,\n    datasetNameContains\n  } = {}) {\n    const path = \"/datasets\";\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString()\n    });\n    if (datasetIds !== undefined) {\n      for (const id_ of datasetIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    }\n    if (datasetNameContains !== undefined) {\n      params.append(\"name_contains\", datasetNameContains);\n    }\n    for await (const datasets of this._getPaginated(path, params)) {\n      yield* datasets;\n    }\n  }\n  async deleteDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += `/${datasetId_}`;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, {\n    datasetId,\n    datasetName,\n    createdAt,\n    exampleId\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_?.toISOString(),\n      id: exampleId\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createExamples(props) {\n    const {\n      inputs,\n      outputs,\n      sourceRunIds,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = props;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs ? outputs[idx] : undefined,\n        id: exampleIds ? exampleIds[idx] : undefined,\n        source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n      };\n    });\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(formattedExamples),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    return await this._get(path);\n  }\n  async *listExamples({\n    datasetId,\n    datasetName,\n    exampleIds\n  } = {}) {\n    let datasetId_;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      datasetId_ = datasetId;\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      throw new Error(\"Must provide a datasetName or datasetId\");\n    }\n    const params = new URLSearchParams({\n      dataset: datasetId_\n    });\n    if (exampleIds !== undefined) {\n      for (const id_ of exampleIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    for await (const examples of this._getPaginated(\"/examples\", params)) {\n      yield* examples;\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    assertUuid(exampleId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator, {\n    sourceInfo,\n    loadChildRuns,\n    referenceExample\n  } = {\n    loadChildRuns: false\n  }) {\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(`Invalid run type: ${typeof run}`);\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo ?? {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    const runId = feedbackResult.targetRunId ?? run_.id;\n    return await this.createFeedback(runId, feedbackResult.key, {\n      score: feedbackResult?.score,\n      value: feedbackResult?.value,\n      comment: feedbackResult?.comment,\n      correction: feedbackResult?.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"model\",\n      sourceRunId: feedbackResult?.sourceRunId\n    });\n  }\n  async createFeedback(runId, key, {\n    score,\n    value,\n    correction,\n    comment,\n    sourceInfo,\n    feedbackSourceType = \"api\",\n    sourceRunId,\n    feedbackId,\n    eager = false\n  }) {\n    const feedback_source = {\n      type: feedbackSourceType ?? \"api\",\n      metadata: sourceInfo ?? {}\n    };\n    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId ?? uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source\n    };\n    const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create feedback\");\n    return feedback;\n  }\n  async updateFeedback(feedbackId, {\n    score,\n    value,\n    correction,\n    comment\n  }) {\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update feedback\");\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async *listFeedback({\n    runIds,\n    feedbackKeys,\n    feedbackSourceTypes\n  } = {}) {\n    const queryParams = new URLSearchParams();\n    if (runIds) {\n      queryParams.append(\"run\", runIds.join(\",\"));\n    }\n    if (feedbackKeys) {\n      for (const key of feedbackKeys) {\n        queryParams.append(\"key\", key);\n      }\n    }\n    if (feedbackSourceTypes) {\n      for (const type of feedbackSourceTypes) {\n        queryParams.append(\"source\", type);\n      }\n    }\n    for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n      yield* feedbacks;\n    }\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getRuntimeEnvironment","__version__","mergeRuntimeEnvIntoRunCreates","runs","runtimeEnv","envVars","map","run","extra","metadata","runtime","revision_id","getTracingSamplingRate","samplingRateStr","undefined","samplingRate","parseFloat","Error","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","trim","assertUuid","validate","Queue","constructor","Object","defineProperty","enumerable","configurable","writable","value","size","items","length","Promise","resolve","pop","upToN","popped","shift","it","forEach","Client","config","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","apiUrl","apiKey","webUrl","validateApiKeyIfHosted","timeout_ms","caller","callerOptions","hideInputs","hideOutputs","autoBatchTracing","pendingAutoBatchedRunLimit","isLocal","getHostUrl","includes","endsWith","headers","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","path","queryParams","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","_get","json","_getPaginated","URLSearchParams","offset","Number","get","limit","set","String","_getCursorPaginatedList","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_filterForSampling","patch","sampled","sampledPostUuids","has","id","delete","Math","random","add","drainAutoBatchQueue","autoBatchQueue","batch","done","batchIngestRuns","runCreates","filter","action","runUpdates","processRunOperation","immediatelyTriggerBatch","oldTimeout","autoBatchTimeout","clearTimeout","itemPromise","setTimeout","autoBatchAggregationDelayMs","autoBatchInitialDelayMs","batchEndpointIsSupported","Accept","createRun","session_name","project_name","runCreate","start_time","Date","now","trace_id","dotted_order","mergedRunCreateParams","preparedCreateParams","create","preparedUpdateParams","update","createById","reduce","params","standaloneUpdates","updateParam","values","post","batchEndpointSupported","preparedCreateParam","preparedUpdateParam","updateRun","runId","data","end_time","parent_run_id","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","treemap","sort","a","b","localeCompare","childRun","child_runs","parentRunId","traceId","referenceExampleId","startTime","executionOrder","runType","error","query","projectIds","Array","isArray","projectNames","projectIds_","all","name","then","session","run_type","reference_example","execution_order","parent_run","toISOString","trace","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","runIds","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","createProject","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","updateProject","endTime","hasProject","e","includeStats","_tenantId","projects","tenant_id","listProjects","nameContains","referenceDatasetName","referenceFree","deleteProject","projectId_","uploadCsv","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","key","detail","createDataset","data_type","readDatasetOpenaiFinetuning","datasetText","line","parse","listDatasets","datasetIds","datasetNameContains","id_","datasets","deleteDataset","datasetId_","createExample","createdAt","exampleId","createdAt_","created_at","createExamples","props","sourceRunIds","exampleIds","formattedExamples","input","idx","source_run_id","createLLMExample","generation","options","output","createChatExample","generations","finalInput","message","finalOutput","readExample","listExamples","examples","deleteExample","updateExample","evaluateRun","evaluator","sourceInfo","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","targetRunId","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","feedbackId","eager","feedback_source","type","feedback","updateFeedback","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","feedbackKeys","feedbackSourceTypes","join","feedbacks"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    return runs.map((run) => {\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime,\n            },\n            metadata: {\n                ...envVars,\n                ...(envVars.revision_id || run.revision_id\n                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n                    : {}),\n                ...metadata,\n            },\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid.validate(str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nexport class Queue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    get size() {\n        return this.items.length;\n    }\n    push(item) {\n        // this.items.push is synchronous with promise creation:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n        return new Promise((resolve) => {\n            this.items.push([item, resolve]);\n        });\n    }\n    pop(upToN) {\n        if (upToN < 1) {\n            throw new Error(\"Number of items to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        while (popped.length < upToN && this.items.length) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n            }\n            else {\n                break;\n            }\n        }\n        return [popped.map((it) => it[0]), () => popped.forEach((it) => it[1]())];\n    }\n}\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit =\n            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs) {\n            return {};\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs) {\n            return {};\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async drainAutoBatchQueue() {\n        while (this.autoBatchQueue.size >= 0) {\n            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                await this.batchIngestRuns({\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                });\n            }\n            finally {\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (immediatelyTriggerBatch ||\n            this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n            await this.drainAutoBatchQueue();\n        }\n        if (this.autoBatchQueue.size > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue();\n            }, oldTimeout\n                ? this.autoBatchAggregationDelayMs\n                : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async batchEndpointIsSupported() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: { Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n            });\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate,\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const body = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!body.post.length && !body.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of body.post) {\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of body.patch) {\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({ action: \"update\", item: data }, true);\n                return;\n            }\n            else {\n                void this.processRunOperation({ action: \"update\", item: data });\n            }\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, limit, }) {\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            execution_order: executionOrder,\n            parent_run: parentRunId ? [parentRunId] : null,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId,\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, eager = false, }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n        };\n        const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}