{"ast":null,"code":"// utils -> extractMetaData\n\nimport { DOMParser } from 'linkedom';\nimport extractLdSchema from './extractLdSchema.js';\n\n/**\n * @param {Element} node\n * @param {Object} attributeLists\n * @returns {?{key: string, content: string}}\n */\nfunction getMetaContentByNameOrProperty(node, attributeLists) {\n  var _node$getAttribute$to, _node$getAttribute, _node$getAttribute2, _node$getAttribute3;\n  const content = node.getAttribute('content');\n  if (!content) return null;\n  const property = (_node$getAttribute$to = (_node$getAttribute = node.getAttribute('property')) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.toLowerCase()) !== null && _node$getAttribute$to !== void 0 ? _node$getAttribute$to : (_node$getAttribute2 = node.getAttribute('itemprop')) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.toLowerCase();\n  const name = (_node$getAttribute3 = node.getAttribute('name')) === null || _node$getAttribute3 === void 0 ? void 0 : _node$getAttribute3.toLowerCase();\n  for (const [key, attrs] of Object.entries(attributeLists)) {\n    if (attrs.includes(property) || attrs.includes(name)) {\n      return {\n        key,\n        content\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * @param html {string}\n * @returns {{image: string, author: string, amphtml: string, description: string, canonical: string, source: string, published: string, title: string, url: string, shortlink: string, favicon: string, type: string}}\n */\nexport default (html => {\n  var _document$querySelect;\n  const entry = {\n    url: '',\n    shortlink: '',\n    amphtml: '',\n    canonical: '',\n    title: '',\n    description: '',\n    image: '',\n    author: '',\n    source: '',\n    published: '',\n    favicon: '',\n    type: ''\n  };\n  const sourceAttrs = ['application-name', 'og:site_name', 'twitter:site', 'dc.title'];\n  const urlAttrs = ['og:url', 'twitter:url', 'parsely-link'];\n  const titleAttrs = ['title', 'og:title', 'twitter:title', 'parsely-title'];\n  const descriptionAttrs = ['description', 'og:description', 'twitter:description', 'parsely-description'];\n  const imageAttrs = ['image', 'og:image', 'og:image:url', 'og:image:secure_url', 'twitter:image', 'twitter:image:src', 'parsely-image-url'];\n  const authorAttrs = ['author', 'creator', 'og:creator', 'article:author', 'twitter:creator', 'dc.creator', 'parsely-author'];\n  const publishedTimeAttrs = ['article:published_time', 'article:modified_time', 'og:updated_time', 'dc.date', 'dc.date.issued', 'dc.date.created', 'dc:created', 'dcterms.date', 'datepublished', 'datemodified', 'updated_time', 'modified_time', 'published_time', 'release_date', 'date', 'parsely-pub-date'];\n  const typeAttrs = ['og:type'];\n  const attributeLists = {\n    source: sourceAttrs,\n    url: urlAttrs,\n    title: titleAttrs,\n    description: descriptionAttrs,\n    image: imageAttrs,\n    author: authorAttrs,\n    published: publishedTimeAttrs,\n    type: typeAttrs\n  };\n  const document = new DOMParser().parseFromString(html, 'text/html');\n  entry.title = (_document$querySelect = document.querySelector('head > title')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.innerText;\n  Array.from(document.getElementsByTagName('link')).forEach(node => {\n    const rel = node.getAttribute('rel');\n    const href = node.getAttribute('href');\n    if (rel && href) {\n      entry[rel] = href;\n      if (rel === 'icon' || rel === 'shortcut icon') {\n        entry.favicon = href;\n      }\n    }\n  });\n  Array.from(document.getElementsByTagName('meta')).forEach(node => {\n    const result = getMetaContentByNameOrProperty(node, attributeLists);\n    if (result) {\n      entry[result.key] = result.content;\n    }\n  });\n  const entries = extractLdSchema(document, entry);\n  return entries;\n});","map":{"version":3,"names":["DOMParser","extractLdSchema","getMetaContentByNameOrProperty","node","attributeLists","_node$getAttribute$to","_node$getAttribute","_node$getAttribute2","_node$getAttribute3","content","getAttribute","property","toLowerCase","name","key","attrs","Object","entries","includes","html","_document$querySelect","entry","url","shortlink","amphtml","canonical","title","description","image","author","source","published","favicon","type","sourceAttrs","urlAttrs","titleAttrs","descriptionAttrs","imageAttrs","authorAttrs","publishedTimeAttrs","typeAttrs","document","parseFromString","querySelector","innerText","Array","from","getElementsByTagName","forEach","rel","href","result"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@extractus/article-extractor/src/utils/extractMetaData.js"],"sourcesContent":["// utils -> extractMetaData\n\nimport { DOMParser } from 'linkedom'\nimport extractLdSchema from './extractLdSchema.js'\n\n/**\n * @param {Element} node\n * @param {Object} attributeLists\n * @returns {?{key: string, content: string}}\n */\nfunction getMetaContentByNameOrProperty (node, attributeLists) {\n  const content = node.getAttribute('content')\n  if (!content) return null\n\n  const property = node\n    .getAttribute('property')?.toLowerCase() ??\n    node.getAttribute('itemprop')?.toLowerCase()\n\n  const name = node.getAttribute('name')?.toLowerCase()\n\n  for (const [key, attrs] of Object.entries(attributeLists)) {\n    if (attrs.includes(property) || attrs.includes(name)) {\n      return { key, content }\n    }\n  }\n\n  return null\n}\n\n/**\n * @param html {string}\n * @returns {{image: string, author: string, amphtml: string, description: string, canonical: string, source: string, published: string, title: string, url: string, shortlink: string, favicon: string, type: string}}\n */\nexport default (html) => {\n  const entry = {\n    url: '',\n    shortlink: '',\n    amphtml: '',\n    canonical: '',\n    title: '',\n    description: '',\n    image: '',\n    author: '',\n    source: '',\n    published: '',\n    favicon: '',\n    type: '',\n  }\n\n  const sourceAttrs = [\n    'application-name',\n    'og:site_name',\n    'twitter:site',\n    'dc.title',\n  ]\n  const urlAttrs = [\n    'og:url',\n    'twitter:url',\n    'parsely-link',\n  ]\n  const titleAttrs = [\n    'title',\n    'og:title',\n    'twitter:title',\n    'parsely-title',\n  ]\n  const descriptionAttrs = [\n    'description',\n    'og:description',\n    'twitter:description',\n    'parsely-description',\n  ]\n  const imageAttrs = [\n    'image',\n    'og:image',\n    'og:image:url',\n    'og:image:secure_url',\n    'twitter:image',\n    'twitter:image:src',\n    'parsely-image-url',\n  ]\n  const authorAttrs = [\n    'author',\n    'creator',\n    'og:creator',\n    'article:author',\n    'twitter:creator',\n    'dc.creator',\n    'parsely-author',\n  ]\n  const publishedTimeAttrs = [\n    'article:published_time',\n    'article:modified_time',\n    'og:updated_time',\n    'dc.date',\n    'dc.date.issued',\n    'dc.date.created',\n    'dc:created',\n    'dcterms.date',\n    'datepublished',\n    'datemodified',\n    'updated_time',\n    'modified_time',\n    'published_time',\n    'release_date',\n    'date',\n    'parsely-pub-date',\n  ]\n  const typeAttrs = [\n    'og:type',\n  ]\n\n  const attributeLists = {\n    source: sourceAttrs,\n    url: urlAttrs,\n    title: titleAttrs,\n    description: descriptionAttrs,\n    image: imageAttrs,\n    author: authorAttrs,\n    published: publishedTimeAttrs,\n    type: typeAttrs,\n  }\n\n  const document = new DOMParser().parseFromString(html, 'text/html')\n  entry.title = document.querySelector('head > title')?.innerText\n\n  Array.from(document.getElementsByTagName('link')).forEach(node => {\n    const rel = node.getAttribute('rel')\n    const href = node.getAttribute('href')\n    if (rel && href) {\n      entry[rel] = href\n      if (rel === 'icon' || rel === 'shortcut icon') {\n        entry.favicon = href\n      }\n    }\n  })\n\n  Array.from(document.getElementsByTagName('meta')).forEach(node => {\n    const result = getMetaContentByNameOrProperty(node, attributeLists)\n    if (result) {\n      entry[result.key] = result.content\n    }\n  })\n\n  const entries = extractLdSchema(document, entry)\n\n  return entries\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}