{"ast":null,"code":"import { AIMessage, HumanMessage, isBaseMessage } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n  constructor(fields) {\n    var _fields$historyMessag, _fields$config;\n    let historyChain = new RunnableLambda({\n      func: (input, options) => this._enterHistory(input, options !== null && options !== void 0 ? options : {})\n    }).withConfig({\n      runName: \"loadHistory\"\n    });\n    const messagesKey = (_fields$historyMessag = fields.historyMessagesKey) !== null && _fields$historyMessag !== void 0 ? _fields$historyMessag : fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain\n      }).withConfig({\n        runName: \"insertHistory\"\n      });\n    }\n    const bound = historyChain.pipe(fields.runnable.withListeners({\n      onEnd: (run, config) => this._exitHistory(run, config !== null && config !== void 0 ? config : {})\n    })).withConfig({\n      runName: \"RunnableWithMessageHistory\"\n    });\n    const config = (_fields$config = fields.config) !== null && _fields$config !== void 0 ? _fields$config : {};\n    super({\n      ...fields,\n      config,\n      bound\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"historyMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"getMessageHistory\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n  _getInputMessages(inputValue) {\n    if (typeof inputValue === \"string\") {\n      return [new HumanMessage(inputValue)];\n    } else if (Array.isArray(inputValue)) {\n      return inputValue;\n    } else {\n      return [inputValue];\n    }\n  }\n  _getOutputMessages(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  outputValue) {\n    let newOutputValue = outputValue;\n    if (!Array.isArray(outputValue) && !isBaseMessage(outputValue) && typeof outputValue !== \"string\") {\n      var _this$outputMessagesK;\n      newOutputValue = outputValue[(_this$outputMessagesK = this.outputMessagesKey) !== null && _this$outputMessagesK !== void 0 ? _this$outputMessagesK : \"output\"];\n    }\n    if (typeof newOutputValue === \"string\") {\n      return [new AIMessage(newOutputValue)];\n    } else if (Array.isArray(newOutputValue)) {\n      return newOutputValue;\n    } else if (isBaseMessage(newOutputValue)) {\n      return [newOutputValue];\n    }\n    throw new Error(\"Expected a string, BaseMessage, or array of BaseMessages. Received: \".concat(JSON.stringify(newOutputValue, null, 2)));\n  }\n  async _enterHistory(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input, kwargs) {\n    var _kwargs$config;\n    const history = kwargs === null || kwargs === void 0 || (_kwargs$config = kwargs.config) === null || _kwargs$config === void 0 || (_kwargs$config = _kwargs$config.configurable) === null || _kwargs$config === void 0 ? void 0 : _kwargs$config.messageHistory;\n    if (this.historyMessagesKey) {\n      return history.getMessages();\n    }\n    const inputVal = input || (this.inputMessagesKey ? input[this.inputMessagesKey] : undefined);\n    const historyMessages = history ? await history.getMessages() : [];\n    const returnType = [...historyMessages, ...this._getInputMessages(inputVal)];\n    return returnType;\n  }\n  async _exitHistory(run, config) {\n    var _config$configurable, _this$inputMessagesKe;\n    const history = (_config$configurable = config.configurable) === null || _config$configurable === void 0 ? void 0 : _config$configurable.messageHistory;\n    // Get input messages\n    const {\n      inputs\n    } = run;\n    const inputValue = inputs[(_this$inputMessagesKe = this.inputMessagesKey) !== null && _this$inputMessagesKe !== void 0 ? _this$inputMessagesKe : \"input\"];\n    const inputMessages = this._getInputMessages(inputValue);\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\"Output values from 'Run' undefined. Run: \".concat(JSON.stringify(run, null, 2)));\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    for await (const message of [...inputMessages, ...outputMessages]) {\n      await history.addMessage(message);\n    }\n  }\n  async _mergeConfig() {\n    const config = await super._mergeConfig(...arguments);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      var _this$inputMessagesKe2;\n      const exampleInput = {\n        [(_this$inputMessagesKe2 = this.inputMessagesKey) !== null && _this$inputMessagesKe2 !== void 0 ? _this$inputMessagesKe2 : \"input\"]: \"foo\"\n      };\n      const exampleConfig = {\n        configurable: {\n          sessionId: \"123\"\n        }\n      };\n      throw new Error(\"sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n\" + \"eg. chain.invoke(\".concat(JSON.stringify(exampleInput), \", \").concat(JSON.stringify(exampleConfig), \")\"));\n    }\n    // attach messageHistory\n    const {\n      sessionId\n    } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n    return config;\n  }\n}","map":{"version":3,"names":["AIMessage","HumanMessage","isBaseMessage","RunnableBinding","RunnableLambda","RunnablePassthrough","RunnableWithMessageHistory","constructor","fields","_fields$historyMessag","_fields$config","historyChain","func","input","options","_enterHistory","withConfig","runName","messagesKey","historyMessagesKey","inputMessagesKey","assign","bound","pipe","runnable","withListeners","onEnd","run","config","_exitHistory","Object","defineProperty","enumerable","configurable","writable","value","getMessageHistory","outputMessagesKey","_getInputMessages","inputValue","Array","isArray","_getOutputMessages","outputValue","newOutputValue","_this$outputMessagesK","Error","concat","JSON","stringify","kwargs","_kwargs$config","history","messageHistory","getMessages","inputVal","undefined","historyMessages","returnType","_config$configurable","_this$inputMessagesKe","inputs","inputMessages","outputs","outputMessages","message","addMessage","_mergeConfig","arguments","sessionId","_this$inputMessagesKe2","exampleInput","exampleConfig"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/history.js"],"sourcesContent":["import { AIMessage, HumanMessage, isBaseMessage, } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda, } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n    constructor(fields) {\n        let historyChain = new RunnableLambda({\n            func: (input, options) => this._enterHistory(input, options ?? {}),\n        }).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(inputValue) {\n        if (typeof inputValue === \"string\") {\n            return [new HumanMessage(inputValue)];\n        }\n        else if (Array.isArray(inputValue)) {\n            return inputValue;\n        }\n        else {\n            return [inputValue];\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let newOutputValue = outputValue;\n        if (!Array.isArray(outputValue) &&\n            !isBaseMessage(outputValue) &&\n            typeof outputValue !== \"string\") {\n            newOutputValue = outputValue[this.outputMessagesKey ?? \"output\"];\n        }\n        if (typeof newOutputValue === \"string\") {\n            return [new AIMessage(newOutputValue)];\n        }\n        else if (Array.isArray(newOutputValue)) {\n            return newOutputValue;\n        }\n        else if (isBaseMessage(newOutputValue)) {\n            return [newOutputValue];\n        }\n        throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(newOutputValue, null, 2)}`);\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.config?.configurable?.messageHistory;\n        if (this.historyMessagesKey) {\n            return history.getMessages();\n        }\n        const inputVal = input ||\n            (this.inputMessagesKey ? input[this.inputMessagesKey] : undefined);\n        const historyMessages = history ? await history.getMessages() : [];\n        const returnType = [\n            ...historyMessages,\n            ...this._getInputMessages(inputVal),\n        ];\n        return returnType;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        const { inputs } = run;\n        const inputValue = inputs[this.inputMessagesKey ?? \"input\"];\n        const inputMessages = this._getInputMessages(inputValue);\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        for await (const message of [...inputMessages, ...outputMessages]) {\n            await history.addMessage(message);\n        }\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}