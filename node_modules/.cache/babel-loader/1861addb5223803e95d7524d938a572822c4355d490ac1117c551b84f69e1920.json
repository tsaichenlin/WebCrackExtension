{"ast":null,"code":"/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\n/**\n * Public constructor.\n * @param {HTMLDocument} doc     The document to parse.\n * @param {Object}       options The options object.\n */\nfunction Readability(doc, options) {\n  // In some older versions, people passed a URI as the first argument. Cope:\n  if (options && options.documentElement) {\n    doc = options;\n    options = arguments[2];\n  } else if (!doc || !doc.documentElement) {\n    throw new Error(\"First argument to Readability constructor should be a document object.\");\n  }\n  options = options || {};\n  this._doc = doc;\n  this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;\n  this._articleTitle = null;\n  this._articleByline = null;\n  this._articleDir = null;\n  this._articleSiteName = null;\n  this._attempts = [];\n\n  // Configurable options\n  this._debug = !!options.debug;\n  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;\n  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;\n  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;\n  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);\n  this._keepClasses = !!options.keepClasses;\n  this._serializer = options.serializer || function (el) {\n    return el.innerHTML;\n  };\n  this._disableJSONLD = !!options.disableJSONLD;\n  this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;\n\n  // Start with all flags set\n  this._flags = this.FLAG_STRIP_UNLIKELYS | this.FLAG_WEIGHT_CLASSES | this.FLAG_CLEAN_CONDITIONALLY;\n\n  // Control whether log messages are sent to the console\n  if (this._debug) {\n    let logNode = function (node) {\n      if (node.nodeType == node.TEXT_NODE) {\n        return \"\".concat(node.nodeName, \" (\\\"\").concat(node.textContent, \"\\\")\");\n      }\n      let attrPairs = Array.from(node.attributes || [], function (attr) {\n        return \"\".concat(attr.name, \"=\\\"\").concat(attr.value, \"\\\"\");\n      }).join(\" \");\n      return \"<\".concat(node.localName, \" \").concat(attrPairs, \">\");\n    };\n    this.log = function () {\n      if (typeof console !== \"undefined\") {\n        let args = Array.from(arguments, arg => {\n          if (arg && arg.nodeType == this.ELEMENT_NODE) {\n            return logNode(arg);\n          }\n          return arg;\n        });\n        args.unshift(\"Reader: (Readability)\");\n        console.log.apply(console, args);\n      } else if (typeof dump !== \"undefined\") {\n        /* global dump */\n        var msg = Array.prototype.map.call(arguments, function (x) {\n          return x && x.nodeName ? logNode(x) : x;\n        }).join(\" \");\n        dump(\"Reader: (Readability) \" + msg + \"\\n\");\n      }\n    };\n  } else {\n    this.log = function () {};\n  }\n}\nReadability.prototype = {\n  FLAG_STRIP_UNLIKELYS: 0x1,\n  FLAG_WEIGHT_CLASSES: 0x2,\n  FLAG_CLEAN_CONDITIONALLY: 0x4,\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n  // Max number of nodes supported by this parser. Default: 0 (no limit)\n  DEFAULT_MAX_ELEMS_TO_PARSE: 0,\n  // The number of top candidates to consider when analysing how\n  // tight the competition is among candidates.\n  DEFAULT_N_TOP_CANDIDATES: 5,\n  // Element tags to score by default.\n  DEFAULT_TAGS_TO_SCORE: \"section,h2,h3,h4,h5,h6,p,td,pre\".toUpperCase().split(\",\"),\n  // The default number of chars an article must have in order to return a result\n  DEFAULT_CHAR_THRESHOLD: 500,\n  // All of the regular expressions in use within readability.\n  // Defined up here so we don't instantiate them repeatedly in loops.\n  REGEXPS: {\n    // NOTE: These two regular expressions are duplicated in\n    // Readability-readerable.js. Please keep both copies in sync.\n    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,\n    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,\n    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,\n    negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,\n    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,\n    byline: /byline|author|dateline|writtenby|p-author/i,\n    replaceFonts: /<(\\/?)font[^>]*>/gi,\n    normalize: /\\s{2,}/g,\n    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,\n    shareElements: /(\\b|_)(share|sharedaddy)(\\b|_)/i,\n    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,\n    prevLink: /(prev|earl|old|new|<|«)/i,\n    tokenize: /\\W+/g,\n    whitespace: /^\\s*$/,\n    hasContent: /\\S$/,\n    hashUrl: /^#.+/,\n    srcsetUrl: /(\\S+)(\\s+[\\d.]+[xw])?(\\s*(?:,|$))/g,\n    b64DataUrl: /^data:\\s*([^\\s;,]+)\\s*;\\s*base64\\s*,/i,\n    // Commas as used in Latin, Sindhi, Chinese and various other scripts.\n    // see: https://en.wikipedia.org/wiki/Comma#Comma_variants\n    commas: /\\u002C|\\u060C|\\uFE50|\\uFE10|\\uFE11|\\u2E41|\\u2E34|\\u2E32|\\uFF0C/g,\n    // See: https://schema.org/Article\n    jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/\n  },\n  UNLIKELY_ROLES: [\"menu\", \"menubar\", \"complementary\", \"navigation\", \"alert\", \"alertdialog\", \"dialog\"],\n  DIV_TO_P_ELEMS: new Set([\"BLOCKQUOTE\", \"DL\", \"DIV\", \"IMG\", \"OL\", \"P\", \"PRE\", \"TABLE\", \"UL\"]),\n  ALTER_TO_DIV_EXCEPTIONS: [\"DIV\", \"ARTICLE\", \"SECTION\", \"P\"],\n  PRESENTATIONAL_ATTRIBUTES: [\"align\", \"background\", \"bgcolor\", \"border\", \"cellpadding\", \"cellspacing\", \"frame\", \"hspace\", \"rules\", \"style\", \"valign\", \"vspace\"],\n  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: [\"TABLE\", \"TH\", \"TD\", \"HR\", \"PRE\"],\n  // The commented out elements qualify as phrasing content but tend to be\n  // removed by readability when put into paragraphs, so we ignore them here.\n  PHRASING_ELEMS: [\n  // \"CANVAS\", \"IFRAME\", \"SVG\", \"VIDEO\",\n  \"ABBR\", \"AUDIO\", \"B\", \"BDO\", \"BR\", \"BUTTON\", \"CITE\", \"CODE\", \"DATA\", \"DATALIST\", \"DFN\", \"EM\", \"EMBED\", \"I\", \"IMG\", \"INPUT\", \"KBD\", \"LABEL\", \"MARK\", \"MATH\", \"METER\", \"NOSCRIPT\", \"OBJECT\", \"OUTPUT\", \"PROGRESS\", \"Q\", \"RUBY\", \"SAMP\", \"SCRIPT\", \"SELECT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\", \"SUP\", \"TEXTAREA\", \"TIME\", \"VAR\", \"WBR\"],\n  // These are the classes that readability sets itself.\n  CLASSES_TO_PRESERVE: [\"page\"],\n  // These are the list of HTML entities that need to be escaped.\n  HTML_ESCAPE_MAP: {\n    \"lt\": \"<\",\n    \"gt\": \">\",\n    \"amp\": \"&\",\n    \"quot\": '\"',\n    \"apos\": \"'\"\n  },\n  /**\n   * Run any post-process modifications to article content as necessary.\n   *\n   * @param Element\n   * @return void\n  **/\n  _postProcessContent: function (articleContent) {\n    // Readability cannot open relative uris so we convert them to absolute uris.\n    this._fixRelativeUris(articleContent);\n    this._simplifyNestedElements(articleContent);\n    if (!this._keepClasses) {\n      // Remove classes.\n      this._cleanClasses(articleContent);\n    }\n  },\n  /**\n   * Iterates over a NodeList, calls `filterFn` for each node and removes node\n   * if function returned `true`.\n   *\n   * If function is not passed, removes all the nodes in node list.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param Function filterFn the function to use as a filter\n   * @return void\n   */\n  _removeNodes: function (nodeList, filterFn) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _removeNodes\");\n    }\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      var parentNode = node.parentNode;\n      if (parentNode) {\n        if (!filterFn || filterFn.call(this, node, i, nodeList)) {\n          parentNode.removeChild(node);\n        }\n      }\n    }\n  },\n  /**\n   * Iterates over a NodeList, and calls _setNodeTag for each node.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param String newTagName the new tag name to use\n   * @return void\n   */\n  _replaceNodeTags: function (nodeList, newTagName) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _replaceNodeTags\");\n    }\n    for (const node of nodeList) {\n      this._setNodeTag(node, newTagName);\n    }\n  },\n  /**\n   * Iterate over a NodeList, which doesn't natively fully implement the Array\n   * interface.\n   *\n   * For convenience, the current object context is applied to the provided\n   * iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return void\n   */\n  _forEachNode: function (nodeList, fn) {\n    Array.prototype.forEach.call(nodeList, fn, this);\n  },\n  /**\n   * Iterate over a NodeList, and return the first node that passes\n   * the supplied test function\n   *\n   * For convenience, the current object context is applied to the provided\n   * test function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The test function.\n   * @return void\n   */\n  _findNode: function (nodeList, fn) {\n    return Array.prototype.find.call(nodeList, fn, this);\n  },\n  /**\n   * Iterate over a NodeList, return true if any of the provided iterate\n   * function calls returns true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _someNode: function (nodeList, fn) {\n    return Array.prototype.some.call(nodeList, fn, this);\n  },\n  /**\n   * Iterate over a NodeList, return true if all of the provided iterate\n   * function calls return true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _everyNode: function (nodeList, fn) {\n    return Array.prototype.every.call(nodeList, fn, this);\n  },\n  /**\n   * Concat all nodelists passed as arguments.\n   *\n   * @return ...NodeList\n   * @return Array\n   */\n  _concatNodeLists: function () {\n    var slice = Array.prototype.slice;\n    var args = slice.call(arguments);\n    var nodeLists = args.map(function (list) {\n      return slice.call(list);\n    });\n    return Array.prototype.concat.apply([], nodeLists);\n  },\n  _getAllNodesWithTag: function (node, tagNames) {\n    if (node.querySelectorAll) {\n      return node.querySelectorAll(tagNames.join(\",\"));\n    }\n    return [].concat.apply([], tagNames.map(function (tag) {\n      var collection = node.getElementsByTagName(tag);\n      return Array.isArray(collection) ? collection : Array.from(collection);\n    }));\n  },\n  /**\n   * Removes the class=\"\" attribute from every element in the given\n   * subtree, except those that match CLASSES_TO_PRESERVE and\n   * the classesToPreserve array from the options object.\n   *\n   * @param Element\n   * @return void\n   */\n  _cleanClasses: function (node) {\n    var classesToPreserve = this._classesToPreserve;\n    var className = (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter(function (cls) {\n      return classesToPreserve.indexOf(cls) != -1;\n    }).join(\" \");\n    if (className) {\n      node.setAttribute(\"class\", className);\n    } else {\n      node.removeAttribute(\"class\");\n    }\n    for (node = node.firstElementChild; node; node = node.nextElementSibling) {\n      this._cleanClasses(node);\n    }\n  },\n  /**\n   * Converts each <a> and <img> uri in the given element to an absolute URI,\n   * ignoring #ref URIs.\n   *\n   * @param Element\n   * @return void\n   */\n  _fixRelativeUris: function (articleContent) {\n    var baseURI = this._doc.baseURI;\n    var documentURI = this._doc.documentURI;\n    function toAbsoluteURI(uri) {\n      // Leave hash links alone if the base URI matches the document URI:\n      if (baseURI == documentURI && uri.charAt(0) == \"#\") {\n        return uri;\n      }\n\n      // Otherwise, resolve against base URI:\n      try {\n        return new URL(uri, baseURI).href;\n      } catch (ex) {\n        // Something went wrong, just return the original:\n      }\n      return uri;\n    }\n    var links = this._getAllNodesWithTag(articleContent, [\"a\"]);\n    this._forEachNode(links, function (link) {\n      var href = link.getAttribute(\"href\");\n      if (href) {\n        // Remove links with javascript: URIs, since\n        // they won't work after scripts have been removed from the page.\n        if (href.indexOf(\"javascript:\") === 0) {\n          // if the link only contains simple text content, it can be converted to a text node\n          if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {\n            var text = this._doc.createTextNode(link.textContent);\n            link.parentNode.replaceChild(text, link);\n          } else {\n            // if the link has multiple children, they should all be preserved\n            var container = this._doc.createElement(\"span\");\n            while (link.firstChild) {\n              container.appendChild(link.firstChild);\n            }\n            link.parentNode.replaceChild(container, link);\n          }\n        } else {\n          link.setAttribute(\"href\", toAbsoluteURI(href));\n        }\n      }\n    });\n    var medias = this._getAllNodesWithTag(articleContent, [\"img\", \"picture\", \"figure\", \"video\", \"audio\", \"source\"]);\n    this._forEachNode(medias, function (media) {\n      var src = media.getAttribute(\"src\");\n      var poster = media.getAttribute(\"poster\");\n      var srcset = media.getAttribute(\"srcset\");\n      if (src) {\n        media.setAttribute(\"src\", toAbsoluteURI(src));\n      }\n      if (poster) {\n        media.setAttribute(\"poster\", toAbsoluteURI(poster));\n      }\n      if (srcset) {\n        var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function (_, p1, p2, p3) {\n          return toAbsoluteURI(p1) + (p2 || \"\") + p3;\n        });\n        media.setAttribute(\"srcset\", newSrcset);\n      }\n    });\n  },\n  _simplifyNestedElements: function (articleContent) {\n    var node = articleContent;\n    while (node) {\n      if (node.parentNode && [\"DIV\", \"SECTION\"].includes(node.tagName) && !(node.id && node.id.startsWith(\"readability\"))) {\n        if (this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        } else if (this._hasSingleTagInsideElement(node, \"DIV\") || this._hasSingleTagInsideElement(node, \"SECTION\")) {\n          var child = node.children[0];\n          for (var i = 0; i < node.attributes.length; i++) {\n            child.setAttribute(node.attributes[i].name, node.attributes[i].value);\n          }\n          node.parentNode.replaceChild(child, node);\n          node = child;\n          continue;\n        }\n      }\n      node = this._getNextNode(node);\n    }\n  },\n  /**\n   * Get the article title as an H1.\n   *\n   * @return string\n   **/\n  _getArticleTitle: function () {\n    var doc = this._doc;\n    var curTitle = \"\";\n    var origTitle = \"\";\n    try {\n      curTitle = origTitle = doc.title.trim();\n\n      // If they had an element with id \"title\" in their HTML\n      if (typeof curTitle !== \"string\") curTitle = origTitle = this._getInnerText(doc.getElementsByTagName(\"title\")[0]);\n    } catch (e) {/* ignore exceptions setting the title. */}\n    var titleHadHierarchicalSeparators = false;\n    function wordCount(str) {\n      return str.split(/\\s+/).length;\n    }\n\n    // If there's a separator in the title, first remove the final part\n    if (/ [\\|\\-\\\\\\/>»] /.test(curTitle)) {\n      titleHadHierarchicalSeparators = / [\\\\\\/>»] /.test(curTitle);\n      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>»] .*/gi, \"$1\");\n\n      // If the resulting title is too short (3 words or fewer), remove\n      // the first part instead:\n      if (wordCount(curTitle) < 3) curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>»]*[\\|\\-\\\\\\/>»](.*)/gi, \"$1\");\n    } else if (curTitle.indexOf(\": \") !== -1) {\n      // Check if we have an heading containing this exact string, so we\n      // could assume it's the full title.\n      var headings = this._concatNodeLists(doc.getElementsByTagName(\"h1\"), doc.getElementsByTagName(\"h2\"));\n      var trimmedTitle = curTitle.trim();\n      var match = this._someNode(headings, function (heading) {\n        return heading.textContent.trim() === trimmedTitle;\n      });\n\n      // If we don't, let's extract the title out of the original title string.\n      if (!match) {\n        curTitle = origTitle.substring(origTitle.lastIndexOf(\":\") + 1);\n\n        // If the title is now too short, try the first colon instead:\n        if (wordCount(curTitle) < 3) {\n          curTitle = origTitle.substring(origTitle.indexOf(\":\") + 1);\n          // But if we have too many words before the colon there's something weird\n          // with the titles and the H tags so let's just use the original title instead\n        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(\":\"))) > 5) {\n          curTitle = origTitle;\n        }\n      }\n    } else if (curTitle.length > 150 || curTitle.length < 15) {\n      var hOnes = doc.getElementsByTagName(\"h1\");\n      if (hOnes.length === 1) curTitle = this._getInnerText(hOnes[0]);\n    }\n    curTitle = curTitle.trim().replace(this.REGEXPS.normalize, \" \");\n    // If we now have 4 words or fewer as our title, and either no\n    // 'hierarchical' separators (\\, /, > or ») were found in the original\n    // title or we decreased the number of words by more than 1 word, use\n    // the original title.\n    var curTitleWordCount = wordCount(curTitle);\n    if (curTitleWordCount <= 4 && (!titleHadHierarchicalSeparators || curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>»]+/g, \"\")) - 1)) {\n      curTitle = origTitle;\n    }\n    return curTitle;\n  },\n  /**\n   * Prepare the HTML document for readability to scrape it.\n   * This includes things like stripping javascript, CSS, and handling terrible markup.\n   *\n   * @return void\n   **/\n  _prepDocument: function () {\n    var doc = this._doc;\n\n    // Remove all style tags in head\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"style\"]));\n    if (doc.body) {\n      this._replaceBrs(doc.body);\n    }\n    this._replaceNodeTags(this._getAllNodesWithTag(doc, [\"font\"]), \"SPAN\");\n  },\n  /**\n   * Finds the next node, starting from the given node, and ignoring\n   * whitespace in between. If the given node is an element, the same node is\n   * returned.\n   */\n  _nextNode: function (node) {\n    var next = node;\n    while (next && next.nodeType != this.ELEMENT_NODE && this.REGEXPS.whitespace.test(next.textContent)) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n  /**\n   * Replaces 2 or more successive <br> elements with a single <p>.\n   * Whitespace between <br> elements are ignored. For example:\n   *   <div>foo<br>bar<br> <br><br>abc</div>\n   * will become:\n   *   <div>foo<br>bar<p>abc</p></div>\n   */\n  _replaceBrs: function (elem) {\n    this._forEachNode(this._getAllNodesWithTag(elem, [\"br\"]), function (br) {\n      var next = br.nextSibling;\n\n      // Whether 2 or more <br> elements have been found and replaced with a\n      // <p> block.\n      var replaced = false;\n\n      // If we find a <br> chain, remove the <br>s until we hit another node\n      // or non-whitespace. This leaves behind the first <br> in the chain\n      // (which will be replaced with a <p> later).\n      while ((next = this._nextNode(next)) && next.tagName == \"BR\") {\n        replaced = true;\n        var brSibling = next.nextSibling;\n        next.parentNode.removeChild(next);\n        next = brSibling;\n      }\n\n      // If we removed a <br> chain, replace the remaining <br> with a <p>. Add\n      // all sibling nodes as children of the <p> until we hit another <br>\n      // chain.\n      if (replaced) {\n        var p = this._doc.createElement(\"p\");\n        br.parentNode.replaceChild(p, br);\n        next = p.nextSibling;\n        while (next) {\n          // If we've hit another <br><br>, we're done adding children to this <p>.\n          if (next.tagName == \"BR\") {\n            var nextElem = this._nextNode(next.nextSibling);\n            if (nextElem && nextElem.tagName == \"BR\") break;\n          }\n          if (!this._isPhrasingContent(next)) break;\n\n          // Otherwise, make this node a child of the new <p>.\n          var sibling = next.nextSibling;\n          p.appendChild(next);\n          next = sibling;\n        }\n        while (p.lastChild && this._isWhitespace(p.lastChild)) {\n          p.removeChild(p.lastChild);\n        }\n        if (p.parentNode.tagName === \"P\") this._setNodeTag(p.parentNode, \"DIV\");\n      }\n    });\n  },\n  _setNodeTag: function (node, tag) {\n    this.log(\"_setNodeTag\", node, tag);\n    if (this._docJSDOMParser) {\n      node.localName = tag.toLowerCase();\n      node.tagName = tag.toUpperCase();\n      return node;\n    }\n    var replacement = node.ownerDocument.createElement(tag);\n    while (node.firstChild) {\n      replacement.appendChild(node.firstChild);\n    }\n    node.parentNode.replaceChild(replacement, node);\n    if (node.readability) replacement.readability = node.readability;\n    for (var i = 0; i < node.attributes.length; i++) {\n      try {\n        replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);\n      } catch (ex) {\n        /* it's possible for setAttribute() to throw if the attribute name\n         * isn't a valid XML Name. Such attributes can however be parsed from\n         * source in HTML docs, see https://github.com/whatwg/html/issues/4275,\n         * so we can hit them here and then throw. We don't care about such\n         * attributes so we ignore them.\n         */\n      }\n    }\n    return replacement;\n  },\n  /**\n   * Prepare the article node for display. Clean out any inline styles,\n   * iframes, forms, strip extraneous <p> tags, etc.\n   *\n   * @param Element\n   * @return void\n   **/\n  _prepArticle: function (articleContent) {\n    this._cleanStyles(articleContent);\n\n    // Check for data tables before we continue, to avoid removing items in\n    // those tables, which will often be isolated even though they're\n    // visually linked to other content-ful elements (text, images, etc.).\n    this._markDataTables(articleContent);\n    this._fixLazyImages(articleContent);\n\n    // Clean out junk from the article content\n    this._cleanConditionally(articleContent, \"form\");\n    this._cleanConditionally(articleContent, \"fieldset\");\n    this._clean(articleContent, \"object\");\n    this._clean(articleContent, \"embed\");\n    this._clean(articleContent, \"footer\");\n    this._clean(articleContent, \"link\");\n    this._clean(articleContent, \"aside\");\n\n    // Clean out elements with little content that have \"share\" in their id/class combinations from final top candidates,\n    // which means we don't remove the top candidates even they have \"share\".\n\n    var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;\n    this._forEachNode(articleContent.children, function (topCandidate) {\n      this._cleanMatchedNodes(topCandidate, function (node, matchString) {\n        return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;\n      });\n    });\n    this._clean(articleContent, \"iframe\");\n    this._clean(articleContent, \"input\");\n    this._clean(articleContent, \"textarea\");\n    this._clean(articleContent, \"select\");\n    this._clean(articleContent, \"button\");\n    this._cleanHeaders(articleContent);\n\n    // Do these last as the previous stuff may have removed junk\n    // that will affect these\n    this._cleanConditionally(articleContent, \"table\");\n    this._cleanConditionally(articleContent, \"ul\");\n    this._cleanConditionally(articleContent, \"div\");\n\n    // replace H1 with H2 as H1 should be only title that is displayed separately\n    this._replaceNodeTags(this._getAllNodesWithTag(articleContent, [\"h1\"]), \"h2\");\n\n    // Remove extra paragraphs\n    this._removeNodes(this._getAllNodesWithTag(articleContent, [\"p\"]), function (paragraph) {\n      var imgCount = paragraph.getElementsByTagName(\"img\").length;\n      var embedCount = paragraph.getElementsByTagName(\"embed\").length;\n      var objectCount = paragraph.getElementsByTagName(\"object\").length;\n      // At this point, nasty iframes have been removed, only remain embedded video ones.\n      var iframeCount = paragraph.getElementsByTagName(\"iframe\").length;\n      var totalCount = imgCount + embedCount + objectCount + iframeCount;\n      return totalCount === 0 && !this._getInnerText(paragraph, false);\n    });\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"br\"]), function (br) {\n      var next = this._nextNode(br.nextSibling);\n      if (next && next.tagName == \"P\") br.parentNode.removeChild(br);\n    });\n\n    // Remove single-cell tables\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"table\"]), function (table) {\n      var tbody = this._hasSingleTagInsideElement(table, \"TBODY\") ? table.firstElementChild : table;\n      if (this._hasSingleTagInsideElement(tbody, \"TR\")) {\n        var row = tbody.firstElementChild;\n        if (this._hasSingleTagInsideElement(row, \"TD\")) {\n          var cell = row.firstElementChild;\n          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? \"P\" : \"DIV\");\n          table.parentNode.replaceChild(cell, table);\n        }\n      }\n    });\n  },\n  /**\n   * Initialize a node with the readability object. Also checks the\n   * className/id for special names to add to its score.\n   *\n   * @param Element\n   * @return void\n  **/\n  _initializeNode: function (node) {\n    node.readability = {\n      \"contentScore\": 0\n    };\n    switch (node.tagName) {\n      case \"DIV\":\n        node.readability.contentScore += 5;\n        break;\n      case \"PRE\":\n      case \"TD\":\n      case \"BLOCKQUOTE\":\n        node.readability.contentScore += 3;\n        break;\n      case \"ADDRESS\":\n      case \"OL\":\n      case \"UL\":\n      case \"DL\":\n      case \"DD\":\n      case \"DT\":\n      case \"LI\":\n      case \"FORM\":\n        node.readability.contentScore -= 3;\n        break;\n      case \"H1\":\n      case \"H2\":\n      case \"H3\":\n      case \"H4\":\n      case \"H5\":\n      case \"H6\":\n      case \"TH\":\n        node.readability.contentScore -= 5;\n        break;\n    }\n    node.readability.contentScore += this._getClassWeight(node);\n  },\n  _removeAndGetNext: function (node) {\n    var nextNode = this._getNextNode(node, true);\n    node.parentNode.removeChild(node);\n    return nextNode;\n  },\n  /**\n   * Traverse the DOM from node to node, starting at the node passed in.\n   * Pass true for the second parameter to indicate this node itself\n   * (and its kids) are going away, and we want the next node over.\n   *\n   * Calling this in a loop will traverse the DOM depth-first.\n   */\n  _getNextNode: function (node, ignoreSelfAndKids) {\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.firstElementChild) {\n      return node.firstElementChild;\n    }\n    // Then for siblings...\n    if (node.nextElementSibling) {\n      return node.nextElementSibling;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n    } while (node && !node.nextElementSibling);\n    return node && node.nextElementSibling;\n  },\n  // compares second text to first one\n  // 1 = same text, 0 = completely different text\n  // works the way that it splits both texts into words and then finds words that are unique in second text\n  // the result is given by the lower length of unique parts\n  _textSimilarity: function (textA, textB) {\n    var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);\n    var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);\n    if (!tokensA.length || !tokensB.length) {\n      return 0;\n    }\n    var uniqTokensB = tokensB.filter(token => !tokensA.includes(token));\n    var distanceB = uniqTokensB.join(\" \").length / tokensB.join(\" \").length;\n    return 1 - distanceB;\n  },\n  _checkByline: function (node, matchString) {\n    if (this._articleByline) {\n      return false;\n    }\n    if (node.getAttribute !== undefined) {\n      var rel = node.getAttribute(\"rel\");\n      var itemprop = node.getAttribute(\"itemprop\");\n    }\n    if ((rel === \"author\" || itemprop && itemprop.indexOf(\"author\") !== -1 || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {\n      this._articleByline = node.textContent.trim();\n      return true;\n    }\n    return false;\n  },\n  _getNodeAncestors: function (node, maxDepth) {\n    maxDepth = maxDepth || 0;\n    var i = 0,\n      ancestors = [];\n    while (node.parentNode) {\n      ancestors.push(node.parentNode);\n      if (maxDepth && ++i === maxDepth) break;\n      node = node.parentNode;\n    }\n    return ancestors;\n  },\n  /***\n   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is\n   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.\n   *\n   * @param page a document to run upon. Needs to be a full document, complete with body.\n   * @return Element\n  **/\n  _grabArticle: function (page) {\n    this.log(\"**** grabArticle ****\");\n    var doc = this._doc;\n    var isPaging = page !== null;\n    page = page ? page : this._doc.body;\n\n    // We can't grab an article if we don't have a page!\n    if (!page) {\n      this.log(\"No body found in document. Abort.\");\n      return null;\n    }\n    var pageCacheHtml = page.innerHTML;\n    while (true) {\n      this.log(\"Starting grabArticle loop\");\n      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);\n\n      // First, node prepping. Trash nodes that look cruddy (like ones with the\n      // class name \"comment\", etc), and turn divs into P tags where they have been\n      // used inappropriately (as in, where they contain no other block level elements.)\n      var elementsToScore = [];\n      var node = this._doc.documentElement;\n      let shouldRemoveTitleHeader = true;\n      while (node) {\n        if (node.tagName === \"HTML\") {\n          this._articleLang = node.getAttribute(\"lang\");\n        }\n        var matchString = node.className + \" \" + node.id;\n        if (!this._isProbablyVisible(node)) {\n          this.log(\"Removing hidden node - \" + matchString);\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // User is not able to see elements applied with both \"aria-modal = true\" and \"role = dialog\"\n        if (node.getAttribute(\"aria-modal\") == \"true\" && node.getAttribute(\"role\") == \"dialog\") {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Check to see if this node is a byline, and remove it if it is.\n        if (this._checkByline(node, matchString)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n        if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {\n          this.log(\"Removing header: \", node.textContent.trim(), this._articleTitle.trim());\n          shouldRemoveTitleHeader = false;\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Remove unlikely candidates\n        if (stripUnlikelyCandidates) {\n          if (this.REGEXPS.unlikelyCandidates.test(matchString) && !this.REGEXPS.okMaybeItsACandidate.test(matchString) && !this._hasAncestorTag(node, \"table\") && !this._hasAncestorTag(node, \"code\") && node.tagName !== \"BODY\" && node.tagName !== \"A\") {\n            this.log(\"Removing unlikely candidate - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n          if (this.UNLIKELY_ROLES.includes(node.getAttribute(\"role\"))) {\n            this.log(\"Removing content with role \" + node.getAttribute(\"role\") + \" - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n        }\n\n        // Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).\n        if ((node.tagName === \"DIV\" || node.tagName === \"SECTION\" || node.tagName === \"HEADER\" || node.tagName === \"H1\" || node.tagName === \"H2\" || node.tagName === \"H3\" || node.tagName === \"H4\" || node.tagName === \"H5\" || node.tagName === \"H6\") && this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {\n          elementsToScore.push(node);\n        }\n\n        // Turn all divs that don't have children block level elements into p's\n        if (node.tagName === \"DIV\") {\n          // Put phrasing content into paragraphs.\n          var p = null;\n          var childNode = node.firstChild;\n          while (childNode) {\n            var nextSibling = childNode.nextSibling;\n            if (this._isPhrasingContent(childNode)) {\n              if (p !== null) {\n                p.appendChild(childNode);\n              } else if (!this._isWhitespace(childNode)) {\n                p = doc.createElement(\"p\");\n                node.replaceChild(p, childNode);\n                p.appendChild(childNode);\n              }\n            } else if (p !== null) {\n              while (p.lastChild && this._isWhitespace(p.lastChild)) {\n                p.removeChild(p.lastChild);\n              }\n              p = null;\n            }\n            childNode = nextSibling;\n          }\n\n          // Sites like http://mobile.slate.com encloses each paragraph with a DIV\n          // element. DIVs with only a P element inside and no text content can be\n          // safely converted into plain P elements to avoid confusing the scoring\n          // algorithm with DIVs with are, in practice, paragraphs.\n          if (this._hasSingleTagInsideElement(node, \"P\") && this._getLinkDensity(node) < 0.25) {\n            var newNode = node.children[0];\n            node.parentNode.replaceChild(newNode, node);\n            node = newNode;\n            elementsToScore.push(node);\n          } else if (!this._hasChildBlockElement(node)) {\n            node = this._setNodeTag(node, \"P\");\n            elementsToScore.push(node);\n          }\n        }\n        node = this._getNextNode(node);\n      }\n\n      /**\n       * Loop through all paragraphs, and assign a score to them based on how content-y they look.\n       * Then add their score to their parent node.\n       *\n       * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.\n      **/\n      var candidates = [];\n      this._forEachNode(elementsToScore, function (elementToScore) {\n        if (!elementToScore.parentNode || typeof elementToScore.parentNode.tagName === \"undefined\") return;\n\n        // If this paragraph is less than 25 characters, don't even count it.\n        var innerText = this._getInnerText(elementToScore);\n        if (innerText.length < 25) return;\n\n        // Exclude nodes with no ancestor.\n        var ancestors = this._getNodeAncestors(elementToScore, 5);\n        if (ancestors.length === 0) return;\n        var contentScore = 0;\n\n        // Add a point for the paragraph itself as a base.\n        contentScore += 1;\n\n        // Add points for any commas within this paragraph.\n        contentScore += innerText.split(this.REGEXPS.commas).length;\n\n        // For every 100 characters in this paragraph, add another point. Up to 3 points.\n        contentScore += Math.min(Math.floor(innerText.length / 100), 3);\n\n        // Initialize and score ancestors.\n        this._forEachNode(ancestors, function (ancestor, level) {\n          if (!ancestor.tagName || !ancestor.parentNode || typeof ancestor.parentNode.tagName === \"undefined\") return;\n          if (typeof ancestor.readability === \"undefined\") {\n            this._initializeNode(ancestor);\n            candidates.push(ancestor);\n          }\n\n          // Node score divider:\n          // - parent:             1 (no division)\n          // - grandparent:        2\n          // - great grandparent+: ancestor level * 3\n          if (level === 0) var scoreDivider = 1;else if (level === 1) scoreDivider = 2;else scoreDivider = level * 3;\n          ancestor.readability.contentScore += contentScore / scoreDivider;\n        });\n      });\n\n      // After we've calculated scores, loop through all of the possible\n      // candidate nodes we found and find the one with the highest score.\n      var topCandidates = [];\n      for (var c = 0, cl = candidates.length; c < cl; c += 1) {\n        var candidate = candidates[c];\n\n        // Scale the final candidates score based on link density. Good content\n        // should have a relatively small link density (5% or less) and be mostly\n        // unaffected by this operation.\n        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));\n        candidate.readability.contentScore = candidateScore;\n        this.log(\"Candidate:\", candidate, \"with score \" + candidateScore);\n        for (var t = 0; t < this._nbTopCandidates; t++) {\n          var aTopCandidate = topCandidates[t];\n          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {\n            topCandidates.splice(t, 0, candidate);\n            if (topCandidates.length > this._nbTopCandidates) topCandidates.pop();\n            break;\n          }\n        }\n      }\n      var topCandidate = topCandidates[0] || null;\n      var neededToCreateTopCandidate = false;\n      var parentOfTopCandidate;\n\n      // If we still have no top candidate, just use the body as a last resort.\n      // We also have to copy the body node so it is something we can modify.\n      if (topCandidate === null || topCandidate.tagName === \"BODY\") {\n        // Move all of the page's children into topCandidate\n        topCandidate = doc.createElement(\"DIV\");\n        neededToCreateTopCandidate = true;\n        // Move everything (not just elements, also text nodes etc.) into the container\n        // so we even include text directly in the body:\n        while (page.firstChild) {\n          this.log(\"Moving child out:\", page.firstChild);\n          topCandidate.appendChild(page.firstChild);\n        }\n        page.appendChild(topCandidate);\n        this._initializeNode(topCandidate);\n      } else if (topCandidate) {\n        // Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array\n        // and whose scores are quite closed with current `topCandidate` node.\n        var alternativeCandidateAncestors = [];\n        for (var i = 1; i < topCandidates.length; i++) {\n          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {\n            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));\n          }\n        }\n        var MINIMUM_TOPCANDIDATES = 3;\n        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {\n          parentOfTopCandidate = topCandidate.parentNode;\n          while (parentOfTopCandidate.tagName !== \"BODY\") {\n            var listsContainingThisAncestor = 0;\n            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {\n              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));\n            }\n            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {\n              topCandidate = parentOfTopCandidate;\n              break;\n            }\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n          }\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n\n        // Because of our bonus system, parents of candidates might have scores\n        // themselves. They get half of the node. There won't be nodes with higher\n        // scores than our topCandidate, but if we see the score going *up* in the first\n        // few steps up the tree, that's a decent sign that there might be more content\n        // lurking in other places that we want to unify in. The sibling stuff\n        // below does some of that - but only if we've looked high enough up the DOM\n        // tree.\n        parentOfTopCandidate = topCandidate.parentNode;\n        var lastScore = topCandidate.readability.contentScore;\n        // The scores shouldn't get too low.\n        var scoreThreshold = lastScore / 3;\n        while (parentOfTopCandidate.tagName !== \"BODY\") {\n          if (!parentOfTopCandidate.readability) {\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n            continue;\n          }\n          var parentScore = parentOfTopCandidate.readability.contentScore;\n          if (parentScore < scoreThreshold) break;\n          if (parentScore > lastScore) {\n            // Alright! We found a better parent to use.\n            topCandidate = parentOfTopCandidate;\n            break;\n          }\n          lastScore = parentOfTopCandidate.readability.contentScore;\n          parentOfTopCandidate = parentOfTopCandidate.parentNode;\n        }\n\n        // If the top candidate is the only child, use parent instead. This will help sibling\n        // joining logic when adjacent content is actually located in parent's sibling node.\n        parentOfTopCandidate = topCandidate.parentNode;\n        while (parentOfTopCandidate.tagName != \"BODY\" && parentOfTopCandidate.children.length == 1) {\n          topCandidate = parentOfTopCandidate;\n          parentOfTopCandidate = topCandidate.parentNode;\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n      }\n\n      // Now that we have the top candidate, look through its siblings for content\n      // that might also be related. Things like preambles, content split by ads\n      // that we removed, etc.\n      var articleContent = doc.createElement(\"DIV\");\n      if (isPaging) articleContent.id = \"readability-content\";\n      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);\n      // Keep potential top candidate's parent node to try to get text direction of it later.\n      parentOfTopCandidate = topCandidate.parentNode;\n      var siblings = parentOfTopCandidate.children;\n      for (var s = 0, sl = siblings.length; s < sl; s++) {\n        var sibling = siblings[s];\n        var append = false;\n        this.log(\"Looking at sibling node:\", sibling, sibling.readability ? \"with score \" + sibling.readability.contentScore : \"\");\n        this.log(\"Sibling has score\", sibling.readability ? sibling.readability.contentScore : \"Unknown\");\n        if (sibling === topCandidate) {\n          append = true;\n        } else {\n          var contentBonus = 0;\n\n          // Give a bonus if sibling nodes and top candidates have the example same classname\n          if (sibling.className === topCandidate.className && topCandidate.className !== \"\") contentBonus += topCandidate.readability.contentScore * 0.2;\n          if (sibling.readability && sibling.readability.contentScore + contentBonus >= siblingScoreThreshold) {\n            append = true;\n          } else if (sibling.nodeName === \"P\") {\n            var linkDensity = this._getLinkDensity(sibling);\n            var nodeContent = this._getInnerText(sibling);\n            var nodeLength = nodeContent.length;\n            if (nodeLength > 80 && linkDensity < 0.25) {\n              append = true;\n            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 && nodeContent.search(/\\.( |$)/) !== -1) {\n              append = true;\n            }\n          }\n        }\n        if (append) {\n          this.log(\"Appending node:\", sibling);\n          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {\n            // We have a node that isn't a common block level element, like a form or td tag.\n            // Turn it into a div so it doesn't get filtered out later by accident.\n            this.log(\"Altering sibling:\", sibling, \"to div.\");\n            sibling = this._setNodeTag(sibling, \"DIV\");\n          }\n          articleContent.appendChild(sibling);\n          // Fetch children again to make it compatible\n          // with DOM parsers without live collection support.\n          siblings = parentOfTopCandidate.children;\n          // siblings is a reference to the children array, and\n          // sibling is removed from the array when we call appendChild().\n          // As a result, we must revisit this index since the nodes\n          // have been shifted.\n          s -= 1;\n          sl -= 1;\n        }\n      }\n      if (this._debug) this.log(\"Article content pre-prep: \" + articleContent.innerHTML);\n      // So we have all of the content that we need. Now we clean it up for presentation.\n      this._prepArticle(articleContent);\n      if (this._debug) this.log(\"Article content post-prep: \" + articleContent.innerHTML);\n      if (neededToCreateTopCandidate) {\n        // We already created a fake div thing, and there wouldn't have been any siblings left\n        // for the previous loop, so there's no point trying to create a new div, and then\n        // move all the children over. Just assign IDs and class names here. No need to append\n        // because that already happened anyway.\n        topCandidate.id = \"readability-page-1\";\n        topCandidate.className = \"page\";\n      } else {\n        var div = doc.createElement(\"DIV\");\n        div.id = \"readability-page-1\";\n        div.className = \"page\";\n        while (articleContent.firstChild) {\n          div.appendChild(articleContent.firstChild);\n        }\n        articleContent.appendChild(div);\n      }\n      if (this._debug) this.log(\"Article content after paging: \" + articleContent.innerHTML);\n      var parseSuccessful = true;\n\n      // Now that we've gone through the full algorithm, check to see if\n      // we got any meaningful content. If we didn't, we may need to re-run\n      // grabArticle with different flags set. This gives us a higher likelihood of\n      // finding the content, and the sieve approach gives us a higher likelihood of\n      // finding the -right- content.\n      var textLength = this._getInnerText(articleContent, true).length;\n      if (textLength < this._charThreshold) {\n        parseSuccessful = false;\n        page.innerHTML = pageCacheHtml;\n        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {\n          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);\n          this._attempts.push({\n            articleContent: articleContent,\n            textLength: textLength\n          });\n        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {\n          this._removeFlag(this.FLAG_WEIGHT_CLASSES);\n          this._attempts.push({\n            articleContent: articleContent,\n            textLength: textLength\n          });\n        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {\n          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);\n          this._attempts.push({\n            articleContent: articleContent,\n            textLength: textLength\n          });\n        } else {\n          this._attempts.push({\n            articleContent: articleContent,\n            textLength: textLength\n          });\n          // No luck after removing flags, just return the longest text we found during the different loops\n          this._attempts.sort(function (a, b) {\n            return b.textLength - a.textLength;\n          });\n\n          // But first check if we actually have something\n          if (!this._attempts[0].textLength) {\n            return null;\n          }\n          articleContent = this._attempts[0].articleContent;\n          parseSuccessful = true;\n        }\n      }\n      if (parseSuccessful) {\n        // Find out text direction from ancestors of final top candidate.\n        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));\n        this._someNode(ancestors, function (ancestor) {\n          if (!ancestor.tagName) return false;\n          var articleDir = ancestor.getAttribute(\"dir\");\n          if (articleDir) {\n            this._articleDir = articleDir;\n            return true;\n          }\n          return false;\n        });\n        return articleContent;\n      }\n    }\n  },\n  /**\n   * Check whether the input string could be a byline.\n   * This verifies that the input is a string, and that the length\n   * is less than 100 chars.\n   *\n   * @param possibleByline {string} - a string to check whether its a byline.\n   * @return Boolean - whether the input string is a byline.\n   */\n  _isValidByline: function (byline) {\n    if (typeof byline == \"string\" || byline instanceof String) {\n      byline = byline.trim();\n      return byline.length > 0 && byline.length < 100;\n    }\n    return false;\n  },\n  /**\n   * Converts some of the common HTML entities in string to their corresponding characters.\n   *\n   * @param str {string} - a string to unescape.\n   * @return string without HTML entity.\n   */\n  _unescapeHtmlEntities: function (str) {\n    if (!str) {\n      return str;\n    }\n    var htmlEscapeMap = this.HTML_ESCAPE_MAP;\n    return str.replace(/&(quot|amp|apos|lt|gt);/g, function (_, tag) {\n      return htmlEscapeMap[tag];\n    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function (_, hex, numStr) {\n      var num = parseInt(hex || numStr, hex ? 16 : 10);\n      return String.fromCharCode(num);\n    });\n  },\n  /**\n   * Try to extract metadata from JSON-LD object.\n   * For now, only Schema.org objects of type Article or its subtypes are supported.\n   * @return Object with any metadata that could be extracted (possibly none)\n   */\n  _getJSONLD: function (doc) {\n    var scripts = this._getAllNodesWithTag(doc, [\"script\"]);\n    var metadata;\n    this._forEachNode(scripts, function (jsonLdElement) {\n      if (!metadata && jsonLdElement.getAttribute(\"type\") === \"application/ld+json\") {\n        try {\n          // Strip CDATA markers if present\n          var content = jsonLdElement.textContent.replace(/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g, \"\");\n          var parsed = JSON.parse(content);\n          if (!parsed[\"@context\"] || !parsed[\"@context\"].match(/^https?\\:\\/\\/schema\\.org$/)) {\n            return;\n          }\n          if (!parsed[\"@type\"] && Array.isArray(parsed[\"@graph\"])) {\n            parsed = parsed[\"@graph\"].find(function (it) {\n              return (it[\"@type\"] || \"\").match(this.REGEXPS.jsonLdArticleTypes);\n            });\n          }\n          if (!parsed || !parsed[\"@type\"] || !parsed[\"@type\"].match(this.REGEXPS.jsonLdArticleTypes)) {\n            return;\n          }\n          metadata = {};\n          if (typeof parsed.name === \"string\" && typeof parsed.headline === \"string\" && parsed.name !== parsed.headline) {\n            // we have both name and headline element in the JSON-LD. They should both be the same but some websites like aktualne.cz\n            // put their own name into \"name\" and the article title to \"headline\" which confuses Readability. So we try to check if either\n            // \"name\" or \"headline\" closely matches the html title, and if so, use that one. If not, then we use \"name\" by default.\n\n            var title = this._getArticleTitle();\n            var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;\n            var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;\n            if (headlineMatches && !nameMatches) {\n              metadata.title = parsed.headline;\n            } else {\n              metadata.title = parsed.name;\n            }\n          } else if (typeof parsed.name === \"string\") {\n            metadata.title = parsed.name.trim();\n          } else if (typeof parsed.headline === \"string\") {\n            metadata.title = parsed.headline.trim();\n          }\n          if (parsed.author) {\n            if (typeof parsed.author.name === \"string\") {\n              metadata.byline = parsed.author.name.trim();\n            } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === \"string\") {\n              metadata.byline = parsed.author.filter(function (author) {\n                return author && typeof author.name === \"string\";\n              }).map(function (author) {\n                return author.name.trim();\n              }).join(\", \");\n            }\n          }\n          if (typeof parsed.description === \"string\") {\n            metadata.excerpt = parsed.description.trim();\n          }\n          if (parsed.publisher && typeof parsed.publisher.name === \"string\") {\n            metadata.siteName = parsed.publisher.name.trim();\n          }\n          if (typeof parsed.datePublished === \"string\") {\n            metadata.datePublished = parsed.datePublished.trim();\n          }\n          return;\n        } catch (err) {\n          this.log(err.message);\n        }\n      }\n    });\n    return metadata ? metadata : {};\n  },\n  /**\n   * Attempts to get excerpt and byline metadata for the article.\n   *\n   * @param {Object} jsonld — object containing any metadata that\n   * could be extracted from JSON-LD object.\n   *\n   * @return Object with optional \"excerpt\" and \"byline\" properties\n   */\n  _getArticleMetadata: function (jsonld) {\n    var metadata = {};\n    var values = {};\n    var metaElements = this._doc.getElementsByTagName(\"meta\");\n\n    // property is a space-separated list of values\n    var propertyPattern = /\\s*(article|dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|published_time|title|site_name)\\s*/gi;\n\n    // name is a single value\n    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title|site_name)\\s*$/i;\n\n    // Find description tags.\n    this._forEachNode(metaElements, function (element) {\n      var elementName = element.getAttribute(\"name\");\n      var elementProperty = element.getAttribute(\"property\");\n      var content = element.getAttribute(\"content\");\n      if (!content) {\n        return;\n      }\n      var matches = null;\n      var name = null;\n      if (elementProperty) {\n        matches = elementProperty.match(propertyPattern);\n        if (matches) {\n          // Convert to lowercase, and remove any whitespace\n          // so we can match below.\n          name = matches[0].toLowerCase().replace(/\\s/g, \"\");\n          // multiple authors\n          values[name] = content.trim();\n        }\n      }\n      if (!matches && elementName && namePattern.test(elementName)) {\n        name = elementName;\n        if (content) {\n          // Convert to lowercase, remove any whitespace, and convert dots\n          // to colons so we can match below.\n          name = name.toLowerCase().replace(/\\s/g, \"\").replace(/\\./g, \":\");\n          values[name] = content.trim();\n        }\n      }\n    });\n\n    // get title\n    metadata.title = jsonld.title || values[\"dc:title\"] || values[\"dcterm:title\"] || values[\"og:title\"] || values[\"weibo:article:title\"] || values[\"weibo:webpage:title\"] || values[\"title\"] || values[\"twitter:title\"];\n    if (!metadata.title) {\n      metadata.title = this._getArticleTitle();\n    }\n\n    // get author\n    metadata.byline = jsonld.byline || values[\"dc:creator\"] || values[\"dcterm:creator\"] || values[\"author\"];\n\n    // get description\n    metadata.excerpt = jsonld.excerpt || values[\"dc:description\"] || values[\"dcterm:description\"] || values[\"og:description\"] || values[\"weibo:article:description\"] || values[\"weibo:webpage:description\"] || values[\"description\"] || values[\"twitter:description\"];\n\n    // get site name\n    metadata.siteName = jsonld.siteName || values[\"og:site_name\"];\n\n    // get article published time\n    metadata.publishedTime = jsonld.datePublished || values[\"article:published_time\"] || null;\n\n    // in many sites the meta value is escaped with HTML entities,\n    // so here we need to unescape it\n    metadata.title = this._unescapeHtmlEntities(metadata.title);\n    metadata.byline = this._unescapeHtmlEntities(metadata.byline);\n    metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);\n    metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);\n    metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);\n    return metadata;\n  },\n  /**\n   * Check if node is image, or if node contains exactly only one image\n   * whether as a direct child or as its descendants.\n   *\n   * @param Element\n  **/\n  _isSingleImage: function (node) {\n    if (node.tagName === \"IMG\") {\n      return true;\n    }\n    if (node.children.length !== 1 || node.textContent.trim() !== \"\") {\n      return false;\n    }\n    return this._isSingleImage(node.children[0]);\n  },\n  /**\n   * Find all <noscript> that are located after <img> nodes, and which contain only one\n   * <img> element. Replace the first image with the image from inside the <noscript> tag,\n   * and remove the <noscript> tag. This improves the quality of the images we use on\n   * some sites (e.g. Medium).\n   *\n   * @param Element\n  **/\n  _unwrapNoscriptImages: function (doc) {\n    // Find img without source or attributes that might contains image, and remove it.\n    // This is done to prevent a placeholder img is replaced by img from noscript in next step.\n    var imgs = Array.from(doc.getElementsByTagName(\"img\"));\n    this._forEachNode(imgs, function (img) {\n      for (var i = 0; i < img.attributes.length; i++) {\n        var attr = img.attributes[i];\n        switch (attr.name) {\n          case \"src\":\n          case \"srcset\":\n          case \"data-src\":\n          case \"data-srcset\":\n            return;\n        }\n        if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n          return;\n        }\n      }\n      img.parentNode.removeChild(img);\n    });\n\n    // Next find noscript and try to extract its image\n    var noscripts = Array.from(doc.getElementsByTagName(\"noscript\"));\n    this._forEachNode(noscripts, function (noscript) {\n      // Parse content of noscript and make sure it only contains image\n      var tmp = doc.createElement(\"div\");\n      tmp.innerHTML = noscript.innerHTML;\n      if (!this._isSingleImage(tmp)) {\n        return;\n      }\n\n      // If noscript has previous sibling and it only contains image,\n      // replace it with noscript content. However we also keep old\n      // attributes that might contains image.\n      var prevElement = noscript.previousElementSibling;\n      if (prevElement && this._isSingleImage(prevElement)) {\n        var prevImg = prevElement;\n        if (prevImg.tagName !== \"IMG\") {\n          prevImg = prevElement.getElementsByTagName(\"img\")[0];\n        }\n        var newImg = tmp.getElementsByTagName(\"img\")[0];\n        for (var i = 0; i < prevImg.attributes.length; i++) {\n          var attr = prevImg.attributes[i];\n          if (attr.value === \"\") {\n            continue;\n          }\n          if (attr.name === \"src\" || attr.name === \"srcset\" || /\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            if (newImg.getAttribute(attr.name) === attr.value) {\n              continue;\n            }\n            var attrName = attr.name;\n            if (newImg.hasAttribute(attrName)) {\n              attrName = \"data-old-\" + attrName;\n            }\n            newImg.setAttribute(attrName, attr.value);\n          }\n        }\n        noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);\n      }\n    });\n  },\n  /**\n   * Removes script tags from the document.\n   *\n   * @param Element\n  **/\n  _removeScripts: function (doc) {\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"script\", \"noscript\"]));\n  },\n  /**\n   * Check if this node has only whitespace and a single element with given tag\n   * Returns false if the DIV node contains non-empty text nodes\n   * or if it contains no element with given tag or more than 1 element.\n   *\n   * @param Element\n   * @param string tag of child element\n  **/\n  _hasSingleTagInsideElement: function (element, tag) {\n    // There should be exactly 1 element child with given tag\n    if (element.children.length != 1 || element.children[0].tagName !== tag) {\n      return false;\n    }\n\n    // And there should be no text nodes with real content\n    return !this._someNode(element.childNodes, function (node) {\n      return node.nodeType === this.TEXT_NODE && this.REGEXPS.hasContent.test(node.textContent);\n    });\n  },\n  _isElementWithoutContent: function (node) {\n    return node.nodeType === this.ELEMENT_NODE && node.textContent.trim().length == 0 && (node.children.length == 0 || node.children.length == node.getElementsByTagName(\"br\").length + node.getElementsByTagName(\"hr\").length);\n  },\n  /**\n   * Determine whether element has any children block level elements.\n   *\n   * @param Element\n   */\n  _hasChildBlockElement: function (element) {\n    return this._someNode(element.childNodes, function (node) {\n      return this.DIV_TO_P_ELEMS.has(node.tagName) || this._hasChildBlockElement(node);\n    });\n  },\n  /***\n   * Determine if a node qualifies as phrasing content.\n   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n  **/\n  _isPhrasingContent: function (node) {\n    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 || (node.tagName === \"A\" || node.tagName === \"DEL\" || node.tagName === \"INS\") && this._everyNode(node.childNodes, this._isPhrasingContent);\n  },\n  _isWhitespace: function (node) {\n    return node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0 || node.nodeType === this.ELEMENT_NODE && node.tagName === \"BR\";\n  },\n  /**\n   * Get the inner text of a node - cross browser compatibly.\n   * This also strips out any excess whitespace to be found.\n   *\n   * @param Element\n   * @param Boolean normalizeSpaces (default: true)\n   * @return string\n  **/\n  _getInnerText: function (e, normalizeSpaces) {\n    normalizeSpaces = typeof normalizeSpaces === \"undefined\" ? true : normalizeSpaces;\n    var textContent = e.textContent.trim();\n    if (normalizeSpaces) {\n      return textContent.replace(this.REGEXPS.normalize, \" \");\n    }\n    return textContent;\n  },\n  /**\n   * Get the number of times a string s appears in the node e.\n   *\n   * @param Element\n   * @param string - what to split on. Default is \",\"\n   * @return number (integer)\n  **/\n  _getCharCount: function (e, s) {\n    s = s || \",\";\n    return this._getInnerText(e).split(s).length - 1;\n  },\n  /**\n   * Remove the style attribute on every e and under.\n   * TODO: Test if getElementsByTagName(*) is faster.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanStyles: function (e) {\n    if (!e || e.tagName.toLowerCase() === \"svg\") return;\n\n    // Remove `style` and deprecated presentational attributes\n    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {\n      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);\n    }\n    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {\n      e.removeAttribute(\"width\");\n      e.removeAttribute(\"height\");\n    }\n    var cur = e.firstElementChild;\n    while (cur !== null) {\n      this._cleanStyles(cur);\n      cur = cur.nextElementSibling;\n    }\n  },\n  /**\n   * Get the density of links as a percentage of the content\n   * This is the amount of text that is inside a link divided by the total text in the node.\n   *\n   * @param Element\n   * @return number (float)\n  **/\n  _getLinkDensity: function (element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0) return 0;\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function (linkNode) {\n      var href = linkNode.getAttribute(\"href\");\n      var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;\n      linkLength += this._getInnerText(linkNode).length * coefficient;\n    });\n    return linkLength / textLength;\n  },\n  /**\n   * Get an elements class/id weight. Uses regular expressions to tell if this\n   * element looks good or bad.\n   *\n   * @param Element\n   * @return number (Integer)\n  **/\n  _getClassWeight: function (e) {\n    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) return 0;\n    var weight = 0;\n\n    // Look for a special classname\n    if (typeof e.className === \"string\" && e.className !== \"\") {\n      if (this.REGEXPS.negative.test(e.className)) weight -= 25;\n      if (this.REGEXPS.positive.test(e.className)) weight += 25;\n    }\n\n    // Look for a special ID\n    if (typeof e.id === \"string\" && e.id !== \"\") {\n      if (this.REGEXPS.negative.test(e.id)) weight -= 25;\n      if (this.REGEXPS.positive.test(e.id)) weight += 25;\n    }\n    return weight;\n  },\n  /**\n   * Clean a node of all elements of type \"tag\".\n   * (Unless it's a youtube/vimeo video. People love movies.)\n   *\n   * @param Element\n   * @param string tag to clean\n   * @return void\n   **/\n  _clean: function (e, tag) {\n    var isEmbed = [\"object\", \"embed\", \"iframe\"].indexOf(tag) !== -1;\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function (element) {\n      // Allow youtube and vimeo videos through as people usually want to see those.\n      if (isEmbed) {\n        // First, check the elements attributes to see if any of them contain youtube or vimeo\n        for (var i = 0; i < element.attributes.length; i++) {\n          if (this._allowedVideoRegex.test(element.attributes[i].value)) {\n            return false;\n          }\n        }\n\n        // For embed with <object> tag, check inner HTML as well.\n        if (element.tagName === \"object\" && this._allowedVideoRegex.test(element.innerHTML)) {\n          return false;\n        }\n      }\n      return true;\n    });\n  },\n  /**\n   * Check if a given node has one of its ancestor tag name matching the\n   * provided one.\n   * @param  HTMLElement node\n   * @param  String      tagName\n   * @param  Number      maxDepth\n   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'\n   * @return Boolean\n   */\n  _hasAncestorTag: function (node, tagName, maxDepth, filterFn) {\n    maxDepth = maxDepth || 3;\n    tagName = tagName.toUpperCase();\n    var depth = 0;\n    while (node.parentNode) {\n      if (maxDepth > 0 && depth > maxDepth) return false;\n      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode))) return true;\n      node = node.parentNode;\n      depth++;\n    }\n    return false;\n  },\n  /**\n   * Return an object indicating how many rows and columns this table has.\n   */\n  _getRowAndColumnCount: function (table) {\n    var rows = 0;\n    var columns = 0;\n    var trs = table.getElementsByTagName(\"tr\");\n    for (var i = 0; i < trs.length; i++) {\n      var rowspan = trs[i].getAttribute(\"rowspan\") || 0;\n      if (rowspan) {\n        rowspan = parseInt(rowspan, 10);\n      }\n      rows += rowspan || 1;\n\n      // Now look for column-related info\n      var columnsInThisRow = 0;\n      var cells = trs[i].getElementsByTagName(\"td\");\n      for (var j = 0; j < cells.length; j++) {\n        var colspan = cells[j].getAttribute(\"colspan\") || 0;\n        if (colspan) {\n          colspan = parseInt(colspan, 10);\n        }\n        columnsInThisRow += colspan || 1;\n      }\n      columns = Math.max(columns, columnsInThisRow);\n    }\n    return {\n      rows: rows,\n      columns: columns\n    };\n  },\n  /**\n   * Look for 'data' (as opposed to 'layout') tables, for which we use\n   * similar checks as\n   * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19\n   */\n  _markDataTables: function (root) {\n    var tables = root.getElementsByTagName(\"table\");\n    for (var i = 0; i < tables.length; i++) {\n      var table = tables[i];\n      var role = table.getAttribute(\"role\");\n      if (role == \"presentation\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var datatable = table.getAttribute(\"datatable\");\n      if (datatable == \"0\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var summary = table.getAttribute(\"summary\");\n      if (summary) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n      var caption = table.getElementsByTagName(\"caption\")[0];\n      if (caption && caption.childNodes.length > 0) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // If the table has a descendant with any of these tags, consider a data table:\n      var dataTableDescendants = [\"col\", \"colgroup\", \"tfoot\", \"thead\", \"th\"];\n      var descendantExists = function (tag) {\n        return !!table.getElementsByTagName(tag)[0];\n      };\n      if (dataTableDescendants.some(descendantExists)) {\n        this.log(\"Data table because found data-y descendant\");\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // Nested tables indicate a layout table:\n      if (table.getElementsByTagName(\"table\")[0]) {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var sizeInfo = this._getRowAndColumnCount(table);\n      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n      // Now just go by size entirely:\n      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;\n    }\n  },\n  /* convert images and figures that have properties like data-src into images that can be loaded without JS */\n  _fixLazyImages: function (root) {\n    this._forEachNode(this._getAllNodesWithTag(root, [\"img\", \"picture\", \"figure\"]), function (elem) {\n      // In some sites (e.g. Kotaku), they put 1px square image as base64 data uri in the src attribute.\n      // So, here we check if the data uri is too short, just might as well remove it.\n      if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {\n        // Make sure it's not SVG, because SVG can have a meaningful image in under 133 bytes.\n        var parts = this.REGEXPS.b64DataUrl.exec(elem.src);\n        if (parts[1] === \"image/svg+xml\") {\n          return;\n        }\n\n        // Make sure this element has other attributes which contains image.\n        // If it doesn't, then this src is important and shouldn't be removed.\n        var srcCouldBeRemoved = false;\n        for (var i = 0; i < elem.attributes.length; i++) {\n          var attr = elem.attributes[i];\n          if (attr.name === \"src\") {\n            continue;\n          }\n          if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            srcCouldBeRemoved = true;\n            break;\n          }\n        }\n\n        // Here we assume if image is less than 100 bytes (or 133B after encoded to base64)\n        // it will be too small, therefore it might be placeholder image.\n        if (srcCouldBeRemoved) {\n          var b64starts = elem.src.search(/base64\\s*/i) + 7;\n          var b64length = elem.src.length - b64starts;\n          if (b64length < 133) {\n            elem.removeAttribute(\"src\");\n          }\n        }\n      }\n\n      // also check for \"null\" to work around https://github.com/jsdom/jsdom/issues/2580\n      if ((elem.src || elem.srcset && elem.srcset != \"null\") && elem.className.toLowerCase().indexOf(\"lazy\") === -1) {\n        return;\n      }\n      for (var j = 0; j < elem.attributes.length; j++) {\n        attr = elem.attributes[j];\n        if (attr.name === \"src\" || attr.name === \"srcset\" || attr.name === \"alt\") {\n          continue;\n        }\n        var copyTo = null;\n        if (/\\.(jpg|jpeg|png|webp)\\s+\\d/.test(attr.value)) {\n          copyTo = \"srcset\";\n        } else if (/^\\s*\\S+\\.(jpg|jpeg|png|webp)\\S*\\s*$/.test(attr.value)) {\n          copyTo = \"src\";\n        }\n        if (copyTo) {\n          //if this is an img or picture, set the attribute directly\n          if (elem.tagName === \"IMG\" || elem.tagName === \"PICTURE\") {\n            elem.setAttribute(copyTo, attr.value);\n          } else if (elem.tagName === \"FIGURE\" && !this._getAllNodesWithTag(elem, [\"img\", \"picture\"]).length) {\n            //if the item is a <figure> that does not contain an image or picture, create one and place it inside the figure\n            //see the nytimes-3 testcase for an example\n            var img = this._doc.createElement(\"img\");\n            img.setAttribute(copyTo, attr.value);\n            elem.appendChild(img);\n          }\n        }\n      }\n    });\n  },\n  _getTextDensity: function (e, tags) {\n    var textLength = this._getInnerText(e, true).length;\n    if (textLength === 0) {\n      return 0;\n    }\n    var childrenLength = 0;\n    var children = this._getAllNodesWithTag(e, tags);\n    this._forEachNode(children, child => childrenLength += this._getInnerText(child, true).length);\n    return childrenLength / textLength;\n  },\n  /**\n   * Clean an element of all tags of type \"tag\" if they look fishy.\n   * \"Fishy\" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.\n   *\n   * @return void\n   **/\n  _cleanConditionally: function (e, tag) {\n    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) return;\n\n    // Gather counts for other typical elements embedded within.\n    // Traverse backwards so we can remove nodes at the same time\n    // without effecting the traversal.\n    //\n    // TODO: Consider taking into account original contentScore here.\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function (node) {\n      // First check if this node IS data table, in which case don't remove it.\n      var isDataTable = function (t) {\n        return t._readabilityDataTable;\n      };\n      var isList = tag === \"ul\" || tag === \"ol\";\n      if (!isList) {\n        var listLength = 0;\n        var listNodes = this._getAllNodesWithTag(node, [\"ul\", \"ol\"]);\n        this._forEachNode(listNodes, list => listLength += this._getInnerText(list).length);\n        isList = listLength / this._getInnerText(node).length > 0.9;\n      }\n      if (tag === \"table\" && isDataTable(node)) {\n        return false;\n      }\n\n      // Next check if we're inside a data table, in which case don't remove it as well.\n      if (this._hasAncestorTag(node, \"table\", -1, isDataTable)) {\n        return false;\n      }\n      if (this._hasAncestorTag(node, \"code\")) {\n        return false;\n      }\n      var weight = this._getClassWeight(node);\n      this.log(\"Cleaning Conditionally\", node);\n      var contentScore = 0;\n      if (weight + contentScore < 0) {\n        return true;\n      }\n      if (this._getCharCount(node, \",\") < 10) {\n        // If there are not very many commas, and the number of\n        // non-paragraph elements is more than paragraphs or other\n        // ominous signs, remove the element.\n        var p = node.getElementsByTagName(\"p\").length;\n        var img = node.getElementsByTagName(\"img\").length;\n        var li = node.getElementsByTagName(\"li\").length - 100;\n        var input = node.getElementsByTagName(\"input\").length;\n        var headingDensity = this._getTextDensity(node, [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]);\n        var embedCount = 0;\n        var embeds = this._getAllNodesWithTag(node, [\"object\", \"embed\", \"iframe\"]);\n        for (var i = 0; i < embeds.length; i++) {\n          // If this embed has attribute that matches video regex, don't delete it.\n          for (var j = 0; j < embeds[i].attributes.length; j++) {\n            if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {\n              return false;\n            }\n          }\n\n          // For embed with <object> tag, check inner HTML as well.\n          if (embeds[i].tagName === \"object\" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {\n            return false;\n          }\n          embedCount++;\n        }\n        var linkDensity = this._getLinkDensity(node);\n        var contentLength = this._getInnerText(node).length;\n        var haveToRemove = img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, \"figure\") || !isList && li > p || input > Math.floor(p / 3) || !isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, \"figure\") || !isList && weight < 25 && linkDensity > 0.2 || weight >= 25 && linkDensity > 0.5 || embedCount === 1 && contentLength < 75 || embedCount > 1;\n        // Allow simple lists of images to remain in pages\n        if (isList && haveToRemove) {\n          for (var x = 0; x < node.children.length; x++) {\n            let child = node.children[x];\n            // Don't filter in lists with li's that contain more than one child\n            if (child.children.length > 1) {\n              return haveToRemove;\n            }\n          }\n          let li_count = node.getElementsByTagName(\"li\").length;\n          // Only allow the list to remain if every li contains an image\n          if (img == li_count) {\n            return false;\n          }\n        }\n        return haveToRemove;\n      }\n      return false;\n    });\n  },\n  /**\n   * Clean out elements that match the specified conditions\n   *\n   * @param Element\n   * @param Function determines whether a node should be removed\n   * @return void\n   **/\n  _cleanMatchedNodes: function (e, filter) {\n    var endOfSearchMarkerNode = this._getNextNode(e, true);\n    var next = this._getNextNode(e);\n    while (next && next != endOfSearchMarkerNode) {\n      if (filter.call(this, next, next.className + \" \" + next.id)) {\n        next = this._removeAndGetNext(next);\n      } else {\n        next = this._getNextNode(next);\n      }\n    }\n  },\n  /**\n   * Clean out spurious headers from an Element.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanHeaders: function (e) {\n    let headingNodes = this._getAllNodesWithTag(e, [\"h1\", \"h2\"]);\n    this._removeNodes(headingNodes, function (node) {\n      let shouldRemove = this._getClassWeight(node) < 0;\n      if (shouldRemove) {\n        this.log(\"Removing header with low class weight:\", node);\n      }\n      return shouldRemove;\n    });\n  },\n  /**\n   * Check if this node is an H1 or H2 element whose content is mostly\n   * the same as the article title.\n   *\n   * @param Element  the node to check.\n   * @return boolean indicating whether this is a title-like header.\n   */\n  _headerDuplicatesTitle: function (node) {\n    if (node.tagName != \"H1\" && node.tagName != \"H2\") {\n      return false;\n    }\n    var heading = this._getInnerText(node, false);\n    this.log(\"Evaluating similarity of header:\", heading, this._articleTitle);\n    return this._textSimilarity(this._articleTitle, heading) > 0.75;\n  },\n  _flagIsActive: function (flag) {\n    return (this._flags & flag) > 0;\n  },\n  _removeFlag: function (flag) {\n    this._flags = this._flags & ~flag;\n  },\n  _isProbablyVisible: function (node) {\n    // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.\n    return (!node.style || node.style.display != \"none\") && (!node.style || node.style.visibility != \"hidden\") && !node.hasAttribute(\"hidden\")\n    //check for \"fallback-image\" so that wikimedia math images are displayed\n    && (!node.hasAttribute(\"aria-hidden\") || node.getAttribute(\"aria-hidden\") != \"true\" || node.className && node.className.indexOf && node.className.indexOf(\"fallback-image\") !== -1);\n  },\n  /**\n   * Runs readability.\n   *\n   * Workflow:\n   *  1. Prep the document by removing script tags, css, etc.\n   *  2. Build readability's DOM tree.\n   *  3. Grab the article content from the current dom tree.\n   *  4. Replace the current DOM tree with the new one.\n   *  5. Read peacefully.\n   *\n   * @return void\n   **/\n  parse: function () {\n    // Avoid parsing too large documents, as per configuration option\n    if (this._maxElemsToParse > 0) {\n      var numTags = this._doc.getElementsByTagName(\"*\").length;\n      if (numTags > this._maxElemsToParse) {\n        throw new Error(\"Aborting parsing document; \" + numTags + \" elements found\");\n      }\n    }\n\n    // Unwrap image from noscript\n    this._unwrapNoscriptImages(this._doc);\n\n    // Extract JSON-LD metadata before removing scripts\n    var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);\n\n    // Remove script tags from the document.\n    this._removeScripts(this._doc);\n    this._prepDocument();\n    var metadata = this._getArticleMetadata(jsonLd);\n    this._articleTitle = metadata.title;\n    var articleContent = this._grabArticle();\n    if (!articleContent) return null;\n    this.log(\"Grabbed: \" + articleContent.innerHTML);\n    this._postProcessContent(articleContent);\n\n    // If we haven't found an excerpt in the article's metadata, use the article's\n    // first paragraph as the excerpt. This is used for displaying a preview of\n    // the article's content.\n    if (!metadata.excerpt) {\n      var paragraphs = articleContent.getElementsByTagName(\"p\");\n      if (paragraphs.length > 0) {\n        metadata.excerpt = paragraphs[0].textContent.trim();\n      }\n    }\n    var textContent = articleContent.textContent;\n    return {\n      title: this._articleTitle,\n      byline: metadata.byline || this._articleByline,\n      dir: this._articleDir,\n      lang: this._articleLang,\n      content: this._serializer(articleContent),\n      textContent: textContent,\n      length: textContent.length,\n      excerpt: metadata.excerpt,\n      siteName: metadata.siteName || this._articleSiteName,\n      publishedTime: metadata.publishedTime\n    };\n  }\n};\nif (typeof module === \"object\") {\n  /* global module */\n  module.exports = Readability;\n}","map":{"version":3,"names":["Readability","doc","options","documentElement","arguments","Error","_doc","_docJSDOMParser","firstChild","__JSDOMParser__","_articleTitle","_articleByline","_articleDir","_articleSiteName","_attempts","_debug","debug","_maxElemsToParse","maxElemsToParse","DEFAULT_MAX_ELEMS_TO_PARSE","_nbTopCandidates","nbTopCandidates","DEFAULT_N_TOP_CANDIDATES","_charThreshold","charThreshold","DEFAULT_CHAR_THRESHOLD","_classesToPreserve","CLASSES_TO_PRESERVE","concat","classesToPreserve","_keepClasses","keepClasses","_serializer","serializer","el","innerHTML","_disableJSONLD","disableJSONLD","_allowedVideoRegex","allowedVideoRegex","REGEXPS","videos","_flags","FLAG_STRIP_UNLIKELYS","FLAG_WEIGHT_CLASSES","FLAG_CLEAN_CONDITIONALLY","logNode","node","nodeType","TEXT_NODE","nodeName","textContent","attrPairs","Array","from","attributes","attr","name","value","join","localName","log","console","args","arg","ELEMENT_NODE","unshift","apply","dump","msg","prototype","map","call","x","DEFAULT_TAGS_TO_SCORE","toUpperCase","split","unlikelyCandidates","okMaybeItsACandidate","positive","negative","extraneous","byline","replaceFonts","normalize","shareElements","nextLink","prevLink","tokenize","whitespace","hasContent","hashUrl","srcsetUrl","b64DataUrl","commas","jsonLdArticleTypes","UNLIKELY_ROLES","DIV_TO_P_ELEMS","Set","ALTER_TO_DIV_EXCEPTIONS","PRESENTATIONAL_ATTRIBUTES","DEPRECATED_SIZE_ATTRIBUTE_ELEMS","PHRASING_ELEMS","HTML_ESCAPE_MAP","_postProcessContent","articleContent","_fixRelativeUris","_simplifyNestedElements","_cleanClasses","_removeNodes","nodeList","filterFn","_isLiveNodeList","i","length","parentNode","removeChild","_replaceNodeTags","newTagName","_setNodeTag","_forEachNode","fn","forEach","_findNode","find","_someNode","some","_everyNode","every","_concatNodeLists","slice","nodeLists","list","_getAllNodesWithTag","tagNames","querySelectorAll","tag","collection","getElementsByTagName","isArray","className","getAttribute","filter","cls","indexOf","setAttribute","removeAttribute","firstElementChild","nextElementSibling","baseURI","documentURI","toAbsoluteURI","uri","charAt","URL","href","ex","links","link","childNodes","text","createTextNode","replaceChild","container","createElement","appendChild","medias","media","src","poster","srcset","newSrcset","replace","_","p1","p2","p3","includes","tagName","id","startsWith","_isElementWithoutContent","_removeAndGetNext","_hasSingleTagInsideElement","child","children","_getNextNode","_getArticleTitle","curTitle","origTitle","title","trim","_getInnerText","e","titleHadHierarchicalSeparators","wordCount","str","test","headings","trimmedTitle","match","heading","substring","lastIndexOf","substr","hOnes","curTitleWordCount","_prepDocument","body","_replaceBrs","_nextNode","next","nextSibling","elem","br","replaced","brSibling","p","nextElem","_isPhrasingContent","sibling","lastChild","_isWhitespace","toLowerCase","replacement","ownerDocument","readability","_prepArticle","_cleanStyles","_markDataTables","_fixLazyImages","_cleanConditionally","_clean","shareElementThreshold","topCandidate","_cleanMatchedNodes","matchString","_cleanHeaders","paragraph","imgCount","embedCount","objectCount","iframeCount","totalCount","table","tbody","row","cell","_initializeNode","contentScore","_getClassWeight","nextNode","ignoreSelfAndKids","_textSimilarity","textA","textB","tokensA","Boolean","tokensB","uniqTokensB","token","distanceB","_checkByline","undefined","rel","itemprop","_isValidByline","_getNodeAncestors","maxDepth","ancestors","push","_grabArticle","page","isPaging","pageCacheHtml","stripUnlikelyCandidates","_flagIsActive","elementsToScore","shouldRemoveTitleHeader","_articleLang","_isProbablyVisible","_headerDuplicatesTitle","_hasAncestorTag","childNode","_getLinkDensity","newNode","_hasChildBlockElement","candidates","elementToScore","innerText","Math","min","floor","ancestor","level","scoreDivider","topCandidates","c","cl","candidate","candidateScore","t","aTopCandidate","splice","pop","neededToCreateTopCandidate","parentOfTopCandidate","alternativeCandidateAncestors","MINIMUM_TOPCANDIDATES","listsContainingThisAncestor","ancestorIndex","Number","lastScore","scoreThreshold","parentScore","siblingScoreThreshold","max","siblings","s","sl","append","contentBonus","linkDensity","nodeContent","nodeLength","search","div","parseSuccessful","textLength","_removeFlag","sort","a","b","articleDir","String","_unescapeHtmlEntities","htmlEscapeMap","hex","numStr","num","parseInt","fromCharCode","_getJSONLD","scripts","metadata","jsonLdElement","content","parsed","JSON","parse","it","headline","nameMatches","headlineMatches","author","description","excerpt","publisher","siteName","datePublished","err","message","_getArticleMetadata","jsonld","values","metaElements","propertyPattern","namePattern","element","elementName","elementProperty","matches","publishedTime","_isSingleImage","_unwrapNoscriptImages","imgs","img","noscripts","noscript","tmp","prevElement","previousElementSibling","prevImg","newImg","attrName","hasAttribute","_removeScripts","has","normalizeSpaces","_getCharCount","cur","linkLength","linkNode","coefficient","weight","isEmbed","depth","_getRowAndColumnCount","rows","columns","trs","rowspan","columnsInThisRow","cells","j","colspan","root","tables","role","_readabilityDataTable","datatable","summary","caption","dataTableDescendants","descendantExists","sizeInfo","parts","exec","srcCouldBeRemoved","b64starts","b64length","copyTo","_getTextDensity","tags","childrenLength","isDataTable","isList","listLength","listNodes","li","input","headingDensity","embeds","contentLength","haveToRemove","li_count","endOfSearchMarkerNode","headingNodes","shouldRemove","flag","style","display","visibility","numTags","jsonLd","paragraphs","dir","lang","module","exports"],"sources":["/Users/mandylin/Desktop/WebCrack React 2/webcrack/node_modules/@mozilla/readability/Readability.js"],"sourcesContent":["/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\n/**\n * Public constructor.\n * @param {HTMLDocument} doc     The document to parse.\n * @param {Object}       options The options object.\n */\nfunction Readability(doc, options) {\n  // In some older versions, people passed a URI as the first argument. Cope:\n  if (options && options.documentElement) {\n    doc = options;\n    options = arguments[2];\n  } else if (!doc || !doc.documentElement) {\n    throw new Error(\"First argument to Readability constructor should be a document object.\");\n  }\n  options = options || {};\n\n  this._doc = doc;\n  this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;\n  this._articleTitle = null;\n  this._articleByline = null;\n  this._articleDir = null;\n  this._articleSiteName = null;\n  this._attempts = [];\n\n  // Configurable options\n  this._debug = !!options.debug;\n  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;\n  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;\n  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;\n  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);\n  this._keepClasses = !!options.keepClasses;\n  this._serializer = options.serializer || function(el) {\n    return el.innerHTML;\n  };\n  this._disableJSONLD = !!options.disableJSONLD;\n  this._allowedVideoRegex = options.allowedVideoRegex || this.REGEXPS.videos;\n\n  // Start with all flags set\n  this._flags = this.FLAG_STRIP_UNLIKELYS |\n                this.FLAG_WEIGHT_CLASSES |\n                this.FLAG_CLEAN_CONDITIONALLY;\n\n\n  // Control whether log messages are sent to the console\n  if (this._debug) {\n    let logNode = function(node) {\n      if (node.nodeType == node.TEXT_NODE) {\n        return `${node.nodeName} (\"${node.textContent}\")`;\n      }\n      let attrPairs = Array.from(node.attributes || [], function(attr) {\n        return `${attr.name}=\"${attr.value}\"`;\n      }).join(\" \");\n      return `<${node.localName} ${attrPairs}>`;\n    };\n    this.log = function () {\n      if (typeof console !== \"undefined\") {\n        let args = Array.from(arguments, arg => {\n          if (arg && arg.nodeType == this.ELEMENT_NODE) {\n            return logNode(arg);\n          }\n          return arg;\n        });\n        args.unshift(\"Reader: (Readability)\");\n        console.log.apply(console, args);\n      } else if (typeof dump !== \"undefined\") {\n        /* global dump */\n        var msg = Array.prototype.map.call(arguments, function(x) {\n          return (x && x.nodeName) ? logNode(x) : x;\n        }).join(\" \");\n        dump(\"Reader: (Readability) \" + msg + \"\\n\");\n      }\n    };\n  } else {\n    this.log = function () {};\n  }\n}\n\nReadability.prototype = {\n  FLAG_STRIP_UNLIKELYS: 0x1,\n  FLAG_WEIGHT_CLASSES: 0x2,\n  FLAG_CLEAN_CONDITIONALLY: 0x4,\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  // Max number of nodes supported by this parser. Default: 0 (no limit)\n  DEFAULT_MAX_ELEMS_TO_PARSE: 0,\n\n  // The number of top candidates to consider when analysing how\n  // tight the competition is among candidates.\n  DEFAULT_N_TOP_CANDIDATES: 5,\n\n  // Element tags to score by default.\n  DEFAULT_TAGS_TO_SCORE: \"section,h2,h3,h4,h5,h6,p,td,pre\".toUpperCase().split(\",\"),\n\n  // The default number of chars an article must have in order to return a result\n  DEFAULT_CHAR_THRESHOLD: 500,\n\n  // All of the regular expressions in use within readability.\n  // Defined up here so we don't instantiate them repeatedly in loops.\n  REGEXPS: {\n    // NOTE: These two regular expressions are duplicated in\n    // Readability-readerable.js. Please keep both copies in sync.\n    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,\n    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,\n\n    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,\n    negative: /-ad-|hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,\n    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,\n    byline: /byline|author|dateline|writtenby|p-author/i,\n    replaceFonts: /<(\\/?)font[^>]*>/gi,\n    normalize: /\\s{2,}/g,\n    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,\n    shareElements: /(\\b|_)(share|sharedaddy)(\\b|_)/i,\n    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,\n    prevLink: /(prev|earl|old|new|<|«)/i,\n    tokenize: /\\W+/g,\n    whitespace: /^\\s*$/,\n    hasContent: /\\S$/,\n    hashUrl: /^#.+/,\n    srcsetUrl: /(\\S+)(\\s+[\\d.]+[xw])?(\\s*(?:,|$))/g,\n    b64DataUrl: /^data:\\s*([^\\s;,]+)\\s*;\\s*base64\\s*,/i,\n    // Commas as used in Latin, Sindhi, Chinese and various other scripts.\n    // see: https://en.wikipedia.org/wiki/Comma#Comma_variants\n    commas: /\\u002C|\\u060C|\\uFE50|\\uFE10|\\uFE11|\\u2E41|\\u2E34|\\u2E32|\\uFF0C/g,\n    // See: https://schema.org/Article\n    jsonLdArticleTypes: /^Article|AdvertiserContentArticle|NewsArticle|AnalysisNewsArticle|AskPublicNewsArticle|BackgroundNewsArticle|OpinionNewsArticle|ReportageNewsArticle|ReviewNewsArticle|Report|SatiricalArticle|ScholarlyArticle|MedicalScholarlyArticle|SocialMediaPosting|BlogPosting|LiveBlogPosting|DiscussionForumPosting|TechArticle|APIReference$/\n  },\n\n  UNLIKELY_ROLES: [ \"menu\", \"menubar\", \"complementary\", \"navigation\", \"alert\", \"alertdialog\", \"dialog\" ],\n\n  DIV_TO_P_ELEMS: new Set([ \"BLOCKQUOTE\", \"DL\", \"DIV\", \"IMG\", \"OL\", \"P\", \"PRE\", \"TABLE\", \"UL\" ]),\n\n  ALTER_TO_DIV_EXCEPTIONS: [\"DIV\", \"ARTICLE\", \"SECTION\", \"P\"],\n\n  PRESENTATIONAL_ATTRIBUTES: [ \"align\", \"background\", \"bgcolor\", \"border\", \"cellpadding\", \"cellspacing\", \"frame\", \"hspace\", \"rules\", \"style\", \"valign\", \"vspace\" ],\n\n  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: [ \"TABLE\", \"TH\", \"TD\", \"HR\", \"PRE\" ],\n\n  // The commented out elements qualify as phrasing content but tend to be\n  // removed by readability when put into paragraphs, so we ignore them here.\n  PHRASING_ELEMS: [\n    // \"CANVAS\", \"IFRAME\", \"SVG\", \"VIDEO\",\n    \"ABBR\", \"AUDIO\", \"B\", \"BDO\", \"BR\", \"BUTTON\", \"CITE\", \"CODE\", \"DATA\",\n    \"DATALIST\", \"DFN\", \"EM\", \"EMBED\", \"I\", \"IMG\", \"INPUT\", \"KBD\", \"LABEL\",\n    \"MARK\", \"MATH\", \"METER\", \"NOSCRIPT\", \"OBJECT\", \"OUTPUT\", \"PROGRESS\", \"Q\",\n    \"RUBY\", \"SAMP\", \"SCRIPT\", \"SELECT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\",\n    \"SUP\", \"TEXTAREA\", \"TIME\", \"VAR\", \"WBR\"\n  ],\n\n  // These are the classes that readability sets itself.\n  CLASSES_TO_PRESERVE: [ \"page\" ],\n\n  // These are the list of HTML entities that need to be escaped.\n  HTML_ESCAPE_MAP: {\n    \"lt\": \"<\",\n    \"gt\": \">\",\n    \"amp\": \"&\",\n    \"quot\": '\"',\n    \"apos\": \"'\",\n  },\n\n  /**\n   * Run any post-process modifications to article content as necessary.\n   *\n   * @param Element\n   * @return void\n  **/\n  _postProcessContent: function(articleContent) {\n    // Readability cannot open relative uris so we convert them to absolute uris.\n    this._fixRelativeUris(articleContent);\n\n    this._simplifyNestedElements(articleContent);\n\n    if (!this._keepClasses) {\n      // Remove classes.\n      this._cleanClasses(articleContent);\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, calls `filterFn` for each node and removes node\n   * if function returned `true`.\n   *\n   * If function is not passed, removes all the nodes in node list.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param Function filterFn the function to use as a filter\n   * @return void\n   */\n  _removeNodes: function(nodeList, filterFn) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _removeNodes\");\n    }\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      var parentNode = node.parentNode;\n      if (parentNode) {\n        if (!filterFn || filterFn.call(this, node, i, nodeList)) {\n          parentNode.removeChild(node);\n        }\n      }\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, and calls _setNodeTag for each node.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param String newTagName the new tag name to use\n   * @return void\n   */\n  _replaceNodeTags: function(nodeList, newTagName) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _replaceNodeTags\");\n    }\n    for (const node of nodeList) {\n      this._setNodeTag(node, newTagName);\n    }\n  },\n\n  /**\n   * Iterate over a NodeList, which doesn't natively fully implement the Array\n   * interface.\n   *\n   * For convenience, the current object context is applied to the provided\n   * iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return void\n   */\n  _forEachNode: function(nodeList, fn) {\n    Array.prototype.forEach.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, and return the first node that passes\n   * the supplied test function\n   *\n   * For convenience, the current object context is applied to the provided\n   * test function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The test function.\n   * @return void\n   */\n  _findNode: function(nodeList, fn) {\n    return Array.prototype.find.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if any of the provided iterate\n   * function calls returns true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _someNode: function(nodeList, fn) {\n    return Array.prototype.some.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if all of the provided iterate\n   * function calls return true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _everyNode: function(nodeList, fn) {\n    return Array.prototype.every.call(nodeList, fn, this);\n  },\n\n  /**\n   * Concat all nodelists passed as arguments.\n   *\n   * @return ...NodeList\n   * @return Array\n   */\n  _concatNodeLists: function() {\n    var slice = Array.prototype.slice;\n    var args = slice.call(arguments);\n    var nodeLists = args.map(function(list) {\n      return slice.call(list);\n    });\n    return Array.prototype.concat.apply([], nodeLists);\n  },\n\n  _getAllNodesWithTag: function(node, tagNames) {\n    if (node.querySelectorAll) {\n      return node.querySelectorAll(tagNames.join(\",\"));\n    }\n    return [].concat.apply([], tagNames.map(function(tag) {\n      var collection = node.getElementsByTagName(tag);\n      return Array.isArray(collection) ? collection : Array.from(collection);\n    }));\n  },\n\n  /**\n   * Removes the class=\"\" attribute from every element in the given\n   * subtree, except those that match CLASSES_TO_PRESERVE and\n   * the classesToPreserve array from the options object.\n   *\n   * @param Element\n   * @return void\n   */\n  _cleanClasses: function(node) {\n    var classesToPreserve = this._classesToPreserve;\n    var className = (node.getAttribute(\"class\") || \"\")\n      .split(/\\s+/)\n      .filter(function(cls) {\n        return classesToPreserve.indexOf(cls) != -1;\n      })\n      .join(\" \");\n\n    if (className) {\n      node.setAttribute(\"class\", className);\n    } else {\n      node.removeAttribute(\"class\");\n    }\n\n    for (node = node.firstElementChild; node; node = node.nextElementSibling) {\n      this._cleanClasses(node);\n    }\n  },\n\n  /**\n   * Converts each <a> and <img> uri in the given element to an absolute URI,\n   * ignoring #ref URIs.\n   *\n   * @param Element\n   * @return void\n   */\n  _fixRelativeUris: function(articleContent) {\n    var baseURI = this._doc.baseURI;\n    var documentURI = this._doc.documentURI;\n    function toAbsoluteURI(uri) {\n      // Leave hash links alone if the base URI matches the document URI:\n      if (baseURI == documentURI && uri.charAt(0) == \"#\") {\n        return uri;\n      }\n\n      // Otherwise, resolve against base URI:\n      try {\n        return new URL(uri, baseURI).href;\n      } catch (ex) {\n        // Something went wrong, just return the original:\n      }\n      return uri;\n    }\n\n    var links = this._getAllNodesWithTag(articleContent, [\"a\"]);\n    this._forEachNode(links, function(link) {\n      var href = link.getAttribute(\"href\");\n      if (href) {\n        // Remove links with javascript: URIs, since\n        // they won't work after scripts have been removed from the page.\n        if (href.indexOf(\"javascript:\") === 0) {\n          // if the link only contains simple text content, it can be converted to a text node\n          if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {\n            var text = this._doc.createTextNode(link.textContent);\n            link.parentNode.replaceChild(text, link);\n          } else {\n            // if the link has multiple children, they should all be preserved\n            var container = this._doc.createElement(\"span\");\n            while (link.firstChild) {\n              container.appendChild(link.firstChild);\n            }\n            link.parentNode.replaceChild(container, link);\n          }\n        } else {\n          link.setAttribute(\"href\", toAbsoluteURI(href));\n        }\n      }\n    });\n\n    var medias = this._getAllNodesWithTag(articleContent, [\n      \"img\", \"picture\", \"figure\", \"video\", \"audio\", \"source\"\n    ]);\n\n    this._forEachNode(medias, function(media) {\n      var src = media.getAttribute(\"src\");\n      var poster = media.getAttribute(\"poster\");\n      var srcset = media.getAttribute(\"srcset\");\n\n      if (src) {\n        media.setAttribute(\"src\", toAbsoluteURI(src));\n      }\n\n      if (poster) {\n        media.setAttribute(\"poster\", toAbsoluteURI(poster));\n      }\n\n      if (srcset) {\n        var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {\n          return toAbsoluteURI(p1) + (p2 || \"\") + p3;\n        });\n\n        media.setAttribute(\"srcset\", newSrcset);\n      }\n    });\n  },\n\n  _simplifyNestedElements: function(articleContent) {\n    var node = articleContent;\n\n    while (node) {\n      if (node.parentNode && [\"DIV\", \"SECTION\"].includes(node.tagName) && !(node.id && node.id.startsWith(\"readability\"))) {\n        if (this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        } else if (this._hasSingleTagInsideElement(node, \"DIV\") || this._hasSingleTagInsideElement(node, \"SECTION\")) {\n          var child = node.children[0];\n          for (var i = 0; i < node.attributes.length; i++) {\n            child.setAttribute(node.attributes[i].name, node.attributes[i].value);\n          }\n          node.parentNode.replaceChild(child, node);\n          node = child;\n          continue;\n        }\n      }\n\n      node = this._getNextNode(node);\n    }\n  },\n\n  /**\n   * Get the article title as an H1.\n   *\n   * @return string\n   **/\n  _getArticleTitle: function() {\n    var doc = this._doc;\n    var curTitle = \"\";\n    var origTitle = \"\";\n\n    try {\n      curTitle = origTitle = doc.title.trim();\n\n      // If they had an element with id \"title\" in their HTML\n      if (typeof curTitle !== \"string\")\n        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName(\"title\")[0]);\n    } catch (e) {/* ignore exceptions setting the title. */}\n\n    var titleHadHierarchicalSeparators = false;\n    function wordCount(str) {\n      return str.split(/\\s+/).length;\n    }\n\n    // If there's a separator in the title, first remove the final part\n    if ((/ [\\|\\-\\\\\\/>»] /).test(curTitle)) {\n      titleHadHierarchicalSeparators = / [\\\\\\/>»] /.test(curTitle);\n      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>»] .*/gi, \"$1\");\n\n      // If the resulting title is too short (3 words or fewer), remove\n      // the first part instead:\n      if (wordCount(curTitle) < 3)\n        curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>»]*[\\|\\-\\\\\\/>»](.*)/gi, \"$1\");\n    } else if (curTitle.indexOf(\": \") !== -1) {\n      // Check if we have an heading containing this exact string, so we\n      // could assume it's the full title.\n      var headings = this._concatNodeLists(\n        doc.getElementsByTagName(\"h1\"),\n        doc.getElementsByTagName(\"h2\")\n      );\n      var trimmedTitle = curTitle.trim();\n      var match = this._someNode(headings, function(heading) {\n        return heading.textContent.trim() === trimmedTitle;\n      });\n\n      // If we don't, let's extract the title out of the original title string.\n      if (!match) {\n        curTitle = origTitle.substring(origTitle.lastIndexOf(\":\") + 1);\n\n        // If the title is now too short, try the first colon instead:\n        if (wordCount(curTitle) < 3) {\n          curTitle = origTitle.substring(origTitle.indexOf(\":\") + 1);\n          // But if we have too many words before the colon there's something weird\n          // with the titles and the H tags so let's just use the original title instead\n        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(\":\"))) > 5) {\n          curTitle = origTitle;\n        }\n      }\n    } else if (curTitle.length > 150 || curTitle.length < 15) {\n      var hOnes = doc.getElementsByTagName(\"h1\");\n\n      if (hOnes.length === 1)\n        curTitle = this._getInnerText(hOnes[0]);\n    }\n\n    curTitle = curTitle.trim().replace(this.REGEXPS.normalize, \" \");\n    // If we now have 4 words or fewer as our title, and either no\n    // 'hierarchical' separators (\\, /, > or ») were found in the original\n    // title or we decreased the number of words by more than 1 word, use\n    // the original title.\n    var curTitleWordCount = wordCount(curTitle);\n    if (curTitleWordCount <= 4 &&\n        (!titleHadHierarchicalSeparators ||\n         curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>»]+/g, \"\")) - 1)) {\n      curTitle = origTitle;\n    }\n\n    return curTitle;\n  },\n\n  /**\n   * Prepare the HTML document for readability to scrape it.\n   * This includes things like stripping javascript, CSS, and handling terrible markup.\n   *\n   * @return void\n   **/\n  _prepDocument: function() {\n    var doc = this._doc;\n\n    // Remove all style tags in head\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"style\"]));\n\n    if (doc.body) {\n      this._replaceBrs(doc.body);\n    }\n\n    this._replaceNodeTags(this._getAllNodesWithTag(doc, [\"font\"]), \"SPAN\");\n  },\n\n  /**\n   * Finds the next node, starting from the given node, and ignoring\n   * whitespace in between. If the given node is an element, the same node is\n   * returned.\n   */\n  _nextNode: function (node) {\n    var next = node;\n    while (next\n        && (next.nodeType != this.ELEMENT_NODE)\n        && this.REGEXPS.whitespace.test(next.textContent)) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n\n  /**\n   * Replaces 2 or more successive <br> elements with a single <p>.\n   * Whitespace between <br> elements are ignored. For example:\n   *   <div>foo<br>bar<br> <br><br>abc</div>\n   * will become:\n   *   <div>foo<br>bar<p>abc</p></div>\n   */\n  _replaceBrs: function (elem) {\n    this._forEachNode(this._getAllNodesWithTag(elem, [\"br\"]), function(br) {\n      var next = br.nextSibling;\n\n      // Whether 2 or more <br> elements have been found and replaced with a\n      // <p> block.\n      var replaced = false;\n\n      // If we find a <br> chain, remove the <br>s until we hit another node\n      // or non-whitespace. This leaves behind the first <br> in the chain\n      // (which will be replaced with a <p> later).\n      while ((next = this._nextNode(next)) && (next.tagName == \"BR\")) {\n        replaced = true;\n        var brSibling = next.nextSibling;\n        next.parentNode.removeChild(next);\n        next = brSibling;\n      }\n\n      // If we removed a <br> chain, replace the remaining <br> with a <p>. Add\n      // all sibling nodes as children of the <p> until we hit another <br>\n      // chain.\n      if (replaced) {\n        var p = this._doc.createElement(\"p\");\n        br.parentNode.replaceChild(p, br);\n\n        next = p.nextSibling;\n        while (next) {\n          // If we've hit another <br><br>, we're done adding children to this <p>.\n          if (next.tagName == \"BR\") {\n            var nextElem = this._nextNode(next.nextSibling);\n            if (nextElem && nextElem.tagName == \"BR\")\n              break;\n          }\n\n          if (!this._isPhrasingContent(next))\n            break;\n\n          // Otherwise, make this node a child of the new <p>.\n          var sibling = next.nextSibling;\n          p.appendChild(next);\n          next = sibling;\n        }\n\n        while (p.lastChild && this._isWhitespace(p.lastChild)) {\n          p.removeChild(p.lastChild);\n        }\n\n        if (p.parentNode.tagName === \"P\")\n          this._setNodeTag(p.parentNode, \"DIV\");\n      }\n    });\n  },\n\n  _setNodeTag: function (node, tag) {\n    this.log(\"_setNodeTag\", node, tag);\n    if (this._docJSDOMParser) {\n      node.localName = tag.toLowerCase();\n      node.tagName = tag.toUpperCase();\n      return node;\n    }\n\n    var replacement = node.ownerDocument.createElement(tag);\n    while (node.firstChild) {\n      replacement.appendChild(node.firstChild);\n    }\n    node.parentNode.replaceChild(replacement, node);\n    if (node.readability)\n      replacement.readability = node.readability;\n\n    for (var i = 0; i < node.attributes.length; i++) {\n      try {\n        replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);\n      } catch (ex) {\n        /* it's possible for setAttribute() to throw if the attribute name\n         * isn't a valid XML Name. Such attributes can however be parsed from\n         * source in HTML docs, see https://github.com/whatwg/html/issues/4275,\n         * so we can hit them here and then throw. We don't care about such\n         * attributes so we ignore them.\n         */\n      }\n    }\n    return replacement;\n  },\n\n  /**\n   * Prepare the article node for display. Clean out any inline styles,\n   * iframes, forms, strip extraneous <p> tags, etc.\n   *\n   * @param Element\n   * @return void\n   **/\n  _prepArticle: function(articleContent) {\n    this._cleanStyles(articleContent);\n\n    // Check for data tables before we continue, to avoid removing items in\n    // those tables, which will often be isolated even though they're\n    // visually linked to other content-ful elements (text, images, etc.).\n    this._markDataTables(articleContent);\n\n    this._fixLazyImages(articleContent);\n\n    // Clean out junk from the article content\n    this._cleanConditionally(articleContent, \"form\");\n    this._cleanConditionally(articleContent, \"fieldset\");\n    this._clean(articleContent, \"object\");\n    this._clean(articleContent, \"embed\");\n    this._clean(articleContent, \"footer\");\n    this._clean(articleContent, \"link\");\n    this._clean(articleContent, \"aside\");\n\n    // Clean out elements with little content that have \"share\" in their id/class combinations from final top candidates,\n    // which means we don't remove the top candidates even they have \"share\".\n\n    var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;\n\n    this._forEachNode(articleContent.children, function (topCandidate) {\n      this._cleanMatchedNodes(topCandidate, function (node, matchString) {\n        return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;\n      });\n    });\n\n    this._clean(articleContent, \"iframe\");\n    this._clean(articleContent, \"input\");\n    this._clean(articleContent, \"textarea\");\n    this._clean(articleContent, \"select\");\n    this._clean(articleContent, \"button\");\n    this._cleanHeaders(articleContent);\n\n    // Do these last as the previous stuff may have removed junk\n    // that will affect these\n    this._cleanConditionally(articleContent, \"table\");\n    this._cleanConditionally(articleContent, \"ul\");\n    this._cleanConditionally(articleContent, \"div\");\n\n    // replace H1 with H2 as H1 should be only title that is displayed separately\n    this._replaceNodeTags(this._getAllNodesWithTag(articleContent, [\"h1\"]), \"h2\");\n\n    // Remove extra paragraphs\n    this._removeNodes(this._getAllNodesWithTag(articleContent, [\"p\"]), function (paragraph) {\n      var imgCount = paragraph.getElementsByTagName(\"img\").length;\n      var embedCount = paragraph.getElementsByTagName(\"embed\").length;\n      var objectCount = paragraph.getElementsByTagName(\"object\").length;\n      // At this point, nasty iframes have been removed, only remain embedded video ones.\n      var iframeCount = paragraph.getElementsByTagName(\"iframe\").length;\n      var totalCount = imgCount + embedCount + objectCount + iframeCount;\n\n      return totalCount === 0 && !this._getInnerText(paragraph, false);\n    });\n\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"br\"]), function(br) {\n      var next = this._nextNode(br.nextSibling);\n      if (next && next.tagName == \"P\")\n        br.parentNode.removeChild(br);\n    });\n\n    // Remove single-cell tables\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"table\"]), function(table) {\n      var tbody = this._hasSingleTagInsideElement(table, \"TBODY\") ? table.firstElementChild : table;\n      if (this._hasSingleTagInsideElement(tbody, \"TR\")) {\n        var row = tbody.firstElementChild;\n        if (this._hasSingleTagInsideElement(row, \"TD\")) {\n          var cell = row.firstElementChild;\n          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? \"P\" : \"DIV\");\n          table.parentNode.replaceChild(cell, table);\n        }\n      }\n    });\n  },\n\n  /**\n   * Initialize a node with the readability object. Also checks the\n   * className/id for special names to add to its score.\n   *\n   * @param Element\n   * @return void\n  **/\n  _initializeNode: function(node) {\n    node.readability = {\"contentScore\": 0};\n\n    switch (node.tagName) {\n      case \"DIV\":\n        node.readability.contentScore += 5;\n        break;\n\n      case \"PRE\":\n      case \"TD\":\n      case \"BLOCKQUOTE\":\n        node.readability.contentScore += 3;\n        break;\n\n      case \"ADDRESS\":\n      case \"OL\":\n      case \"UL\":\n      case \"DL\":\n      case \"DD\":\n      case \"DT\":\n      case \"LI\":\n      case \"FORM\":\n        node.readability.contentScore -= 3;\n        break;\n\n      case \"H1\":\n      case \"H2\":\n      case \"H3\":\n      case \"H4\":\n      case \"H5\":\n      case \"H6\":\n      case \"TH\":\n        node.readability.contentScore -= 5;\n        break;\n    }\n\n    node.readability.contentScore += this._getClassWeight(node);\n  },\n\n  _removeAndGetNext: function(node) {\n    var nextNode = this._getNextNode(node, true);\n    node.parentNode.removeChild(node);\n    return nextNode;\n  },\n\n  /**\n   * Traverse the DOM from node to node, starting at the node passed in.\n   * Pass true for the second parameter to indicate this node itself\n   * (and its kids) are going away, and we want the next node over.\n   *\n   * Calling this in a loop will traverse the DOM depth-first.\n   */\n  _getNextNode: function(node, ignoreSelfAndKids) {\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.firstElementChild) {\n      return node.firstElementChild;\n    }\n    // Then for siblings...\n    if (node.nextElementSibling) {\n      return node.nextElementSibling;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n    } while (node && !node.nextElementSibling);\n    return node && node.nextElementSibling;\n  },\n\n  // compares second text to first one\n  // 1 = same text, 0 = completely different text\n  // works the way that it splits both texts into words and then finds words that are unique in second text\n  // the result is given by the lower length of unique parts\n  _textSimilarity: function(textA, textB) {\n    var tokensA = textA.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);\n    var tokensB = textB.toLowerCase().split(this.REGEXPS.tokenize).filter(Boolean);\n    if (!tokensA.length || !tokensB.length) {\n      return 0;\n    }\n    var uniqTokensB = tokensB.filter(token => !tokensA.includes(token));\n    var distanceB = uniqTokensB.join(\" \").length / tokensB.join(\" \").length;\n    return 1 - distanceB;\n  },\n\n  _checkByline: function(node, matchString) {\n    if (this._articleByline) {\n      return false;\n    }\n\n    if (node.getAttribute !== undefined) {\n      var rel = node.getAttribute(\"rel\");\n      var itemprop = node.getAttribute(\"itemprop\");\n    }\n\n    if ((rel === \"author\" || (itemprop && itemprop.indexOf(\"author\") !== -1) || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {\n      this._articleByline = node.textContent.trim();\n      return true;\n    }\n\n    return false;\n  },\n\n  _getNodeAncestors: function(node, maxDepth) {\n    maxDepth = maxDepth || 0;\n    var i = 0, ancestors = [];\n    while (node.parentNode) {\n      ancestors.push(node.parentNode);\n      if (maxDepth && ++i === maxDepth)\n        break;\n      node = node.parentNode;\n    }\n    return ancestors;\n  },\n\n  /***\n   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is\n   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.\n   *\n   * @param page a document to run upon. Needs to be a full document, complete with body.\n   * @return Element\n  **/\n  _grabArticle: function (page) {\n    this.log(\"**** grabArticle ****\");\n    var doc = this._doc;\n    var isPaging = page !== null;\n    page = page ? page : this._doc.body;\n\n    // We can't grab an article if we don't have a page!\n    if (!page) {\n      this.log(\"No body found in document. Abort.\");\n      return null;\n    }\n\n    var pageCacheHtml = page.innerHTML;\n\n    while (true) {\n      this.log(\"Starting grabArticle loop\");\n      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);\n\n      // First, node prepping. Trash nodes that look cruddy (like ones with the\n      // class name \"comment\", etc), and turn divs into P tags where they have been\n      // used inappropriately (as in, where they contain no other block level elements.)\n      var elementsToScore = [];\n      var node = this._doc.documentElement;\n\n      let shouldRemoveTitleHeader = true;\n\n      while (node) {\n\n        if (node.tagName === \"HTML\") {\n          this._articleLang = node.getAttribute(\"lang\");\n        }\n\n        var matchString = node.className + \" \" + node.id;\n\n        if (!this._isProbablyVisible(node)) {\n          this.log(\"Removing hidden node - \" + matchString);\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // User is not able to see elements applied with both \"aria-modal = true\" and \"role = dialog\"\n        if (node.getAttribute(\"aria-modal\") == \"true\" && node.getAttribute(\"role\") == \"dialog\") {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Check to see if this node is a byline, and remove it if it is.\n        if (this._checkByline(node, matchString)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        if (shouldRemoveTitleHeader && this._headerDuplicatesTitle(node)) {\n          this.log(\"Removing header: \", node.textContent.trim(), this._articleTitle.trim());\n          shouldRemoveTitleHeader = false;\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Remove unlikely candidates\n        if (stripUnlikelyCandidates) {\n          if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n              !this.REGEXPS.okMaybeItsACandidate.test(matchString) &&\n              !this._hasAncestorTag(node, \"table\") &&\n              !this._hasAncestorTag(node, \"code\") &&\n              node.tagName !== \"BODY\" &&\n              node.tagName !== \"A\") {\n            this.log(\"Removing unlikely candidate - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n\n          if (this.UNLIKELY_ROLES.includes(node.getAttribute(\"role\"))) {\n            this.log(\"Removing content with role \" + node.getAttribute(\"role\") + \" - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n        }\n\n        // Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).\n        if ((node.tagName === \"DIV\" || node.tagName === \"SECTION\" || node.tagName === \"HEADER\" ||\n             node.tagName === \"H1\" || node.tagName === \"H2\" || node.tagName === \"H3\" ||\n             node.tagName === \"H4\" || node.tagName === \"H5\" || node.tagName === \"H6\") &&\n            this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {\n          elementsToScore.push(node);\n        }\n\n        // Turn all divs that don't have children block level elements into p's\n        if (node.tagName === \"DIV\") {\n          // Put phrasing content into paragraphs.\n          var p = null;\n          var childNode = node.firstChild;\n          while (childNode) {\n            var nextSibling = childNode.nextSibling;\n            if (this._isPhrasingContent(childNode)) {\n              if (p !== null) {\n                p.appendChild(childNode);\n              } else if (!this._isWhitespace(childNode)) {\n                p = doc.createElement(\"p\");\n                node.replaceChild(p, childNode);\n                p.appendChild(childNode);\n              }\n            } else if (p !== null) {\n              while (p.lastChild && this._isWhitespace(p.lastChild)) {\n                p.removeChild(p.lastChild);\n              }\n              p = null;\n            }\n            childNode = nextSibling;\n          }\n\n          // Sites like http://mobile.slate.com encloses each paragraph with a DIV\n          // element. DIVs with only a P element inside and no text content can be\n          // safely converted into plain P elements to avoid confusing the scoring\n          // algorithm with DIVs with are, in practice, paragraphs.\n          if (this._hasSingleTagInsideElement(node, \"P\") && this._getLinkDensity(node) < 0.25) {\n            var newNode = node.children[0];\n            node.parentNode.replaceChild(newNode, node);\n            node = newNode;\n            elementsToScore.push(node);\n          } else if (!this._hasChildBlockElement(node)) {\n            node = this._setNodeTag(node, \"P\");\n            elementsToScore.push(node);\n          }\n        }\n        node = this._getNextNode(node);\n      }\n\n      /**\n       * Loop through all paragraphs, and assign a score to them based on how content-y they look.\n       * Then add their score to their parent node.\n       *\n       * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.\n      **/\n      var candidates = [];\n      this._forEachNode(elementsToScore, function(elementToScore) {\n        if (!elementToScore.parentNode || typeof(elementToScore.parentNode.tagName) === \"undefined\")\n          return;\n\n        // If this paragraph is less than 25 characters, don't even count it.\n        var innerText = this._getInnerText(elementToScore);\n        if (innerText.length < 25)\n          return;\n\n        // Exclude nodes with no ancestor.\n        var ancestors = this._getNodeAncestors(elementToScore, 5);\n        if (ancestors.length === 0)\n          return;\n\n        var contentScore = 0;\n\n        // Add a point for the paragraph itself as a base.\n        contentScore += 1;\n\n        // Add points for any commas within this paragraph.\n        contentScore += innerText.split(this.REGEXPS.commas).length;\n\n        // For every 100 characters in this paragraph, add another point. Up to 3 points.\n        contentScore += Math.min(Math.floor(innerText.length / 100), 3);\n\n        // Initialize and score ancestors.\n        this._forEachNode(ancestors, function(ancestor, level) {\n          if (!ancestor.tagName || !ancestor.parentNode || typeof(ancestor.parentNode.tagName) === \"undefined\")\n            return;\n\n          if (typeof(ancestor.readability) === \"undefined\") {\n            this._initializeNode(ancestor);\n            candidates.push(ancestor);\n          }\n\n          // Node score divider:\n          // - parent:             1 (no division)\n          // - grandparent:        2\n          // - great grandparent+: ancestor level * 3\n          if (level === 0)\n            var scoreDivider = 1;\n          else if (level === 1)\n            scoreDivider = 2;\n          else\n            scoreDivider = level * 3;\n          ancestor.readability.contentScore += contentScore / scoreDivider;\n        });\n      });\n\n      // After we've calculated scores, loop through all of the possible\n      // candidate nodes we found and find the one with the highest score.\n      var topCandidates = [];\n      for (var c = 0, cl = candidates.length; c < cl; c += 1) {\n        var candidate = candidates[c];\n\n        // Scale the final candidates score based on link density. Good content\n        // should have a relatively small link density (5% or less) and be mostly\n        // unaffected by this operation.\n        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));\n        candidate.readability.contentScore = candidateScore;\n\n        this.log(\"Candidate:\", candidate, \"with score \" + candidateScore);\n\n        for (var t = 0; t < this._nbTopCandidates; t++) {\n          var aTopCandidate = topCandidates[t];\n\n          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {\n            topCandidates.splice(t, 0, candidate);\n            if (topCandidates.length > this._nbTopCandidates)\n              topCandidates.pop();\n            break;\n          }\n        }\n      }\n\n      var topCandidate = topCandidates[0] || null;\n      var neededToCreateTopCandidate = false;\n      var parentOfTopCandidate;\n\n      // If we still have no top candidate, just use the body as a last resort.\n      // We also have to copy the body node so it is something we can modify.\n      if (topCandidate === null || topCandidate.tagName === \"BODY\") {\n        // Move all of the page's children into topCandidate\n        topCandidate = doc.createElement(\"DIV\");\n        neededToCreateTopCandidate = true;\n        // Move everything (not just elements, also text nodes etc.) into the container\n        // so we even include text directly in the body:\n        while (page.firstChild) {\n          this.log(\"Moving child out:\", page.firstChild);\n          topCandidate.appendChild(page.firstChild);\n        }\n\n        page.appendChild(topCandidate);\n\n        this._initializeNode(topCandidate);\n      } else if (topCandidate) {\n        // Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array\n        // and whose scores are quite closed with current `topCandidate` node.\n        var alternativeCandidateAncestors = [];\n        for (var i = 1; i < topCandidates.length; i++) {\n          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {\n            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));\n          }\n        }\n        var MINIMUM_TOPCANDIDATES = 3;\n        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {\n          parentOfTopCandidate = topCandidate.parentNode;\n          while (parentOfTopCandidate.tagName !== \"BODY\") {\n            var listsContainingThisAncestor = 0;\n            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {\n              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));\n            }\n            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {\n              topCandidate = parentOfTopCandidate;\n              break;\n            }\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n          }\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n\n        // Because of our bonus system, parents of candidates might have scores\n        // themselves. They get half of the node. There won't be nodes with higher\n        // scores than our topCandidate, but if we see the score going *up* in the first\n        // few steps up the tree, that's a decent sign that there might be more content\n        // lurking in other places that we want to unify in. The sibling stuff\n        // below does some of that - but only if we've looked high enough up the DOM\n        // tree.\n        parentOfTopCandidate = topCandidate.parentNode;\n        var lastScore = topCandidate.readability.contentScore;\n        // The scores shouldn't get too low.\n        var scoreThreshold = lastScore / 3;\n        while (parentOfTopCandidate.tagName !== \"BODY\") {\n          if (!parentOfTopCandidate.readability) {\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n            continue;\n          }\n          var parentScore = parentOfTopCandidate.readability.contentScore;\n          if (parentScore < scoreThreshold)\n            break;\n          if (parentScore > lastScore) {\n            // Alright! We found a better parent to use.\n            topCandidate = parentOfTopCandidate;\n            break;\n          }\n          lastScore = parentOfTopCandidate.readability.contentScore;\n          parentOfTopCandidate = parentOfTopCandidate.parentNode;\n        }\n\n        // If the top candidate is the only child, use parent instead. This will help sibling\n        // joining logic when adjacent content is actually located in parent's sibling node.\n        parentOfTopCandidate = topCandidate.parentNode;\n        while (parentOfTopCandidate.tagName != \"BODY\" && parentOfTopCandidate.children.length == 1) {\n          topCandidate = parentOfTopCandidate;\n          parentOfTopCandidate = topCandidate.parentNode;\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n      }\n\n      // Now that we have the top candidate, look through its siblings for content\n      // that might also be related. Things like preambles, content split by ads\n      // that we removed, etc.\n      var articleContent = doc.createElement(\"DIV\");\n      if (isPaging)\n        articleContent.id = \"readability-content\";\n\n      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);\n      // Keep potential top candidate's parent node to try to get text direction of it later.\n      parentOfTopCandidate = topCandidate.parentNode;\n      var siblings = parentOfTopCandidate.children;\n\n      for (var s = 0, sl = siblings.length; s < sl; s++) {\n        var sibling = siblings[s];\n        var append = false;\n\n        this.log(\"Looking at sibling node:\", sibling, sibling.readability ? (\"with score \" + sibling.readability.contentScore) : \"\");\n        this.log(\"Sibling has score\", sibling.readability ? sibling.readability.contentScore : \"Unknown\");\n\n        if (sibling === topCandidate) {\n          append = true;\n        } else {\n          var contentBonus = 0;\n\n          // Give a bonus if sibling nodes and top candidates have the example same classname\n          if (sibling.className === topCandidate.className && topCandidate.className !== \"\")\n            contentBonus += topCandidate.readability.contentScore * 0.2;\n\n          if (sibling.readability &&\n              ((sibling.readability.contentScore + contentBonus) >= siblingScoreThreshold)) {\n            append = true;\n          } else if (sibling.nodeName === \"P\") {\n            var linkDensity = this._getLinkDensity(sibling);\n            var nodeContent = this._getInnerText(sibling);\n            var nodeLength = nodeContent.length;\n\n            if (nodeLength > 80 && linkDensity < 0.25) {\n              append = true;\n            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 &&\n                       nodeContent.search(/\\.( |$)/) !== -1) {\n              append = true;\n            }\n          }\n        }\n\n        if (append) {\n          this.log(\"Appending node:\", sibling);\n\n          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {\n            // We have a node that isn't a common block level element, like a form or td tag.\n            // Turn it into a div so it doesn't get filtered out later by accident.\n            this.log(\"Altering sibling:\", sibling, \"to div.\");\n\n            sibling = this._setNodeTag(sibling, \"DIV\");\n          }\n\n          articleContent.appendChild(sibling);\n          // Fetch children again to make it compatible\n          // with DOM parsers without live collection support.\n          siblings = parentOfTopCandidate.children;\n          // siblings is a reference to the children array, and\n          // sibling is removed from the array when we call appendChild().\n          // As a result, we must revisit this index since the nodes\n          // have been shifted.\n          s -= 1;\n          sl -= 1;\n        }\n      }\n\n      if (this._debug)\n        this.log(\"Article content pre-prep: \" + articleContent.innerHTML);\n      // So we have all of the content that we need. Now we clean it up for presentation.\n      this._prepArticle(articleContent);\n      if (this._debug)\n        this.log(\"Article content post-prep: \" + articleContent.innerHTML);\n\n      if (neededToCreateTopCandidate) {\n        // We already created a fake div thing, and there wouldn't have been any siblings left\n        // for the previous loop, so there's no point trying to create a new div, and then\n        // move all the children over. Just assign IDs and class names here. No need to append\n        // because that already happened anyway.\n        topCandidate.id = \"readability-page-1\";\n        topCandidate.className = \"page\";\n      } else {\n        var div = doc.createElement(\"DIV\");\n        div.id = \"readability-page-1\";\n        div.className = \"page\";\n        while (articleContent.firstChild) {\n          div.appendChild(articleContent.firstChild);\n        }\n        articleContent.appendChild(div);\n      }\n\n      if (this._debug)\n        this.log(\"Article content after paging: \" + articleContent.innerHTML);\n\n      var parseSuccessful = true;\n\n      // Now that we've gone through the full algorithm, check to see if\n      // we got any meaningful content. If we didn't, we may need to re-run\n      // grabArticle with different flags set. This gives us a higher likelihood of\n      // finding the content, and the sieve approach gives us a higher likelihood of\n      // finding the -right- content.\n      var textLength = this._getInnerText(articleContent, true).length;\n      if (textLength < this._charThreshold) {\n        parseSuccessful = false;\n        page.innerHTML = pageCacheHtml;\n\n        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {\n          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {\n          this._removeFlag(this.FLAG_WEIGHT_CLASSES);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {\n          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else {\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n          // No luck after removing flags, just return the longest text we found during the different loops\n          this._attempts.sort(function (a, b) {\n            return b.textLength - a.textLength;\n          });\n\n          // But first check if we actually have something\n          if (!this._attempts[0].textLength) {\n            return null;\n          }\n\n          articleContent = this._attempts[0].articleContent;\n          parseSuccessful = true;\n        }\n      }\n\n      if (parseSuccessful) {\n        // Find out text direction from ancestors of final top candidate.\n        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));\n        this._someNode(ancestors, function(ancestor) {\n          if (!ancestor.tagName)\n            return false;\n          var articleDir = ancestor.getAttribute(\"dir\");\n          if (articleDir) {\n            this._articleDir = articleDir;\n            return true;\n          }\n          return false;\n        });\n        return articleContent;\n      }\n    }\n  },\n\n  /**\n   * Check whether the input string could be a byline.\n   * This verifies that the input is a string, and that the length\n   * is less than 100 chars.\n   *\n   * @param possibleByline {string} - a string to check whether its a byline.\n   * @return Boolean - whether the input string is a byline.\n   */\n  _isValidByline: function(byline) {\n    if (typeof byline == \"string\" || byline instanceof String) {\n      byline = byline.trim();\n      return (byline.length > 0) && (byline.length < 100);\n    }\n    return false;\n  },\n\n  /**\n   * Converts some of the common HTML entities in string to their corresponding characters.\n   *\n   * @param str {string} - a string to unescape.\n   * @return string without HTML entity.\n   */\n  _unescapeHtmlEntities: function(str) {\n    if (!str) {\n      return str;\n    }\n\n    var htmlEscapeMap = this.HTML_ESCAPE_MAP;\n    return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {\n      return htmlEscapeMap[tag];\n    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {\n      var num = parseInt(hex || numStr, hex ? 16 : 10);\n      return String.fromCharCode(num);\n    });\n  },\n\n  /**\n   * Try to extract metadata from JSON-LD object.\n   * For now, only Schema.org objects of type Article or its subtypes are supported.\n   * @return Object with any metadata that could be extracted (possibly none)\n   */\n  _getJSONLD: function (doc) {\n    var scripts = this._getAllNodesWithTag(doc, [\"script\"]);\n\n    var metadata;\n\n    this._forEachNode(scripts, function(jsonLdElement) {\n      if (!metadata && jsonLdElement.getAttribute(\"type\") === \"application/ld+json\") {\n        try {\n          // Strip CDATA markers if present\n          var content = jsonLdElement.textContent.replace(/^\\s*<!\\[CDATA\\[|\\]\\]>\\s*$/g, \"\");\n          var parsed = JSON.parse(content);\n          if (\n            !parsed[\"@context\"] ||\n            !parsed[\"@context\"].match(/^https?\\:\\/\\/schema\\.org$/)\n          ) {\n            return;\n          }\n\n          if (!parsed[\"@type\"] && Array.isArray(parsed[\"@graph\"])) {\n            parsed = parsed[\"@graph\"].find(function(it) {\n              return (it[\"@type\"] || \"\").match(\n                this.REGEXPS.jsonLdArticleTypes\n              );\n            });\n          }\n\n          if (\n            !parsed ||\n            !parsed[\"@type\"] ||\n            !parsed[\"@type\"].match(this.REGEXPS.jsonLdArticleTypes)\n          ) {\n            return;\n          }\n\n          metadata = {};\n\n          if (typeof parsed.name === \"string\" && typeof parsed.headline === \"string\" && parsed.name !== parsed.headline) {\n            // we have both name and headline element in the JSON-LD. They should both be the same but some websites like aktualne.cz\n            // put their own name into \"name\" and the article title to \"headline\" which confuses Readability. So we try to check if either\n            // \"name\" or \"headline\" closely matches the html title, and if so, use that one. If not, then we use \"name\" by default.\n\n            var title = this._getArticleTitle();\n            var nameMatches = this._textSimilarity(parsed.name, title) > 0.75;\n            var headlineMatches = this._textSimilarity(parsed.headline, title) > 0.75;\n\n            if (headlineMatches && !nameMatches) {\n              metadata.title = parsed.headline;\n            } else {\n              metadata.title = parsed.name;\n            }\n          } else if (typeof parsed.name === \"string\") {\n            metadata.title = parsed.name.trim();\n          } else if (typeof parsed.headline === \"string\") {\n            metadata.title = parsed.headline.trim();\n          }\n          if (parsed.author) {\n            if (typeof parsed.author.name === \"string\") {\n              metadata.byline = parsed.author.name.trim();\n            } else if (Array.isArray(parsed.author) && parsed.author[0] && typeof parsed.author[0].name === \"string\") {\n              metadata.byline = parsed.author\n                .filter(function(author) {\n                  return author && typeof author.name === \"string\";\n                })\n                .map(function(author) {\n                  return author.name.trim();\n                })\n                .join(\", \");\n            }\n          }\n          if (typeof parsed.description === \"string\") {\n            metadata.excerpt = parsed.description.trim();\n          }\n          if (\n            parsed.publisher &&\n            typeof parsed.publisher.name === \"string\"\n          ) {\n            metadata.siteName = parsed.publisher.name.trim();\n          }\n          if (typeof parsed.datePublished === \"string\") {\n            metadata.datePublished = parsed.datePublished.trim();\n          }\n          return;\n        } catch (err) {\n          this.log(err.message);\n        }\n      }\n    });\n    return metadata ? metadata : {};\n  },\n\n  /**\n   * Attempts to get excerpt and byline metadata for the article.\n   *\n   * @param {Object} jsonld — object containing any metadata that\n   * could be extracted from JSON-LD object.\n   *\n   * @return Object with optional \"excerpt\" and \"byline\" properties\n   */\n  _getArticleMetadata: function(jsonld) {\n    var metadata = {};\n    var values = {};\n    var metaElements = this._doc.getElementsByTagName(\"meta\");\n\n    // property is a space-separated list of values\n    var propertyPattern = /\\s*(article|dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|published_time|title|site_name)\\s*/gi;\n\n    // name is a single value\n    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title|site_name)\\s*$/i;\n\n    // Find description tags.\n    this._forEachNode(metaElements, function(element) {\n      var elementName = element.getAttribute(\"name\");\n      var elementProperty = element.getAttribute(\"property\");\n      var content = element.getAttribute(\"content\");\n      if (!content) {\n        return;\n      }\n      var matches = null;\n      var name = null;\n\n      if (elementProperty) {\n        matches = elementProperty.match(propertyPattern);\n        if (matches) {\n          // Convert to lowercase, and remove any whitespace\n          // so we can match below.\n          name = matches[0].toLowerCase().replace(/\\s/g, \"\");\n          // multiple authors\n          values[name] = content.trim();\n        }\n      }\n      if (!matches && elementName && namePattern.test(elementName)) {\n        name = elementName;\n        if (content) {\n          // Convert to lowercase, remove any whitespace, and convert dots\n          // to colons so we can match below.\n          name = name.toLowerCase().replace(/\\s/g, \"\").replace(/\\./g, \":\");\n          values[name] = content.trim();\n        }\n      }\n    });\n\n    // get title\n    metadata.title = jsonld.title ||\n                     values[\"dc:title\"] ||\n                     values[\"dcterm:title\"] ||\n                     values[\"og:title\"] ||\n                     values[\"weibo:article:title\"] ||\n                     values[\"weibo:webpage:title\"] ||\n                     values[\"title\"] ||\n                     values[\"twitter:title\"];\n\n    if (!metadata.title) {\n      metadata.title = this._getArticleTitle();\n    }\n\n    // get author\n    metadata.byline = jsonld.byline ||\n                      values[\"dc:creator\"] ||\n                      values[\"dcterm:creator\"] ||\n                      values[\"author\"];\n\n    // get description\n    metadata.excerpt = jsonld.excerpt ||\n                       values[\"dc:description\"] ||\n                       values[\"dcterm:description\"] ||\n                       values[\"og:description\"] ||\n                       values[\"weibo:article:description\"] ||\n                       values[\"weibo:webpage:description\"] ||\n                       values[\"description\"] ||\n                       values[\"twitter:description\"];\n\n    // get site name\n    metadata.siteName = jsonld.siteName ||\n                        values[\"og:site_name\"];\n\n    // get article published time\n    metadata.publishedTime = jsonld.datePublished ||\n      values[\"article:published_time\"] || null;\n\n    // in many sites the meta value is escaped with HTML entities,\n    // so here we need to unescape it\n    metadata.title = this._unescapeHtmlEntities(metadata.title);\n    metadata.byline = this._unescapeHtmlEntities(metadata.byline);\n    metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);\n    metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);\n    metadata.publishedTime = this._unescapeHtmlEntities(metadata.publishedTime);\n\n    return metadata;\n  },\n\n  /**\n   * Check if node is image, or if node contains exactly only one image\n   * whether as a direct child or as its descendants.\n   *\n   * @param Element\n  **/\n  _isSingleImage: function(node) {\n    if (node.tagName === \"IMG\") {\n      return true;\n    }\n\n    if (node.children.length !== 1 || node.textContent.trim() !== \"\") {\n      return false;\n    }\n\n    return this._isSingleImage(node.children[0]);\n  },\n\n  /**\n   * Find all <noscript> that are located after <img> nodes, and which contain only one\n   * <img> element. Replace the first image with the image from inside the <noscript> tag,\n   * and remove the <noscript> tag. This improves the quality of the images we use on\n   * some sites (e.g. Medium).\n   *\n   * @param Element\n  **/\n  _unwrapNoscriptImages: function(doc) {\n    // Find img without source or attributes that might contains image, and remove it.\n    // This is done to prevent a placeholder img is replaced by img from noscript in next step.\n    var imgs = Array.from(doc.getElementsByTagName(\"img\"));\n    this._forEachNode(imgs, function(img) {\n      for (var i = 0; i < img.attributes.length; i++) {\n        var attr = img.attributes[i];\n        switch (attr.name) {\n          case \"src\":\n          case \"srcset\":\n          case \"data-src\":\n          case \"data-srcset\":\n            return;\n        }\n\n        if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n          return;\n        }\n      }\n\n      img.parentNode.removeChild(img);\n    });\n\n    // Next find noscript and try to extract its image\n    var noscripts = Array.from(doc.getElementsByTagName(\"noscript\"));\n    this._forEachNode(noscripts, function(noscript) {\n      // Parse content of noscript and make sure it only contains image\n      var tmp = doc.createElement(\"div\");\n      tmp.innerHTML = noscript.innerHTML;\n      if (!this._isSingleImage(tmp)) {\n        return;\n      }\n\n      // If noscript has previous sibling and it only contains image,\n      // replace it with noscript content. However we also keep old\n      // attributes that might contains image.\n      var prevElement = noscript.previousElementSibling;\n      if (prevElement && this._isSingleImage(prevElement)) {\n        var prevImg = prevElement;\n        if (prevImg.tagName !== \"IMG\") {\n          prevImg = prevElement.getElementsByTagName(\"img\")[0];\n        }\n\n        var newImg = tmp.getElementsByTagName(\"img\")[0];\n        for (var i = 0; i < prevImg.attributes.length; i++) {\n          var attr = prevImg.attributes[i];\n          if (attr.value === \"\") {\n            continue;\n          }\n\n          if (attr.name === \"src\" || attr.name === \"srcset\" || /\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            if (newImg.getAttribute(attr.name) === attr.value) {\n              continue;\n            }\n\n            var attrName = attr.name;\n            if (newImg.hasAttribute(attrName)) {\n              attrName = \"data-old-\" + attrName;\n            }\n\n            newImg.setAttribute(attrName, attr.value);\n          }\n        }\n\n        noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);\n      }\n    });\n  },\n\n  /**\n   * Removes script tags from the document.\n   *\n   * @param Element\n  **/\n  _removeScripts: function(doc) {\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"script\", \"noscript\"]));\n  },\n\n  /**\n   * Check if this node has only whitespace and a single element with given tag\n   * Returns false if the DIV node contains non-empty text nodes\n   * or if it contains no element with given tag or more than 1 element.\n   *\n   * @param Element\n   * @param string tag of child element\n  **/\n  _hasSingleTagInsideElement: function(element, tag) {\n    // There should be exactly 1 element child with given tag\n    if (element.children.length != 1 || element.children[0].tagName !== tag) {\n      return false;\n    }\n\n    // And there should be no text nodes with real content\n    return !this._someNode(element.childNodes, function(node) {\n      return node.nodeType === this.TEXT_NODE &&\n             this.REGEXPS.hasContent.test(node.textContent);\n    });\n  },\n\n  _isElementWithoutContent: function(node) {\n    return node.nodeType === this.ELEMENT_NODE &&\n      node.textContent.trim().length == 0 &&\n      (node.children.length == 0 ||\n       node.children.length == node.getElementsByTagName(\"br\").length + node.getElementsByTagName(\"hr\").length);\n  },\n\n  /**\n   * Determine whether element has any children block level elements.\n   *\n   * @param Element\n   */\n  _hasChildBlockElement: function (element) {\n    return this._someNode(element.childNodes, function(node) {\n      return this.DIV_TO_P_ELEMS.has(node.tagName) ||\n             this._hasChildBlockElement(node);\n    });\n  },\n\n  /***\n   * Determine if a node qualifies as phrasing content.\n   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n  **/\n  _isPhrasingContent: function(node) {\n    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 ||\n      ((node.tagName === \"A\" || node.tagName === \"DEL\" || node.tagName === \"INS\") &&\n        this._everyNode(node.childNodes, this._isPhrasingContent));\n  },\n\n  _isWhitespace: function(node) {\n    return (node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0) ||\n           (node.nodeType === this.ELEMENT_NODE && node.tagName === \"BR\");\n  },\n\n  /**\n   * Get the inner text of a node - cross browser compatibly.\n   * This also strips out any excess whitespace to be found.\n   *\n   * @param Element\n   * @param Boolean normalizeSpaces (default: true)\n   * @return string\n  **/\n  _getInnerText: function(e, normalizeSpaces) {\n    normalizeSpaces = (typeof normalizeSpaces === \"undefined\") ? true : normalizeSpaces;\n    var textContent = e.textContent.trim();\n\n    if (normalizeSpaces) {\n      return textContent.replace(this.REGEXPS.normalize, \" \");\n    }\n    return textContent;\n  },\n\n  /**\n   * Get the number of times a string s appears in the node e.\n   *\n   * @param Element\n   * @param string - what to split on. Default is \",\"\n   * @return number (integer)\n  **/\n  _getCharCount: function(e, s) {\n    s = s || \",\";\n    return this._getInnerText(e).split(s).length - 1;\n  },\n\n  /**\n   * Remove the style attribute on every e and under.\n   * TODO: Test if getElementsByTagName(*) is faster.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanStyles: function(e) {\n    if (!e || e.tagName.toLowerCase() === \"svg\")\n      return;\n\n    // Remove `style` and deprecated presentational attributes\n    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {\n      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);\n    }\n\n    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {\n      e.removeAttribute(\"width\");\n      e.removeAttribute(\"height\");\n    }\n\n    var cur = e.firstElementChild;\n    while (cur !== null) {\n      this._cleanStyles(cur);\n      cur = cur.nextElementSibling;\n    }\n  },\n\n  /**\n   * Get the density of links as a percentage of the content\n   * This is the amount of text that is inside a link divided by the total text in the node.\n   *\n   * @param Element\n   * @return number (float)\n  **/\n  _getLinkDensity: function(element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0)\n      return 0;\n\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function(linkNode) {\n      var href = linkNode.getAttribute(\"href\");\n      var coefficient = href && this.REGEXPS.hashUrl.test(href) ? 0.3 : 1;\n      linkLength += this._getInnerText(linkNode).length * coefficient;\n    });\n\n    return linkLength / textLength;\n  },\n\n  /**\n   * Get an elements class/id weight. Uses regular expressions to tell if this\n   * element looks good or bad.\n   *\n   * @param Element\n   * @return number (Integer)\n  **/\n  _getClassWeight: function(e) {\n    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))\n      return 0;\n\n    var weight = 0;\n\n    // Look for a special classname\n    if (typeof(e.className) === \"string\" && e.className !== \"\") {\n      if (this.REGEXPS.negative.test(e.className))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.className))\n        weight += 25;\n    }\n\n    // Look for a special ID\n    if (typeof(e.id) === \"string\" && e.id !== \"\") {\n      if (this.REGEXPS.negative.test(e.id))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.id))\n        weight += 25;\n    }\n\n    return weight;\n  },\n\n  /**\n   * Clean a node of all elements of type \"tag\".\n   * (Unless it's a youtube/vimeo video. People love movies.)\n   *\n   * @param Element\n   * @param string tag to clean\n   * @return void\n   **/\n  _clean: function(e, tag) {\n    var isEmbed = [\"object\", \"embed\", \"iframe\"].indexOf(tag) !== -1;\n\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {\n      // Allow youtube and vimeo videos through as people usually want to see those.\n      if (isEmbed) {\n        // First, check the elements attributes to see if any of them contain youtube or vimeo\n        for (var i = 0; i < element.attributes.length; i++) {\n          if (this._allowedVideoRegex.test(element.attributes[i].value)) {\n            return false;\n          }\n        }\n\n        // For embed with <object> tag, check inner HTML as well.\n        if (element.tagName === \"object\" && this._allowedVideoRegex.test(element.innerHTML)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  },\n\n  /**\n   * Check if a given node has one of its ancestor tag name matching the\n   * provided one.\n   * @param  HTMLElement node\n   * @param  String      tagName\n   * @param  Number      maxDepth\n   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'\n   * @return Boolean\n   */\n  _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {\n    maxDepth = maxDepth || 3;\n    tagName = tagName.toUpperCase();\n    var depth = 0;\n    while (node.parentNode) {\n      if (maxDepth > 0 && depth > maxDepth)\n        return false;\n      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))\n        return true;\n      node = node.parentNode;\n      depth++;\n    }\n    return false;\n  },\n\n  /**\n   * Return an object indicating how many rows and columns this table has.\n   */\n  _getRowAndColumnCount: function(table) {\n    var rows = 0;\n    var columns = 0;\n    var trs = table.getElementsByTagName(\"tr\");\n    for (var i = 0; i < trs.length; i++) {\n      var rowspan = trs[i].getAttribute(\"rowspan\") || 0;\n      if (rowspan) {\n        rowspan = parseInt(rowspan, 10);\n      }\n      rows += (rowspan || 1);\n\n      // Now look for column-related info\n      var columnsInThisRow = 0;\n      var cells = trs[i].getElementsByTagName(\"td\");\n      for (var j = 0; j < cells.length; j++) {\n        var colspan = cells[j].getAttribute(\"colspan\") || 0;\n        if (colspan) {\n          colspan = parseInt(colspan, 10);\n        }\n        columnsInThisRow += (colspan || 1);\n      }\n      columns = Math.max(columns, columnsInThisRow);\n    }\n    return {rows: rows, columns: columns};\n  },\n\n  /**\n   * Look for 'data' (as opposed to 'layout') tables, for which we use\n   * similar checks as\n   * https://searchfox.org/mozilla-central/rev/f82d5c549f046cb64ce5602bfd894b7ae807c8f8/accessible/generic/TableAccessible.cpp#19\n   */\n  _markDataTables: function(root) {\n    var tables = root.getElementsByTagName(\"table\");\n    for (var i = 0; i < tables.length; i++) {\n      var table = tables[i];\n      var role = table.getAttribute(\"role\");\n      if (role == \"presentation\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var datatable = table.getAttribute(\"datatable\");\n      if (datatable == \"0\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var summary = table.getAttribute(\"summary\");\n      if (summary) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      var caption = table.getElementsByTagName(\"caption\")[0];\n      if (caption && caption.childNodes.length > 0) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // If the table has a descendant with any of these tags, consider a data table:\n      var dataTableDescendants = [\"col\", \"colgroup\", \"tfoot\", \"thead\", \"th\"];\n      var descendantExists = function(tag) {\n        return !!table.getElementsByTagName(tag)[0];\n      };\n      if (dataTableDescendants.some(descendantExists)) {\n        this.log(\"Data table because found data-y descendant\");\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // Nested tables indicate a layout table:\n      if (table.getElementsByTagName(\"table\")[0]) {\n        table._readabilityDataTable = false;\n        continue;\n      }\n\n      var sizeInfo = this._getRowAndColumnCount(table);\n      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n      // Now just go by size entirely:\n      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;\n    }\n  },\n\n  /* convert images and figures that have properties like data-src into images that can be loaded without JS */\n  _fixLazyImages: function (root) {\n    this._forEachNode(this._getAllNodesWithTag(root, [\"img\", \"picture\", \"figure\"]), function (elem) {\n      // In some sites (e.g. Kotaku), they put 1px square image as base64 data uri in the src attribute.\n      // So, here we check if the data uri is too short, just might as well remove it.\n      if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {\n        // Make sure it's not SVG, because SVG can have a meaningful image in under 133 bytes.\n        var parts = this.REGEXPS.b64DataUrl.exec(elem.src);\n        if (parts[1] === \"image/svg+xml\") {\n          return;\n        }\n\n        // Make sure this element has other attributes which contains image.\n        // If it doesn't, then this src is important and shouldn't be removed.\n        var srcCouldBeRemoved = false;\n        for (var i = 0; i < elem.attributes.length; i++) {\n          var attr = elem.attributes[i];\n          if (attr.name === \"src\") {\n            continue;\n          }\n\n          if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            srcCouldBeRemoved = true;\n            break;\n          }\n        }\n\n        // Here we assume if image is less than 100 bytes (or 133B after encoded to base64)\n        // it will be too small, therefore it might be placeholder image.\n        if (srcCouldBeRemoved) {\n          var b64starts = elem.src.search(/base64\\s*/i) + 7;\n          var b64length = elem.src.length - b64starts;\n          if (b64length < 133) {\n            elem.removeAttribute(\"src\");\n          }\n        }\n      }\n\n      // also check for \"null\" to work around https://github.com/jsdom/jsdom/issues/2580\n      if ((elem.src || (elem.srcset && elem.srcset != \"null\")) && elem.className.toLowerCase().indexOf(\"lazy\") === -1) {\n        return;\n      }\n\n      for (var j = 0; j < elem.attributes.length; j++) {\n        attr = elem.attributes[j];\n        if (attr.name === \"src\" || attr.name === \"srcset\" || attr.name === \"alt\") {\n          continue;\n        }\n        var copyTo = null;\n        if (/\\.(jpg|jpeg|png|webp)\\s+\\d/.test(attr.value)) {\n          copyTo = \"srcset\";\n        } else if (/^\\s*\\S+\\.(jpg|jpeg|png|webp)\\S*\\s*$/.test(attr.value)) {\n          copyTo = \"src\";\n        }\n        if (copyTo) {\n          //if this is an img or picture, set the attribute directly\n          if (elem.tagName === \"IMG\" || elem.tagName === \"PICTURE\") {\n            elem.setAttribute(copyTo, attr.value);\n          } else if (elem.tagName === \"FIGURE\" && !this._getAllNodesWithTag(elem, [\"img\", \"picture\"]).length) {\n            //if the item is a <figure> that does not contain an image or picture, create one and place it inside the figure\n            //see the nytimes-3 testcase for an example\n            var img = this._doc.createElement(\"img\");\n            img.setAttribute(copyTo, attr.value);\n            elem.appendChild(img);\n          }\n        }\n      }\n    });\n  },\n\n  _getTextDensity: function(e, tags) {\n    var textLength = this._getInnerText(e, true).length;\n    if (textLength === 0) {\n      return 0;\n    }\n    var childrenLength = 0;\n    var children = this._getAllNodesWithTag(e, tags);\n    this._forEachNode(children, (child) => childrenLength += this._getInnerText(child, true).length);\n    return childrenLength / textLength;\n  },\n\n  /**\n   * Clean an element of all tags of type \"tag\" if they look fishy.\n   * \"Fishy\" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.\n   *\n   * @return void\n   **/\n  _cleanConditionally: function(e, tag) {\n    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))\n      return;\n\n    // Gather counts for other typical elements embedded within.\n    // Traverse backwards so we can remove nodes at the same time\n    // without effecting the traversal.\n    //\n    // TODO: Consider taking into account original contentScore here.\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {\n      // First check if this node IS data table, in which case don't remove it.\n      var isDataTable = function(t) {\n        return t._readabilityDataTable;\n      };\n\n      var isList = tag === \"ul\" || tag === \"ol\";\n      if (!isList) {\n        var listLength = 0;\n        var listNodes = this._getAllNodesWithTag(node, [\"ul\", \"ol\"]);\n        this._forEachNode(listNodes, (list) => listLength += this._getInnerText(list).length);\n        isList = listLength / this._getInnerText(node).length > 0.9;\n      }\n\n      if (tag === \"table\" && isDataTable(node)) {\n        return false;\n      }\n\n      // Next check if we're inside a data table, in which case don't remove it as well.\n      if (this._hasAncestorTag(node, \"table\", -1, isDataTable)) {\n        return false;\n      }\n\n      if (this._hasAncestorTag(node, \"code\")) {\n        return false;\n      }\n\n      var weight = this._getClassWeight(node);\n\n      this.log(\"Cleaning Conditionally\", node);\n\n      var contentScore = 0;\n\n      if (weight + contentScore < 0) {\n        return true;\n      }\n\n      if (this._getCharCount(node, \",\") < 10) {\n        // If there are not very many commas, and the number of\n        // non-paragraph elements is more than paragraphs or other\n        // ominous signs, remove the element.\n        var p = node.getElementsByTagName(\"p\").length;\n        var img = node.getElementsByTagName(\"img\").length;\n        var li = node.getElementsByTagName(\"li\").length - 100;\n        var input = node.getElementsByTagName(\"input\").length;\n        var headingDensity = this._getTextDensity(node, [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]);\n\n        var embedCount = 0;\n        var embeds = this._getAllNodesWithTag(node, [\"object\", \"embed\", \"iframe\"]);\n\n        for (var i = 0; i < embeds.length; i++) {\n          // If this embed has attribute that matches video regex, don't delete it.\n          for (var j = 0; j < embeds[i].attributes.length; j++) {\n            if (this._allowedVideoRegex.test(embeds[i].attributes[j].value)) {\n              return false;\n            }\n          }\n\n          // For embed with <object> tag, check inner HTML as well.\n          if (embeds[i].tagName === \"object\" && this._allowedVideoRegex.test(embeds[i].innerHTML)) {\n            return false;\n          }\n\n          embedCount++;\n        }\n\n        var linkDensity = this._getLinkDensity(node);\n        var contentLength = this._getInnerText(node).length;\n\n        var haveToRemove =\n          (img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && li > p) ||\n          (input > Math.floor(p/3)) ||\n          (!isList && headingDensity < 0.9 && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && weight < 25 && linkDensity > 0.2) ||\n          (weight >= 25 && linkDensity > 0.5) ||\n          ((embedCount === 1 && contentLength < 75) || embedCount > 1);\n        // Allow simple lists of images to remain in pages\n        if (isList && haveToRemove) {\n          for (var x = 0; x < node.children.length; x++) {\n            let child = node.children[x];\n            // Don't filter in lists with li's that contain more than one child\n            if (child.children.length > 1) {\n              return haveToRemove;\n            }\n          }\n          let li_count = node.getElementsByTagName(\"li\").length;\n          // Only allow the list to remain if every li contains an image\n          if (img == li_count) {\n            return false;\n          }\n        }\n        return haveToRemove;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Clean out elements that match the specified conditions\n   *\n   * @param Element\n   * @param Function determines whether a node should be removed\n   * @return void\n   **/\n  _cleanMatchedNodes: function(e, filter) {\n    var endOfSearchMarkerNode = this._getNextNode(e, true);\n    var next = this._getNextNode(e);\n    while (next && next != endOfSearchMarkerNode) {\n      if (filter.call(this, next, next.className + \" \" + next.id)) {\n        next = this._removeAndGetNext(next);\n      } else {\n        next = this._getNextNode(next);\n      }\n    }\n  },\n\n  /**\n   * Clean out spurious headers from an Element.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanHeaders: function(e) {\n    let headingNodes = this._getAllNodesWithTag(e, [\"h1\", \"h2\"]);\n    this._removeNodes(headingNodes, function(node) {\n      let shouldRemove = this._getClassWeight(node) < 0;\n      if (shouldRemove) {\n        this.log(\"Removing header with low class weight:\", node);\n      }\n      return shouldRemove;\n    });\n  },\n\n  /**\n   * Check if this node is an H1 or H2 element whose content is mostly\n   * the same as the article title.\n   *\n   * @param Element  the node to check.\n   * @return boolean indicating whether this is a title-like header.\n   */\n  _headerDuplicatesTitle: function(node) {\n    if (node.tagName != \"H1\" && node.tagName != \"H2\") {\n      return false;\n    }\n    var heading = this._getInnerText(node, false);\n    this.log(\"Evaluating similarity of header:\", heading, this._articleTitle);\n    return this._textSimilarity(this._articleTitle, heading) > 0.75;\n  },\n\n  _flagIsActive: function(flag) {\n    return (this._flags & flag) > 0;\n  },\n\n  _removeFlag: function(flag) {\n    this._flags = this._flags & ~flag;\n  },\n\n  _isProbablyVisible: function(node) {\n    // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.\n    return (!node.style || node.style.display != \"none\")\n      && (!node.style || node.style.visibility != \"hidden\")\n      && !node.hasAttribute(\"hidden\")\n      //check for \"fallback-image\" so that wikimedia math images are displayed\n      && (!node.hasAttribute(\"aria-hidden\") || node.getAttribute(\"aria-hidden\") != \"true\" || (node.className && node.className.indexOf && node.className.indexOf(\"fallback-image\") !== -1));\n  },\n\n  /**\n   * Runs readability.\n   *\n   * Workflow:\n   *  1. Prep the document by removing script tags, css, etc.\n   *  2. Build readability's DOM tree.\n   *  3. Grab the article content from the current dom tree.\n   *  4. Replace the current DOM tree with the new one.\n   *  5. Read peacefully.\n   *\n   * @return void\n   **/\n  parse: function () {\n    // Avoid parsing too large documents, as per configuration option\n    if (this._maxElemsToParse > 0) {\n      var numTags = this._doc.getElementsByTagName(\"*\").length;\n      if (numTags > this._maxElemsToParse) {\n        throw new Error(\"Aborting parsing document; \" + numTags + \" elements found\");\n      }\n    }\n\n    // Unwrap image from noscript\n    this._unwrapNoscriptImages(this._doc);\n\n    // Extract JSON-LD metadata before removing scripts\n    var jsonLd = this._disableJSONLD ? {} : this._getJSONLD(this._doc);\n\n    // Remove script tags from the document.\n    this._removeScripts(this._doc);\n\n    this._prepDocument();\n\n    var metadata = this._getArticleMetadata(jsonLd);\n    this._articleTitle = metadata.title;\n\n    var articleContent = this._grabArticle();\n    if (!articleContent)\n      return null;\n\n    this.log(\"Grabbed: \" + articleContent.innerHTML);\n\n    this._postProcessContent(articleContent);\n\n    // If we haven't found an excerpt in the article's metadata, use the article's\n    // first paragraph as the excerpt. This is used for displaying a preview of\n    // the article's content.\n    if (!metadata.excerpt) {\n      var paragraphs = articleContent.getElementsByTagName(\"p\");\n      if (paragraphs.length > 0) {\n        metadata.excerpt = paragraphs[0].textContent.trim();\n      }\n    }\n\n    var textContent = articleContent.textContent;\n    return {\n      title: this._articleTitle,\n      byline: metadata.byline || this._articleByline,\n      dir: this._articleDir,\n      lang: this._articleLang,\n      content: this._serializer(articleContent),\n      textContent: textContent,\n      length: textContent.length,\n      excerpt: metadata.excerpt,\n      siteName: metadata.siteName || this._articleSiteName,\n      publishedTime: metadata.publishedTime\n    };\n  }\n};\n\nif (typeof module === \"object\") {\n  /* global module */\n  module.exports = Readability;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}