{"ast":null,"code":"import pRetry from \"p-retry\";\nimport { CallbackManager } from \"../callbacks/manager.js\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch } from \"../tracers/log_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup } from \"../utils/stream.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter } from \"./utils.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) &&\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  !(value instanceof Date) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  getName(suffix) {\n    var _ref, _this$name;\n    const name = // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (_ref = (_this$name = this.name) !== null && _this$name !== void 0 ? _this$name : this.constructor.lc_name()) !== null && _ref !== void 0 ? _ref : this.constructor.name;\n    return suffix ? \"\".concat(name).concat(suffix) : name;\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs,\n      config: {}\n    });\n  }\n  /**\n   * Return a new Runnable that maps a list of inputs to a list of outputs,\n   * by calling invoke() with each input.\n   */\n  map() {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableEach({\n      bound: this\n    });\n  }\n  /**\n   * Add retry logic to an existing runnable.\n   * @param kwargs\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields === null || fields === void 0 ? void 0 : fields.stopAfterAttempt,\n      ...fields\n    });\n  }\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {}\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks: fields.fallbacks\n    });\n  }\n  _getOptionsList(options) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (Array.isArray(options)) {\n      if (options.length !== length) {\n        throw new Error(\"Passed \\\"options\\\" must be an array with the same length as the inputs, but got \".concat(options.length, \" options for \").concat(length, \" inputs\"));\n      }\n      return options.map(ensureConfig);\n    }\n    return Array.from({\n      length\n    }, () => ensureConfig(options));\n  }\n  async batch(inputs, options, batchOptions) {\n    var _configList$0$maxConc, _configList$;\n    const configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const maxConcurrency = (_configList$0$maxConc = (_configList$ = configList[0]) === null || _configList$ === void 0 ? void 0 : _configList$.maxConcurrency) !== null && _configList$0$maxConc !== void 0 ? _configList$0$maxConc : batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: e => {\n        throw e;\n      }\n    });\n    const batchCalls = inputs.map((input, i) => caller.call(async () => {\n      try {\n        const result = await this.invoke(input, configList[i]);\n        return result;\n      } catch (e) {\n        if (batchOptions !== null && batchOptions !== void 0 && batchOptions.returnExceptions) {\n          return e;\n        }\n        throw e;\n      }\n    }));\n    return Promise.all(batchCalls);\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this._streamIterator(input, options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n  _separateRunnableConfigFromCallOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const runnableConfig = ensureConfig({\n      callbacks: options.callbacks,\n      tags: options.tags,\n      metadata: options.metadata,\n      runName: options.runName,\n      configurable: options.configurable,\n      recursionLimit: options.recursionLimit,\n      maxConcurrency: options.maxConcurrency\n    });\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    var _config$runName;\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, config === null || config === void 0 ? void 0 : config.runType, undefined, undefined, (_config$runName = config === null || config === void 0 ? void 0 : config.runName) !== null && _config$runName !== void 0 ? _config$runName : this.getName()));\n    let output;\n    try {\n      output = await func.call(this, input, config, runManager);\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, \"output\")));\n    return output;\n  }\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig(func, inputs, options, batchOptions) {\n    const optionsList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => {\n      var _optionsList$i$runNam;\n      return callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, optionsList[i].runType, undefined, undefined, (_optionsList$i$runNam = optionsList[i].runName) !== null && _optionsList$i$runNam !== void 0 ? _optionsList$i$runNam : this.getName());\n    }));\n    let outputs;\n    try {\n      outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n    return outputs;\n  }\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n    var _runManager3, _finalOutput;\n    let finalInput;\n    let finalInputSupported = true;\n    let finalOutput;\n    let finalOutputSupported = true;\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalInput = concat(finalInput, chunk);\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n    let runManager;\n    try {\n      var _runManager;\n      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => {\n        var _config$runName2;\n        return callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {\n          input: \"\"\n        }, undefined, config === null || config === void 0 ? void 0 : config.runType, undefined, undefined, (_config$runName2 = config === null || config === void 0 ? void 0 : config.runName) !== null && _config$runName2 !== void 0 ? _config$runName2 : this.getName());\n      }, config);\n      runManager = pipe.setup;\n      const isLogStreamHandler = handler => handler.name === \"log_stream_tracer\";\n      const streamLogHandler = (_runManager = runManager) === null || _runManager === void 0 ? void 0 : _runManager.handlers.find(isLogStreamHandler);\n      let iterator = pipe.output;\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = await streamLogHandler.tapOutputIterable(runManager.runId, pipe.output);\n      }\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      var _runManager2;\n      await ((_runManager2 = runManager) === null || _runManager2 === void 0 ? void 0 : _runManager2.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\")\n      }));\n      throw e;\n    }\n    await ((_runManager3 = runManager) === null || _runManager3 === void 0 ? void 0 : _runManager3.handleChainEnd((_finalOutput = finalOutput) !== null && _finalOutput !== void 0 ? _finalOutput : {}, undefined, undefined, undefined, {\n      inputs: _coerceToDict(finalInput, \"input\")\n    }));\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys));\n  }\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(mapping) {\n    return this.pipe(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableAssign(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableMap({\n      steps: mapping\n    })));\n  }\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(generator, options) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = concat(finalChunk, chunk);\n      }\n    }\n    yield* this._streamIterator(finalChunk, options);\n  }\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(input, options, streamOptions) {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\"\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n  async *_streamLog(input, logStreamCallbackHandler, config) {\n    const {\n      callbacks\n    } = config;\n    if (callbacks === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: \"/streamed_output/-\",\n              value: chunk\n            }]\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n  /**\n   * Generate a stream of events emitted by the internal steps of the runnable.\n   *\n   * Use to create an iterator over StreamEvents that provide real-time information\n   * about the progress of the runnable, including StreamEvents from intermediate\n   * results.\n   *\n   * A StreamEvent is a dictionary with the following schema:\n   *\n   * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n   * - `name`: string - The name of the runnable that generated the event.\n   * - `run_id`: string - Randomly generated ID associated with the given execution of\n   *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n   *   parent runnable is assigned its own unique ID.\n   * - `tags`: string[] - The tags of the runnable that generated the event.\n   * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n   * - `data`: Record<string, any>\n   *\n   * Below is a table that illustrates some events that might be emitted by various\n   * chains. Metadata fields have been omitted from the table for brevity.\n   * Chain definitions have been included after the table.\n   *\n   * | event                | name             | chunk                              | input                                         | output                                          |\n   * |----------------------|------------------|------------------------------------|-----------------------------------------------|-------------------------------------------------|\n   * | on_llm_start         | [model name]     |                                    | {'input': 'hello'}                            |                                                 |\n   * | on_llm_stream        | [model name]     | 'Hello' OR AIMessageChunk(\"hello\") |                                               |                                                 |\n   * | on_llm_end           | [model name]     |                                    | 'Hello human!'                                |\n   * | on_chain_start       | format_docs      |                                    |                                               |                                                 |\n   * | on_chain_stream      | format_docs      | \"hello world!, goodbye world!\"     |                                               |                                                 |\n   * | on_chain_end         | format_docs      |                                    | [Document(...)]                               | \"hello world!, goodbye world!\"                  |\n   * | on_tool_start        | some_tool        |                                    | {\"x\": 1, \"y\": \"2\"}                            |                                                 |\n   * | on_tool_stream       | some_tool        |   {\"x\": 1, \"y\": \"2\"}               |                                               |                                                 |\n   * | on_tool_end          | some_tool        |                                    |                                               | {\"x\": 1, \"y\": \"2\"}                              |\n   * | on_retriever_start   | [retriever name] |                                    | {\"query\": \"hello\"}                            |                                                 |\n   * | on_retriever_chunk   | [retriever name] |  {documents: [...]}                |                                               |                                                 |\n   * | on_retriever_end     | [retriever name] |                                    | {\"query\": \"hello\"}                            | {documents: [...]}                              |\n   * | on_prompt_start      | [template_name]  |                                    | {\"question\": \"hello\"}                         |                                                 |\n   * | on_prompt_end        | [template_name]  |                                    | {\"question\": \"hello\"}                         | ChatPromptValue(messages: [SystemMessage, ...]) |\n   */\n  async *streamEvents(input, options, streamOptions) {\n    var _config$tags, _config$metadata, _config$runName3, _runLog;\n    if (options.version !== \"v1\") {\n      throw new Error(\"Only version \\\"v1\\\" of the events schema is currently supported.\");\n    }\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = (_config$tags = config.tags) !== null && _config$tags !== void 0 ? _config$tags : [];\n    const rootMetadata = (_config$metadata = config.metadata) !== null && _config$metadata !== void 0 ? _config$metadata : {};\n    const rootName = (_config$runName3 = config.runName) !== null && _config$runName3 !== void 0 ? _config$runName3 : this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\"\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(\"Internal error: \\\"streamEvents\\\" state is missing. Please open a bug report.\");\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = {\n          ...runLog.state\n        };\n        const event = {\n          run_id: state.id,\n          event: \"on_\".concat(state.type, \"_start\"),\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input\n          }\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops.filter(op => op.path.startsWith(\"/logs/\")).map(op => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(\"Expected exactly one chunk of streamed output, got \".concat(chunkCount, \" instead. Encountered in: \\\"\").concat(logEntry.name, \"\\\"\"));\n          }\n          data = {\n            chunk: logEntry.streamed_output[0]\n          };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: \"on_\".concat(logEntry.type, \"_\").concat(eventType),\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const {\n        state\n      } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(\"Expected exactly one chunk of streamed output, got \".concat(chunkCount, \" instead. Encountered in: \\\"\").concat(state.name, \"\\\"\"));\n        }\n        const data = {\n          chunk: state.streamed_output[0]\n        };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: \"on_\".concat(state.type, \"_stream\"),\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = (_runLog = runLog) === null || _runLog === void 0 ? void 0 : _runLog.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: \"on_\".concat(state.type, \"_end\"),\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output\n        }\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return thing ? thing.lc_runnable : false;\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners(_ref2) {\n    let {\n      onStart,\n      onEnd,\n      onError\n    } = _ref2;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config: {},\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"config\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"configFactories\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n  getName(suffix) {\n    return this.bound.getName(suffix);\n  }\n  async _mergeConfig() {\n    for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {\n      options[_key] = arguments[_key];\n    }\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(config, ...(this.configFactories ? await Promise.all(this.configFactories.map(async configFactory => await configFactory(config))) : []));\n  }\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      },\n      config: this.config\n    });\n  }\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: {\n        ...this.config,\n        ...config\n      }\n    });\n  }\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new this.constructor({\n      bound: this.bound.withRetry(fields),\n      kwargs: this.kwargs,\n      config: this.config\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, await this._mergeConfig(options, this.kwargs));\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async individualOption => this._mergeConfig(individualOption, this.kwargs))) : await this._mergeConfig(options, this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async *_streamIterator(input, options) {\n    yield* this.bound._streamIterator(input, await this._mergeConfig(options, this.kwargs));\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, await this._mergeConfig(options, this.kwargs));\n  }\n  async *transform(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  generator, options) {\n    yield* this.bound.transform(generator, await this._mergeConfig(options, this.kwargs));\n  }\n  async *streamEvents(input, options, streamOptions) {\n    yield* this.bound.streamEvents(input, {\n      ...(await this._mergeConfig(options, this.kwargs)),\n      version: options.version\n    }, streamOptions);\n  }\n  static isRunnableBinding(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thing\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners(_ref3) {\n    let {\n      onStart,\n      onEnd,\n      onError\n    } = _ref3;\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nexport class RunnableEach extends Runnable {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n   */\n  bind(kwargs) {\n    return new RunnableEach({\n      bound: this.bound.bind(kwargs)\n    });\n  }\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(inputs, config) {\n    return this._callWithConfig(this._invoke, inputs, config);\n  }\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async _invoke(inputs, config, runManager) {\n    return this.bound.batch(inputs, patchConfig(config, {\n      callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()\n    }));\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners(_ref4) {\n    let {\n      onStart,\n      onEnd,\n      onError\n    } = _ref4;\n    return new RunnableEach({\n      bound: this.bound.withListeners({\n        onStart,\n        onEnd,\n        onError\n      })\n    });\n  }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nexport class RunnableRetry extends RunnableBinding {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n  constructor(fields) {\n    var _fields$maxAttemptNum, _fields$onFailedAttem;\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"maxAttemptNumber\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"onFailedAttempt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: () => {}\n    });\n    this.maxAttemptNumber = (_fields$maxAttemptNum = fields.maxAttemptNumber) !== null && _fields$maxAttemptNum !== void 0 ? _fields$maxAttemptNum : this.maxAttemptNumber;\n    this.onFailedAttempt = (_fields$onFailedAttem = fields.onFailedAttempt) !== null && _fields$onFailedAttem !== void 0 ? _fields$onFailedAttem : this.onFailedAttempt;\n  }\n  _patchConfigForRetry(attempt, config, runManager) {\n    const tag = attempt > 1 ? \"retry:attempt:\".concat(attempt) : undefined;\n    return patchConfig(config, {\n      callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(tag)\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return pRetry(attemptNumber => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n      onFailedAttempt: this.onFailedAttempt,\n      retries: Math.max(this.maxAttemptNumber - 1, 0),\n      randomize: true\n    });\n  }\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input, config) {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n  async _batch(inputs, configs, runManagers, batchOptions) {\n    const resultsMap = {};\n    try {\n      await pRetry(async attemptNumber => {\n        const remainingIndexes = inputs.map((_, i) => i).filter(i => resultsMap[i.toString()] === undefined ||\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        resultsMap[i.toString()] instanceof Error);\n        const remainingInputs = remainingIndexes.map(i => inputs[i]);\n        const patchedConfigs = remainingIndexes.map(i => this._patchConfigForRetry(attemptNumber, configs === null || configs === void 0 ? void 0 : configs[i], runManagers === null || runManagers === void 0 ? void 0 : runManagers[i]));\n        const results = await super.batch(remainingInputs, patchedConfigs, {\n          ...batchOptions,\n          returnExceptions: true\n        });\n        let firstException;\n        for (let i = 0; i < results.length; i += 1) {\n          const result = results[i];\n          const resultMapIndex = remainingIndexes[i];\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (result instanceof Error) {\n            if (firstException === undefined) {\n              firstException = result;\n            }\n          }\n          resultsMap[resultMapIndex.toString()] = result;\n        }\n        if (firstException) {\n          throw firstException;\n        }\n        return results;\n      }, {\n        onFailedAttempt: this.onFailedAttempt,\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true\n      });\n    } catch (e) {\n      if ((batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.returnExceptions) !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map(key => resultsMap[parseInt(key, 10)]);\n  }\n  async batch(inputs, options, batchOptions) {\n    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    var _fields$middle;\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    this.first = fields.first;\n    this.middle = (_fields$middle = fields.middle) !== null && _fields$middle !== void 0 ? _fields$middle : this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options === null || options === void 0 ? void 0 : options.runName));\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        nextStepInput = await step.invoke(nextStepInput, patchConfig(options, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"seq:step:\".concat(i + 1))\n        }));\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      finalOutput = await this.last.invoke(nextStepInput, patchConfig(options, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"seq:step:\".concat(this.steps.length))\n      }));\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, \"output\")));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n          const childRunManager = runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"seq:step:\".concat(i + 1));\n          return patchConfig(configList[j], {\n            callbacks: childRunManager\n          });\n        }), batchOptions);\n      }\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n    return nextStepInputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options === null || options === void 0 ? void 0 : options.runName));\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(options, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"seq:step:1\")\n      }));\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(finalGenerator, patchConfig(options, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"seq:step:\".concat(i + 1))\n        }));\n      }\n      for await (const chunk of finalGenerator) {\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = concat(finalOutput, chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, \"output\")));\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      var _this$name2;\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last,\n        name: (_this$name2 = this.name) !== null && _this$name2 !== void 0 ? _this$name2 : coerceable.name\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from(_ref5, name) {\n    let [first, ...runnables] = _ref5;\n    return new RunnableSequence({\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1]),\n      name\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  getStepsKeys() {\n    return Object.keys(this.steps);\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  static from(steps) {\n    return new RunnableMap({\n      steps\n    });\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {\n      input\n    }, undefined, undefined, undefined, undefined, options === null || options === void 0 ? void 0 : options.runName));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      await Promise.all(Object.entries(this.steps).map(async _ref6 => {\n        let [key, runnable] = _ref6;\n        output[key] = await runnable.invoke(input, patchConfig(options, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"map:key:\".concat(key))\n        }));\n      }));\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(output));\n    return output;\n  }\n  async *_transform(generator, runManager, options) {\n    // shallow copy steps to ignore changes while iterating\n    const steps = {\n      ...this.steps\n    };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(Object.entries(steps).map((_ref7, i) => {\n      let [key, runnable] = _ref7;\n      const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"map:key:\".concat(key))\n      }));\n      return [key, gen.next().then(result => ({\n        key,\n        gen,\n        result\n      }))];\n    }));\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const {\n        key,\n        result,\n        gen\n      } = await Promise.race(tasks.values());\n      tasks.delete(key);\n      if (!result.done) {\n        yield {\n          [key]: result.value\n        };\n        tasks.set(key, gen.next().then(result => ({\n          key,\n          gen,\n          result\n        })));\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.func = fields.func;\n  }\n  static from(func) {\n    return new RunnableLambda({\n      func\n    });\n  }\n  async _invoke(input, config, runManager) {\n    let output = await this.func(input, {\n      ...config,\n      config\n    });\n    if (output && Runnable.isRunnable(output)) {\n      var _config$recursionLimi;\n      if ((config === null || config === void 0 ? void 0 : config.recursionLimit) === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      output = await output.invoke(input, patchConfig(config, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(),\n        recursionLimit: ((_config$recursionLimi = config === null || config === void 0 ? void 0 : config.recursionLimit) !== null && _config$recursionLimi !== void 0 ? _config$recursionLimi : DEFAULT_RECURSION_LIMIT) - 1\n      }));\n    }\n    return output;\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._invoke, input, options);\n  }\n  async *_transform(generator, runManager, config) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = concat(finalChunk, chunk);\n        } catch (e) {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const output = await this.func(finalChunk, {\n      ...config,\n      config\n    });\n    if (output && Runnable.isRunnable(output)) {\n      var _config$recursionLimi2;\n      if ((config === null || config === void 0 ? void 0 : config.recursionLimit) === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk, patchConfig(config, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(),\n        recursionLimit: ((_config$recursionLimi2 = config === null || config === void 0 ? void 0 : config.recursionLimit) !== null && _config$recursionLimi2 !== void 0 ? _config$recursionLimi2 : DEFAULT_RECURSION_LIMIT) - 1\n      }));\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else {\n      yield output;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\nexport class RunnableParallel extends RunnableMap {}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options === null || options === void 0 ? void 0 : options.runName));\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const output = await runnable.invoke(input, patchConfig(options, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()\n        }));\n        await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, \"output\")));\n        return output;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (firstError === undefined) {\n      throw new Error(\"No error stored at end of fallback.\");\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(firstError));\n    throw firstError;\n  }\n  async batch(inputs, options, batchOptions) {\n    if (batchOptions !== null && batchOptions !== void 0 && batchOptions.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config === null || config === void 0 ? void 0 : config.callbacks, undefined, config === null || config === void 0 ? void 0 : config.tags, undefined, config === null || config === void 0 ? void 0 : config.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()\n        })), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(firstError)));\n    throw firstError;\n  }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(\"Expected a Runnable, function or object.\\nInstead got an unsupported type.\");\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnableAssign extends Runnable {\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n  constructor(fields) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        mapper: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"mapper\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.mapper = fields.mapper;\n  }\n  async invoke(input, options) {\n    const mapperResult = await this.mapper.invoke(input, options);\n    return {\n      ...input,\n      ...mapperResult\n    };\n  }\n  async *_transform(generator, runManager, options) {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {\n      callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild()\n    }));\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(\"RunnableAssign can only be used with objects as input, got \".concat(typeof chunk));\n      }\n      const filtered = Object.fromEntries(Object.entries(chunk).filter(_ref8 => {\n        let [key] = _ref8;\n        return !mapperKeys.includes(key);\n      }));\n      if (Object.keys(filtered).length > 0) {\n        yield filtered;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnablePick extends Runnable {\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n  constructor(fields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        keys: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"keys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keys = fields.keys;\n  }\n  async _pick(input) {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys.map(key => [key, input[key]]).filter(v => v[1] !== undefined);\n      return picked.length === 0 ? undefined : Object.fromEntries(picked);\n    }\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n  async *_transform(generator) {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}","map":{"version":3,"names":["pRetry","CallbackManager","LogStreamCallbackHandler","RunLog","RunLogPatch","Serializable","IterableReadableStream","concat","atee","pipeGeneratorWithSetup","AsyncGeneratorWithSetup","DEFAULT_RECURSION_LIMIT","ensureConfig","getCallbackManagerForConfig","mergeConfigs","patchConfig","AsyncCaller","RootListenersTracer","_RootEventFilter","_coerceToDict","value","defaultKey","Array","isArray","Date","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","getName","suffix","_ref","_this$name","name","lc_name","bind","kwargs","RunnableBinding","bound","config","map","RunnableEach","withRetry","fields","RunnableRetry","maxAttemptNumber","stopAfterAttempt","withConfig","withFallbacks","RunnableWithFallbacks","runnable","fallbacks","_getOptionsList","options","length","undefined","Error","from","batch","inputs","batchOptions","_configList$0$maxConc","_configList$","configList","maxConcurrency","caller","onFailedAttempt","e","batchCalls","input","i","call","result","invoke","returnExceptions","Promise","all","_streamIterator","stream","wrappedGenerator","setup","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","callbacks","tags","metadata","runName","recursionLimit","callOptions","_callWithConfig","func","_config$runName","callbackManager_","runManager","handleChainStart","toJSON","runType","output","handleChainError","handleChainEnd","_batchWithConfig","optionsList","callbackManagers","runManagers","callbackManager","_optionsList$i$runNam","outputs","_transformStreamWithConfig","inputGenerator","transformer","_runManager3","_finalOutput","finalInput","finalInputSupported","finalOutput","finalOutputSupported","wrapInputForTracing","chunk","_runManager","pipe","_config$runName2","isLogStreamHandler","handler","streamLogHandler","handlers","find","iterator","tapOutputIterable","runId","_runManager2","coerceable","RunnableSequence","first","last","_coerceToRunnable","pick","keys","RunnablePick","assign","mapping","RunnableAssign","RunnableMap","steps","transform","generator","finalChunk","streamLog","streamOptions","logStreamCallbackHandler","autoClose","_schemaFormat","_streamLog","copiedCallbacks","copy","inheritableHandlers","push","runnableStreamPromise","consumeRunnableStream","runnableStream","patch","ops","op","path","writer","write","close","runnableStreamConsumePromise","log","streamEvents","_config$tags","_config$metadata","_config$runName3","_runLog","version","runLog","hasEncounteredStartEvent","rootTags","rootMetadata","rootName","rootEventFilter","logStream","fromRunLogPatch","state","event","run_id","id","type","data","includeEvent","paths","filter","startsWith","split","dedupedPaths","Set","eventType","logEntry","logs","end_time","streamed_output","final_output","chunkCount","isRunnable","thing","lc_runnable","withListeners","_ref2","onStart","onEnd","onError","configFactories","_mergeConfig","_len","_key","configFactory","mergedOptions","individualOption","isRunnableBinding","_ref3","_invoke","getChild","_ref4","_fields$maxAttemptNum","_fields$onFailedAttem","_patchConfigForRetry","attempt","tag","attemptNumber","retries","Math","max","randomize","_batch","configs","resultsMap","remainingIndexes","_","toString","remainingInputs","patchedConfigs","results","firstException","resultMapIndex","sort","a","b","parseInt","key","_fields$middle","middle","nextStepInput","initialSteps","step","nextStepInputs","j","childRunManager","concatSupported","finalGenerator","isRunnableSequence","_this$name2","_ref5","runnables","slice","getStepsKeys","entries","_ref6","_transform","inputCopies","tasks","Map","_ref7","gen","next","then","size","race","values","delete","done","set","RunnableLambda","_config$recursionLimi","_config$recursionLimi2","RunnableParallel","fallback","configure","firstError","mapper","mapperResult","mapperKeys","forPassthrough","forMapper","mapperOutput","firstMapperChunkPromise","filtered","fromEntries","_ref8","includes","_pick","picked","v"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/base.js"],"sourcesContent":["import pRetry from \"p-retry\";\nimport { CallbackManager, } from \"../callbacks/manager.js\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, } from \"../tracers/log_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup, } from \"../utils/stream.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter } from \"./utils.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param kwargs\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options)) {\n            if (options.length !== length) {\n                throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n            }\n            return options.map(ensureConfig);\n        }\n        return Array.from({ length }, () => ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this._streamIterator(input, options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options = {}) {\n        const runnableConfig = ensureConfig({\n            callbacks: options.callbacks,\n            tags: options.tags,\n            metadata: options.metadata,\n            runName: options.runName,\n            configurable: options.configurable,\n            recursionLimit: options.recursionLimit,\n            maxConcurrency: options.maxConcurrency,\n        });\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        let output;\n        try {\n            output = await func.call(this, input, config, runManager);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName())));\n        let outputs;\n        try {\n            outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalInput = concat(finalInput, chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, undefined, config?.runType, undefined, undefined, config?.runName ?? this.getName()), config);\n            runManager = pipe.setup;\n            const isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\n            const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n            let iterator = pipe.output;\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = await streamLogHandler.tapOutputIterable(runManager.runId, pipe.output);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = concat(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, options);\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = ensureConfig(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    /**\n     * Generate a stream of events emitted by the internal steps of the runnable.\n     *\n     * Use to create an iterator over StreamEvents that provide real-time information\n     * about the progress of the runnable, including StreamEvents from intermediate\n     * results.\n     *\n     * A StreamEvent is a dictionary with the following schema:\n     *\n     * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n     * - `name`: string - The name of the runnable that generated the event.\n     * - `run_id`: string - Randomly generated ID associated with the given execution of\n     *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n     *   parent runnable is assigned its own unique ID.\n     * - `tags`: string[] - The tags of the runnable that generated the event.\n     * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n     * - `data`: Record<string, any>\n     *\n     * Below is a table that illustrates some events that might be emitted by various\n     * chains. Metadata fields have been omitted from the table for brevity.\n     * Chain definitions have been included after the table.\n     *\n     * | event                | name             | chunk                              | input                                         | output                                          |\n     * |----------------------|------------------|------------------------------------|-----------------------------------------------|-------------------------------------------------|\n     * | on_llm_start         | [model name]     |                                    | {'input': 'hello'}                            |                                                 |\n     * | on_llm_stream        | [model name]     | 'Hello' OR AIMessageChunk(\"hello\") |                                               |                                                 |\n     * | on_llm_end           | [model name]     |                                    | 'Hello human!'                                |\n     * | on_chain_start       | format_docs      |                                    |                                               |                                                 |\n     * | on_chain_stream      | format_docs      | \"hello world!, goodbye world!\"     |                                               |                                                 |\n     * | on_chain_end         | format_docs      |                                    | [Document(...)]                               | \"hello world!, goodbye world!\"                  |\n     * | on_tool_start        | some_tool        |                                    | {\"x\": 1, \"y\": \"2\"}                            |                                                 |\n     * | on_tool_stream       | some_tool        |   {\"x\": 1, \"y\": \"2\"}               |                                               |                                                 |\n     * | on_tool_end          | some_tool        |                                    |                                               | {\"x\": 1, \"y\": \"2\"}                              |\n     * | on_retriever_start   | [retriever name] |                                    | {\"query\": \"hello\"}                            |                                                 |\n     * | on_retriever_chunk   | [retriever name] |  {documents: [...]}                |                                               |                                                 |\n     * | on_retriever_end     | [retriever name] |                                    | {\"query\": \"hello\"}                            | {documents: [...]}                              |\n     * | on_prompt_start      | [template_name]  |                                    | {\"question\": \"hello\"}                         |                                                 |\n     * | on_prompt_end        | [template_name]  |                                    | {\"question\": \"hello\"}                         | ChatPromptValue(messages: [SystemMessage, ...]) |\n     */\n    async *streamEvents(input, options, streamOptions) {\n        if (options.version !== \"v1\") {\n            throw new Error(`Only version \"v1\" of the events schema is currently supported.`);\n        }\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = ensureConfig(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return thing ? thing.lc_runnable : false;\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = mergeConfigs(this.config, ...options);\n        return mergeConfigs(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return new this.constructor({\n            bound: this.bound.withRetry(fields),\n            kwargs: this.kwargs,\n            config: this.config,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig(options, this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(individualOption, this.kwargs)))\n            : await this._mergeConfig(options, this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig(options, this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig(options, this.kwargs));\n    }\n    async *transform(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig(options, this.kwargs));\n    }\n    async *streamEvents(input, options, streamOptions) {\n        yield* this.bound.streamEvents(input, {\n            ...(await this._mergeConfig(options, this.kwargs)),\n            version: options.version,\n        }, streamOptions);\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n */\nexport class RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke, inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n */\nexport class RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            onFailedAttempt: this.onFailedAttempt,\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await pRetry(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                onFailedAttempt: this.onFailedAttempt,\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({})]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                nextStepInput = await step.invoke(nextStepInput, patchConfig(options, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, patchConfig(options, {\n                callbacks: runManager?.getChild(`seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(`seq:step:${i + 1}`);\n                    return patchConfig(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(options, {\n                callbacks: runManager?.getChild(`seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, patchConfig(options, {\n                    callbacks: runManager?.getChild(`seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = concat(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], name) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n            name,\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, undefined, undefined, undefined, undefined, options?.runName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, patchConfig(options, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = atee(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const { key, result, gen } = await Promise.race(tasks.values());\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let output = await this.func(input, { ...config, config });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            output = await output.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            }));\n        }\n        return output;\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke, input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = concat(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const output = await this.func(finalChunk, { ...config, config });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            }));\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexport class RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, options?.runName);\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, patchConfig(options, { callbacks: runManager?.getChild() }));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), undefined, undefined, undefined, undefined, configList[i].runName)));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = atee(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n */\nexport class RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0 ? undefined : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,SAAS;AAC5B,SAASC,eAAe,QAAS,yBAAyB;AAC1D,SAASC,wBAAwB,EAAEC,MAAM,EAAEC,WAAW,QAAS,0BAA0B;AACzF,SAASC,YAAY,QAAQ,yBAAyB;AACtD,SAASC,sBAAsB,EAAEC,MAAM,EAAEC,IAAI,EAAEC,sBAAsB,EAAEC,uBAAuB,QAAS,oBAAoB;AAC3H,SAASC,uBAAuB,EAAEC,YAAY,EAAEC,2BAA2B,EAAEC,YAAY,EAAEC,WAAW,QAAS,aAAa;AAC5H,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,mBAAmB,QAAQ,6BAA6B;AACjE,SAASC,gBAAgB,QAAQ,YAAY;AAC7C;AACA,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,UAAU,EAAE;EAC7C,OAAOD,KAAK,IACR,CAACE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC;EACrB;EACA,EAAEA,KAAK,YAAYI,IAAI,CAAC,IACxB,OAAOJ,KAAK,KAAK,QAAQ,GACvBA,KAAK,GACL;IAAE,CAACC,UAAU,GAAGD;EAAM,CAAC;AACjC;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,QAAQ,SAASpB,YAAY,CAAC;EACvCqB,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnBC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE;MACvCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;MAChCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;EACN;EACAa,OAAOA,CAACC,MAAM,EAAE;IAAA,IAAAC,IAAA,EAAAC,UAAA;IACZ,MAAMC,IAAI,GACV;IAAA,CAAAF,IAAA,IAAAC,UAAA,GACA,IAAI,CAACC,IAAI,cAAAD,UAAA,cAAAA,UAAA,GAAI,IAAI,CAACV,WAAW,CAACY,OAAO,CAAC,CAAC,cAAAH,IAAA,cAAAA,IAAA,GAAI,IAAI,CAACT,WAAW,CAACW,IAAI;IAChE,OAAOH,MAAM,MAAA3B,MAAA,CAAM8B,IAAI,EAAA9B,MAAA,CAAG2B,MAAM,IAAKG,IAAI;EAC7C;EACA;AACJ;AACA;AACA;AACA;EACIE,IAAIA,CAACC,MAAM,EAAE;IACT;IACA,OAAO,IAAIC,eAAe,CAAC;MAAEC,KAAK,EAAE,IAAI;MAAEF,MAAM;MAAEG,MAAM,EAAE,CAAC;IAAE,CAAC,CAAC;EACnE;EACA;AACJ;AACA;AACA;EACIC,GAAGA,CAAA,EAAG;IACF;IACA,OAAO,IAAIC,YAAY,CAAC;MAAEH,KAAK,EAAE;IAAK,CAAC,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;EACII,SAASA,CAACC,MAAM,EAAE;IACd;IACA,OAAO,IAAIC,aAAa,CAAC;MACrBN,KAAK,EAAE,IAAI;MACXF,MAAM,EAAE,CAAC,CAAC;MACVG,MAAM,EAAE,CAAC,CAAC;MACVM,gBAAgB,EAAEF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEG,gBAAgB;MAC1C,GAAGH;IACP,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACII,UAAUA,CAACR,MAAM,EAAE;IACf;IACA,OAAO,IAAIF,eAAe,CAAC;MACvBC,KAAK,EAAE,IAAI;MACXC,MAAM;MACNH,MAAM,EAAE,CAAC;IACb,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;EACIY,aAAaA,CAACL,MAAM,EAAE;IAClB;IACA,OAAO,IAAIM,qBAAqB,CAAC;MAC7BC,QAAQ,EAAE,IAAI;MACdC,SAAS,EAAER,MAAM,CAACQ;IACtB,CAAC,CAAC;EACN;EACAC,eAAeA,CAACC,OAAO,EAAc;IAAA,IAAZC,MAAM,GAAA/B,SAAA,CAAA+B,MAAA,QAAA/B,SAAA,QAAAgC,SAAA,GAAAhC,SAAA,MAAG,CAAC;IAC/B,IAAIL,KAAK,CAACC,OAAO,CAACkC,OAAO,CAAC,EAAE;MACxB,IAAIA,OAAO,CAACC,MAAM,KAAKA,MAAM,EAAE;QAC3B,MAAM,IAAIE,KAAK,oFAAArD,MAAA,CAAkFkD,OAAO,CAACC,MAAM,mBAAAnD,MAAA,CAAgBmD,MAAM,YAAS,CAAC;MACnJ;MACA,OAAOD,OAAO,CAACb,GAAG,CAAChC,YAAY,CAAC;IACpC;IACA,OAAOU,KAAK,CAACuC,IAAI,CAAC;MAAEH;IAAO,CAAC,EAAE,MAAM9C,YAAY,CAAC6C,OAAO,CAAC,CAAC;EAC9D;EACA,MAAMK,KAAKA,CAACC,MAAM,EAAEN,OAAO,EAAEO,YAAY,EAAE;IAAA,IAAAC,qBAAA,EAAAC,YAAA;IACvC,MAAMC,UAAU,GAAG,IAAI,CAACX,eAAe,CAACC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,CAAC,CAAC,EAAEM,MAAM,CAACL,MAAM,CAAC;IACrE,MAAMU,cAAc,IAAAH,qBAAA,IAAAC,YAAA,GAAGC,UAAU,CAAC,CAAC,CAAC,cAAAD,YAAA,uBAAbA,YAAA,CAAeE,cAAc,cAAAH,qBAAA,cAAAA,qBAAA,GAAID,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEI,cAAc;IACpF,MAAMC,MAAM,GAAG,IAAIrD,WAAW,CAAC;MAC3BoD,cAAc;MACdE,eAAe,EAAGC,CAAC,IAAK;QACpB,MAAMA,CAAC;MACX;IACJ,CAAC,CAAC;IACF,MAAMC,UAAU,GAAGT,MAAM,CAACnB,GAAG,CAAC,CAAC6B,KAAK,EAAEC,CAAC,KAAKL,MAAM,CAACM,IAAI,CAAC,YAAY;MAChE,IAAI;QACA,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACC,MAAM,CAACJ,KAAK,EAAEN,UAAU,CAACO,CAAC,CAAC,CAAC;QACtD,OAAOE,MAAM;MACjB,CAAC,CACD,OAAOL,CAAC,EAAE;QACN,IAAIP,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEc,gBAAgB,EAAE;UAChC,OAAOP,CAAC;QACZ;QACA,MAAMA,CAAC;MACX;IACJ,CAAC,CAAC,CAAC;IACH,OAAOQ,OAAO,CAACC,GAAG,CAACR,UAAU,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOS,eAAeA,CAACR,KAAK,EAAEhB,OAAO,EAAE;IACnC,MAAM,IAAI,CAACoB,MAAM,CAACJ,KAAK,EAAEhB,OAAO,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMyB,MAAMA,CAACT,KAAK,EAAEhB,OAAO,EAAE;IACzB;IACA;IACA,MAAM0B,gBAAgB,GAAG,IAAIzE,uBAAuB,CAAC,IAAI,CAACuE,eAAe,CAACR,KAAK,EAAEhB,OAAO,CAAC,CAAC;IAC1F,MAAM0B,gBAAgB,CAACC,KAAK;IAC5B,OAAO9E,sBAAsB,CAAC+E,kBAAkB,CAACF,gBAAgB,CAAC;EACtE;EACAG,sCAAsCA,CAAA,EAAe;IAAA,IAAd7B,OAAO,GAAA9B,SAAA,CAAA+B,MAAA,QAAA/B,SAAA,QAAAgC,SAAA,GAAAhC,SAAA,MAAG,CAAC,CAAC;IAC/C,MAAM4D,cAAc,GAAG3E,YAAY,CAAC;MAChC4E,SAAS,EAAE/B,OAAO,CAAC+B,SAAS;MAC5BC,IAAI,EAAEhC,OAAO,CAACgC,IAAI;MAClBC,QAAQ,EAAEjC,OAAO,CAACiC,QAAQ;MAC1BC,OAAO,EAAElC,OAAO,CAACkC,OAAO;MACxB5D,YAAY,EAAE0B,OAAO,CAAC1B,YAAY;MAClC6D,cAAc,EAAEnC,OAAO,CAACmC,cAAc;MACtCxB,cAAc,EAAEX,OAAO,CAACW;IAC5B,CAAC,CAAC;IACF,MAAMyB,WAAW,GAAG;MAAE,GAAGpC;IAAQ,CAAC;IAClC,OAAOoC,WAAW,CAACL,SAAS;IAC5B,OAAOK,WAAW,CAACJ,IAAI;IACvB,OAAOI,WAAW,CAACH,QAAQ;IAC3B,OAAOG,WAAW,CAACF,OAAO;IAC1B,OAAOE,WAAW,CAAC9D,YAAY;IAC/B,OAAO8D,WAAW,CAACD,cAAc;IACjC,OAAOC,WAAW,CAACzB,cAAc;IACjC,OAAO,CAACmB,cAAc,EAAEM,WAAW,CAAC;EACxC;EACA,MAAMC,eAAeA,CAACC,IAAI,EAAEtB,KAAK,EAAEhB,OAAO,EAAE;IAAA,IAAAuC,eAAA;IACxC,MAAMrD,MAAM,GAAG/B,YAAY,CAAC6C,OAAO,CAAC;IACpC,MAAMwC,gBAAgB,GAAG,MAAMpF,2BAA2B,CAAC8B,MAAM,CAAC;IAClE,MAAMuD,UAAU,GAAG,OAAMD,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEE,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAACsD,KAAK,EAAE,OAAO,CAAC,EAAEd,SAAS,EAAEhB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE0D,OAAO,EAAE1C,SAAS,EAAEA,SAAS,GAAAqC,eAAA,GAAErD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEgD,OAAO,cAAAK,eAAA,cAAAA,eAAA,GAAI,IAAI,CAAC/D,OAAO,CAAC,CAAC,CAAC;IAC9L,IAAIqE,MAAM;IACV,IAAI;MACAA,MAAM,GAAG,MAAMP,IAAI,CAACpB,IAAI,CAAC,IAAI,EAAEF,KAAK,EAAE9B,MAAM,EAAEuD,UAAU,CAAC;IAC7D,CAAC,CACD,OAAO3B,CAAC,EAAE;MACN,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAChC,CAAC,CAAC;MACrC,MAAMA,CAAC;IACX;IACA,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAACmF,MAAM,EAAE,QAAQ,CAAC,CAAC;IACjE,OAAOA,MAAM;EACjB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMG,gBAAgBA,CAACV,IAAI,EAAEhC,MAAM,EAAEN,OAAO,EAAEO,YAAY,EAAE;IACxD,MAAM0C,WAAW,GAAG,IAAI,CAAClD,eAAe,CAACC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,CAAC,CAAC,EAAEM,MAAM,CAACL,MAAM,CAAC;IACtE,MAAMiD,gBAAgB,GAAG,MAAM5B,OAAO,CAACC,GAAG,CAAC0B,WAAW,CAAC9D,GAAG,CAAC/B,2BAA2B,CAAC,CAAC;IACxF,MAAM+F,WAAW,GAAG,MAAM7B,OAAO,CAACC,GAAG,CAAC2B,gBAAgB,CAAC/D,GAAG,CAAC,CAACiE,eAAe,EAAEnC,CAAC;MAAA,IAAAoC,qBAAA;MAAA,OAAKD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEV,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAAC4C,MAAM,CAACW,CAAC,CAAC,EAAE,OAAO,CAAC,EAAEf,SAAS,EAAE+C,WAAW,CAAChC,CAAC,CAAC,CAAC2B,OAAO,EAAE1C,SAAS,EAAEA,SAAS,GAAAmD,qBAAA,GAAEJ,WAAW,CAAChC,CAAC,CAAC,CAACiB,OAAO,cAAAmB,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAAC7E,OAAO,CAAC,CAAC,CAAC;IAAA,EAAC,CAAC;IAC3Q,IAAI8E,OAAO;IACX,IAAI;MACAA,OAAO,GAAG,MAAMhB,IAAI,CAACpB,IAAI,CAAC,IAAI,EAAEZ,MAAM,EAAE2C,WAAW,EAAEE,WAAW,EAAE5C,YAAY,CAAC;IACnF,CAAC,CACD,OAAOO,CAAC,EAAE;MACN,MAAMQ,OAAO,CAACC,GAAG,CAAC4B,WAAW,CAAChE,GAAG,CAAEsD,UAAU,IAAKA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAChC,CAAC,CAAC,CAAC,CAAC;MACnF,MAAMA,CAAC;IACX;IACA,MAAMQ,OAAO,CAACC,GAAG,CAAC4B,WAAW,CAAChE,GAAG,CAAEsD,UAAU,IAAKA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAAC4F,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IAChH,OAAOA,OAAO;EAClB;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOC,0BAA0BA,CAACC,cAAc,EAAEC,WAAW,EAAEzD,OAAO,EAAE;IAAA,IAAA0D,YAAA,EAAAC,YAAA;IACpE,IAAIC,UAAU;IACd,IAAIC,mBAAmB,GAAG,IAAI;IAC9B,IAAIC,WAAW;IACf,IAAIC,oBAAoB,GAAG,IAAI;IAC/B,MAAM7E,MAAM,GAAG/B,YAAY,CAAC6C,OAAO,CAAC;IACpC,MAAMwC,gBAAgB,GAAG,MAAMpF,2BAA2B,CAAC8B,MAAM,CAAC;IAClE,gBAAgB8E,mBAAmBA,CAAA,EAAG;MAClC,WAAW,MAAMC,KAAK,IAAIT,cAAc,EAAE;QACtC,IAAIK,mBAAmB,EAAE;UACrB,IAAID,UAAU,KAAK1D,SAAS,EAAE;YAC1B0D,UAAU,GAAGK,KAAK;UACtB,CAAC,MACI;YACD,IAAI;cACA;cACAL,UAAU,GAAG9G,MAAM,CAAC8G,UAAU,EAAEK,KAAK,CAAC;YAC1C,CAAC,CACD,MAAM;cACFL,UAAU,GAAG1D,SAAS;cACtB2D,mBAAmB,GAAG,KAAK;YAC/B;UACJ;QACJ;QACA,MAAMI,KAAK;MACf;IACJ;IACA,IAAIxB,UAAU;IACd,IAAI;MAAA,IAAAyB,WAAA;MACA,MAAMC,IAAI,GAAG,MAAMnH,sBAAsB,CAACyG,WAAW,CAAC3E,IAAI,CAAC,IAAI,CAAC,EAAEkF,mBAAmB,CAAC,CAAC,EAAE;QAAA,IAAAI,gBAAA;QAAA,OAAY5B,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEE,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE;UAAE3B,KAAK,EAAE;QAAG,CAAC,EAAEd,SAAS,EAAEhB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE0D,OAAO,EAAE1C,SAAS,EAAEA,SAAS,GAAAkE,gBAAA,GAAElF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEgD,OAAO,cAAAkC,gBAAA,cAAAA,gBAAA,GAAI,IAAI,CAAC5F,OAAO,CAAC,CAAC,CAAC;MAAA,GAAEU,MAAM,CAAC;MACnQuD,UAAU,GAAG0B,IAAI,CAACxC,KAAK;MACvB,MAAM0C,kBAAkB,GAAIC,OAAO,IAAKA,OAAO,CAAC1F,IAAI,KAAK,mBAAmB;MAC5E,MAAM2F,gBAAgB,IAAAL,WAAA,GAAGzB,UAAU,cAAAyB,WAAA,uBAAVA,WAAA,CAAYM,QAAQ,CAACC,IAAI,CAACJ,kBAAkB,CAAC;MACtE,IAAIK,QAAQ,GAAGP,IAAI,CAACtB,MAAM;MAC1B,IAAI0B,gBAAgB,KAAKrE,SAAS,IAAIuC,UAAU,KAAKvC,SAAS,EAAE;QAC5DwE,QAAQ,GAAG,MAAMH,gBAAgB,CAACI,iBAAiB,CAAClC,UAAU,CAACmC,KAAK,EAAET,IAAI,CAACtB,MAAM,CAAC;MACtF;MACA,WAAW,MAAMoB,KAAK,IAAIS,QAAQ,EAAE;QAChC,MAAMT,KAAK;QACX,IAAIF,oBAAoB,EAAE;UACtB,IAAID,WAAW,KAAK5D,SAAS,EAAE;YAC3B4D,WAAW,GAAGG,KAAK;UACvB,CAAC,MACI;YACD,IAAI;cACA;cACAH,WAAW,GAAGhH,MAAM,CAACgH,WAAW,EAAEG,KAAK,CAAC;YAC5C,CAAC,CACD,MAAM;cACFH,WAAW,GAAG5D,SAAS;cACvB6D,oBAAoB,GAAG,KAAK;YAChC;UACJ;QACJ;MACJ;IACJ,CAAC,CACD,OAAOjD,CAAC,EAAE;MAAA,IAAA+D,YAAA;MACN,QAAAA,YAAA,GAAMpC,UAAU,cAAAoC,YAAA,uBAAVA,YAAA,CAAY/B,gBAAgB,CAAChC,CAAC,EAAEZ,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE;QACnEI,MAAM,EAAE5C,aAAa,CAACkG,UAAU,EAAE,OAAO;MAC7C,CAAC,CAAC;MACF,MAAM9C,CAAC;IACX;IACA,QAAA4C,YAAA,GAAMjB,UAAU,cAAAiB,YAAA,uBAAVA,YAAA,CAAYX,cAAc,EAAAY,YAAA,GAACG,WAAW,cAAAH,YAAA,cAAAA,YAAA,GAAI,CAAC,CAAC,EAAEzD,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE;MAAEI,MAAM,EAAE5C,aAAa,CAACkG,UAAU,EAAE,OAAO;IAAE,CAAC,CAAC;EACxI;EACA;AACJ;AACA;AACA;AACA;AACA;EACIO,IAAIA,CAACW,UAAU,EAAE;IACb;IACA,OAAO,IAAIC,gBAAgB,CAAC;MACxBC,KAAK,EAAE,IAAI;MACXC,IAAI,EAAEC,iBAAiB,CAACJ,UAAU;IACtC,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIK,IAAIA,CAACC,IAAI,EAAE;IACP;IACA,OAAO,IAAI,CAACjB,IAAI,CAAC,IAAIkB,YAAY,CAACD,IAAI,CAAC,CAAC;EAC5C;EACA;AACJ;AACA;EACIE,MAAMA,CAACC,OAAO,EAAE;IACZ,OAAO,IAAI,CAACpB,IAAI;IAChB;IACA,IAAIqB,cAAc;IAClB;IACA,IAAIC,WAAW,CAAC;MAAEC,KAAK,EAAEH;IAAQ,CAAC,CAAC,CAAC,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,OAAOI,SAASA,CAACC,SAAS,EAAE5F,OAAO,EAAE;IACjC,IAAI6F,UAAU;IACd,WAAW,MAAM5B,KAAK,IAAI2B,SAAS,EAAE;MACjC,IAAIC,UAAU,KAAK3F,SAAS,EAAE;QAC1B2F,UAAU,GAAG5B,KAAK;MACtB,CAAC,MACI;QACD;QACA;QACA;QACA4B,UAAU,GAAG/I,MAAM,CAAC+I,UAAU,EAAE5B,KAAK,CAAC;MAC1C;IACJ;IACA,OAAO,IAAI,CAACzC,eAAe,CAACqE,UAAU,EAAE7F,OAAO,CAAC;EACpD;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAO8F,SAASA,CAAC9E,KAAK,EAAEhB,OAAO,EAAE+F,aAAa,EAAE;IAC5C,MAAMC,wBAAwB,GAAG,IAAIvJ,wBAAwB,CAAC;MAC1D,GAAGsJ,aAAa;MAChBE,SAAS,EAAE,KAAK;MAChBC,aAAa,EAAE;IACnB,CAAC,CAAC;IACF,MAAMhH,MAAM,GAAG/B,YAAY,CAAC6C,OAAO,CAAC;IACpC,OAAO,IAAI,CAACmG,UAAU,CAACnF,KAAK,EAAEgF,wBAAwB,EAAE9G,MAAM,CAAC;EACnE;EACA,OAAOiH,UAAUA,CAACnF,KAAK,EAAEgF,wBAAwB,EAAE9G,MAAM,EAAE;IACvD,MAAM;MAAE6C;IAAU,CAAC,GAAG7C,MAAM;IAC5B,IAAI6C,SAAS,KAAK7B,SAAS,EAAE;MACzB;MACAhB,MAAM,CAAC6C,SAAS,GAAG,CAACiE,wBAAwB,CAAC;IACjD,CAAC,MACI,IAAInI,KAAK,CAACC,OAAO,CAACiE,SAAS,CAAC,EAAE;MAC/B;MACA7C,MAAM,CAAC6C,SAAS,GAAGA,SAAS,CAACjF,MAAM,CAAC,CAACkJ,wBAAwB,CAAC,CAAC;IACnE,CAAC,MACI;MACD,MAAMI,eAAe,GAAGrE,SAAS,CAACsE,IAAI,CAAC,CAAC;MACxCD,eAAe,CAACE,mBAAmB,CAACC,IAAI,CAACP,wBAAwB,CAAC;MAClE;MACA9G,MAAM,CAAC6C,SAAS,GAAGqE,eAAe;IACtC;IACA,MAAMI,qBAAqB,GAAG,IAAI,CAAC/E,MAAM,CAACT,KAAK,EAAE9B,MAAM,CAAC;IACxD,eAAeuH,qBAAqBA,CAAA,EAAG;MACnC,IAAI;QACA,MAAMC,cAAc,GAAG,MAAMF,qBAAqB;QAClD,WAAW,MAAMvC,KAAK,IAAIyC,cAAc,EAAE;UACtC,MAAMC,KAAK,GAAG,IAAIhK,WAAW,CAAC;YAC1BiK,GAAG,EAAE,CACD;cACIC,EAAE,EAAE,KAAK;cACTC,IAAI,EAAE,oBAAoB;cAC1BnJ,KAAK,EAAEsG;YACX,CAAC;UAET,CAAC,CAAC;UACF,MAAM+B,wBAAwB,CAACe,MAAM,CAACC,KAAK,CAACL,KAAK,CAAC;QACtD;MACJ,CAAC,SACO;QACJ,MAAMX,wBAAwB,CAACe,MAAM,CAACE,KAAK,CAAC,CAAC;MACjD;IACJ;IACA,MAAMC,4BAA4B,GAAGT,qBAAqB,CAAC,CAAC;IAC5D,IAAI;MACA,WAAW,MAAMU,GAAG,IAAInB,wBAAwB,EAAE;QAC9C,MAAMmB,GAAG;MACb;IACJ,CAAC,SACO;MACJ,MAAMD,4BAA4B;IACtC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOE,YAAYA,CAACpG,KAAK,EAAEhB,OAAO,EAAE+F,aAAa,EAAE;IAAA,IAAAsB,YAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,OAAA;IAC/C,IAAIxH,OAAO,CAACyH,OAAO,KAAK,IAAI,EAAE;MAC1B,MAAM,IAAItH,KAAK,mEAAiE,CAAC;IACrF;IACA,IAAIuH,MAAM;IACV,IAAIC,wBAAwB,GAAG,KAAK;IACpC,MAAMzI,MAAM,GAAG/B,YAAY,CAAC6C,OAAO,CAAC;IACpC,MAAM4H,QAAQ,IAAAP,YAAA,GAAGnI,MAAM,CAAC8C,IAAI,cAAAqF,YAAA,cAAAA,YAAA,GAAI,EAAE;IAClC,MAAMQ,YAAY,IAAAP,gBAAA,GAAGpI,MAAM,CAAC+C,QAAQ,cAAAqF,gBAAA,cAAAA,gBAAA,GAAI,CAAC,CAAC;IAC1C,MAAMQ,QAAQ,IAAAP,gBAAA,GAAGrI,MAAM,CAACgD,OAAO,cAAAqF,gBAAA,cAAAA,gBAAA,GAAI,IAAI,CAAC/I,OAAO,CAAC,CAAC;IACjD,MAAMwH,wBAAwB,GAAG,IAAIvJ,wBAAwB,CAAC;MAC1D,GAAGsJ,aAAa;MAChBE,SAAS,EAAE,KAAK;MAChBC,aAAa,EAAE;IACnB,CAAC,CAAC;IACF,MAAM6B,eAAe,GAAG,IAAItK,gBAAgB,CAAC;MACzC,GAAGsI;IACP,CAAC,CAAC;IACF,MAAMiC,SAAS,GAAG,IAAI,CAAC7B,UAAU,CAACnF,KAAK,EAAEgF,wBAAwB,EAAE9G,MAAM,CAAC;IAC1E,WAAW,MAAMiI,GAAG,IAAIa,SAAS,EAAE;MAC/B,IAAI,CAACN,MAAM,EAAE;QACTA,MAAM,GAAGhL,MAAM,CAACuL,eAAe,CAACd,GAAG,CAAC;MACxC,CAAC,MACI;QACDO,MAAM,GAAGA,MAAM,CAAC5K,MAAM,CAACqK,GAAG,CAAC;MAC/B;MACA,IAAIO,MAAM,CAACQ,KAAK,KAAKhI,SAAS,EAAE;QAC5B,MAAM,IAAIC,KAAK,+EAA6E,CAAC;MACjG;MACA;MACA;MACA,IAAI,CAACwH,wBAAwB,EAAE;QAC3BA,wBAAwB,GAAG,IAAI;QAC/B,MAAMO,KAAK,GAAG;UAAE,GAAGR,MAAM,CAACQ;QAAM,CAAC;QACjC,MAAMC,KAAK,GAAG;UACVC,MAAM,EAAEF,KAAK,CAACG,EAAE;UAChBF,KAAK,QAAArL,MAAA,CAAQoL,KAAK,CAACI,IAAI,WAAQ;UAC/B1J,IAAI,EAAEkJ,QAAQ;UACd9F,IAAI,EAAE4F,QAAQ;UACd3F,QAAQ,EAAE4F,YAAY;UACtBU,IAAI,EAAE;YACFvH;UACJ;QACJ,CAAC;QACD,IAAI+G,eAAe,CAACS,YAAY,CAACL,KAAK,EAAED,KAAK,CAACI,IAAI,CAAC,EAAE;UACjD,MAAMH,KAAK;QACf;MACJ;MACA,MAAMM,KAAK,GAAGtB,GAAG,CAACP,GAAG,CAChB8B,MAAM,CAAE7B,EAAE,IAAKA,EAAE,CAACC,IAAI,CAAC6B,UAAU,CAAC,QAAQ,CAAC,CAAC,CAC5CxJ,GAAG,CAAE0H,EAAE,IAAKA,EAAE,CAACC,IAAI,CAAC8B,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACvC,MAAMC,YAAY,GAAG,CAAC,GAAG,IAAIC,GAAG,CAACL,KAAK,CAAC,CAAC;MACxC,KAAK,MAAM3B,IAAI,IAAI+B,YAAY,EAAE;QAC7B,IAAIE,SAAS;QACb,IAAIR,IAAI,GAAG,CAAC,CAAC;QACb,MAAMS,QAAQ,GAAGtB,MAAM,CAACQ,KAAK,CAACe,IAAI,CAACnC,IAAI,CAAC;QACxC,IAAIkC,QAAQ,CAACE,QAAQ,KAAKhJ,SAAS,EAAE;UACjC,IAAI8I,QAAQ,CAACG,eAAe,CAAClJ,MAAM,GAAG,CAAC,EAAE;YACrC8I,SAAS,GAAG,QAAQ;UACxB,CAAC,MACI;YACDA,SAAS,GAAG,OAAO;UACvB;QACJ,CAAC,MACI;UACDA,SAAS,GAAG,KAAK;QACrB;QACA,IAAIA,SAAS,KAAK,OAAO,EAAE;UACvB;UACA;UACA;UACA;UACA,IAAIC,QAAQ,CAAC1I,MAAM,KAAKJ,SAAS,EAAE;YAC/BqI,IAAI,CAACvH,KAAK,GAAGgI,QAAQ,CAAC1I,MAAM;UAChC;QACJ,CAAC,MACI,IAAIyI,SAAS,KAAK,KAAK,EAAE;UAC1B,IAAIC,QAAQ,CAAC1I,MAAM,KAAKJ,SAAS,EAAE;YAC/BqI,IAAI,CAACvH,KAAK,GAAGgI,QAAQ,CAAC1I,MAAM;UAChC;UACAiI,IAAI,CAAC1F,MAAM,GAAGmG,QAAQ,CAACI,YAAY;QACvC,CAAC,MACI,IAAIL,SAAS,KAAK,QAAQ,EAAE;UAC7B,MAAMM,UAAU,GAAGL,QAAQ,CAACG,eAAe,CAAClJ,MAAM;UAClD,IAAIoJ,UAAU,KAAK,CAAC,EAAE;YAClB,MAAM,IAAIlJ,KAAK,uDAAArD,MAAA,CAAuDuM,UAAU,kCAAAvM,MAAA,CAA8BkM,QAAQ,CAACpK,IAAI,OAAG,CAAC;UACnI;UACA2J,IAAI,GAAG;YAAEtE,KAAK,EAAE+E,QAAQ,CAACG,eAAe,CAAC,CAAC;UAAE,CAAC;UAC7C;UACA;UACAH,QAAQ,CAACG,eAAe,GAAG,EAAE;QACjC;QACA,MAAM;UACFhB,KAAK,QAAArL,MAAA,CAAQkM,QAAQ,CAACV,IAAI,OAAAxL,MAAA,CAAIiM,SAAS,CAAE;UACzCnK,IAAI,EAAEoK,QAAQ,CAACpK,IAAI;UACnBwJ,MAAM,EAAEY,QAAQ,CAACX,EAAE;UACnBrG,IAAI,EAAEgH,QAAQ,CAAChH,IAAI;UACnBC,QAAQ,EAAE+G,QAAQ,CAAC/G,QAAQ;UAC3BsG;QACJ,CAAC;MACL;MACA;MACA;MACA,MAAM;QAAEL;MAAM,CAAC,GAAGR,MAAM;MACxB,IAAIQ,KAAK,CAACiB,eAAe,CAAClJ,MAAM,GAAG,CAAC,EAAE;QAClC,MAAMoJ,UAAU,GAAGnB,KAAK,CAACiB,eAAe,CAAClJ,MAAM;QAC/C,IAAIoJ,UAAU,KAAK,CAAC,EAAE;UAClB,MAAM,IAAIlJ,KAAK,uDAAArD,MAAA,CAAuDuM,UAAU,kCAAAvM,MAAA,CAA8BoL,KAAK,CAACtJ,IAAI,OAAG,CAAC;QAChI;QACA,MAAM2J,IAAI,GAAG;UAAEtE,KAAK,EAAEiE,KAAK,CAACiB,eAAe,CAAC,CAAC;QAAE,CAAC;QAChD;QACAjB,KAAK,CAACiB,eAAe,GAAG,EAAE;QAC1B,MAAMhB,KAAK,GAAG;UACVA,KAAK,QAAArL,MAAA,CAAQoL,KAAK,CAACI,IAAI,YAAS;UAChCF,MAAM,EAAEF,KAAK,CAACG,EAAE;UAChBrG,IAAI,EAAE4F,QAAQ;UACd3F,QAAQ,EAAE4F,YAAY;UACtBjJ,IAAI,EAAEkJ,QAAQ;UACdS;QACJ,CAAC;QACD,IAAIR,eAAe,CAACS,YAAY,CAACL,KAAK,EAAED,KAAK,CAACI,IAAI,CAAC,EAAE;UACjD,MAAMH,KAAK;QACf;MACJ;IACJ;IACA,MAAMD,KAAK,IAAAV,OAAA,GAAGE,MAAM,cAAAF,OAAA,uBAANA,OAAA,CAAQU,KAAK;IAC3B,IAAIA,KAAK,KAAKhI,SAAS,EAAE;MACrB;MACA,MAAMiI,KAAK,GAAG;QACVA,KAAK,QAAArL,MAAA,CAAQoL,KAAK,CAACI,IAAI,SAAM;QAC7B1J,IAAI,EAAEkJ,QAAQ;QACdM,MAAM,EAAEF,KAAK,CAACG,EAAE;QAChBrG,IAAI,EAAE4F,QAAQ;QACd3F,QAAQ,EAAE4F,YAAY;QACtBU,IAAI,EAAE;UACF1F,MAAM,EAAEqF,KAAK,CAACkB;QAClB;MACJ,CAAC;MACD,IAAIrB,eAAe,CAACS,YAAY,CAACL,KAAK,EAAED,KAAK,CAACI,IAAI,CAAC,EAC/C,MAAMH,KAAK;IACnB;EACJ;EACA;EACA,OAAOmB,UAAUA,CAACC,KAAK,EAAE;IACrB,OAAOA,KAAK,GAAGA,KAAK,CAACC,WAAW,GAAG,KAAK;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAAAC,KAAA,EAA+B;IAAA,IAA9B;MAAEC,OAAO;MAAEC,KAAK;MAAEC;IAAS,CAAC,GAAAH,KAAA;IACtC;IACA,OAAO,IAAI1K,eAAe,CAAC;MACvBC,KAAK,EAAE,IAAI;MACXC,MAAM,EAAE,CAAC,CAAC;MACV4K,eAAe,EAAE,CACZ5K,MAAM,KAAM;QACT6C,SAAS,EAAE,CACP,IAAIvE,mBAAmB,CAAC;UACpB0B,MAAM;UACNyK,OAAO;UACPC,KAAK;UACLC;QACJ,CAAC,CAAC;MAEV,CAAC,CAAC;IAEV,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAM7K,eAAe,SAAShB,QAAQ,CAAC;EAC1C,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,iBAAiB;EAC5B;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACsB,KAAK,GAAGK,MAAM,CAACL,KAAK;IACzB,IAAI,CAACF,MAAM,GAAGO,MAAM,CAACP,MAAM;IAC3B,IAAI,CAACG,MAAM,GAAGI,MAAM,CAACJ,MAAM;IAC3B,IAAI,CAAC4K,eAAe,GAAGxK,MAAM,CAACwK,eAAe;EACjD;EACAtL,OAAOA,CAACC,MAAM,EAAE;IACZ,OAAO,IAAI,CAACQ,KAAK,CAACT,OAAO,CAACC,MAAM,CAAC;EACrC;EACA,MAAMsL,YAAYA,CAAA,EAAa;IAAA,SAAAC,IAAA,GAAA9L,SAAA,CAAA+B,MAAA,EAATD,OAAO,OAAAnC,KAAA,CAAAmM,IAAA,GAAAC,IAAA,MAAAA,IAAA,GAAAD,IAAA,EAAAC,IAAA;MAAPjK,OAAO,CAAAiK,IAAA,IAAA/L,SAAA,CAAA+L,IAAA;IAAA;IACzB,MAAM/K,MAAM,GAAG7B,YAAY,CAAC,IAAI,CAAC6B,MAAM,EAAE,GAAGc,OAAO,CAAC;IACpD,OAAO3C,YAAY,CAAC6B,MAAM,EAAE,IAAI,IAAI,CAAC4K,eAAe,GAC9C,MAAMxI,OAAO,CAACC,GAAG,CAAC,IAAI,CAACuI,eAAe,CAAC3K,GAAG,CAAC,MAAO+K,aAAa,IAAK,MAAMA,aAAa,CAAChL,MAAM,CAAC,CAAC,CAAC,GACjG,EAAE,CAAC,CAAC;EACd;EACAJ,IAAIA,CAACC,MAAM,EAAE;IACT;IACA,OAAO,IAAI,IAAI,CAACd,WAAW,CAAC;MACxBgB,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBF,MAAM,EAAE;QAAE,GAAG,IAAI,CAACA,MAAM;QAAE,GAAGA;MAAO,CAAC;MACrCG,MAAM,EAAE,IAAI,CAACA;IACjB,CAAC,CAAC;EACN;EACAQ,UAAUA,CAACR,MAAM,EAAE;IACf;IACA,OAAO,IAAI,IAAI,CAACjB,WAAW,CAAC;MACxBgB,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBF,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBG,MAAM,EAAE;QAAE,GAAG,IAAI,CAACA,MAAM;QAAE,GAAGA;MAAO;IACxC,CAAC,CAAC;EACN;EACAG,SAASA,CAACC,MAAM,EAAE;IACd;IACA,OAAO,IAAI,IAAI,CAACrB,WAAW,CAAC;MACxBgB,KAAK,EAAE,IAAI,CAACA,KAAK,CAACI,SAAS,CAACC,MAAM,CAAC;MACnCP,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBG,MAAM,EAAE,IAAI,CAACA;IACjB,CAAC,CAAC;EACN;EACA,MAAMkC,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,OAAO,IAAI,CAACf,KAAK,CAACmC,MAAM,CAACJ,KAAK,EAAE,MAAM,IAAI,CAAC+I,YAAY,CAAC/J,OAAO,EAAE,IAAI,CAACjB,MAAM,CAAC,CAAC;EAClF;EACA,MAAMsB,KAAKA,CAACC,MAAM,EAAEN,OAAO,EAAEO,YAAY,EAAE;IACvC,MAAM4J,aAAa,GAAGtM,KAAK,CAACC,OAAO,CAACkC,OAAO,CAAC,GACtC,MAAMsB,OAAO,CAACC,GAAG,CAACvB,OAAO,CAACb,GAAG,CAAC,MAAOiL,gBAAgB,IAAK,IAAI,CAACL,YAAY,CAACK,gBAAgB,EAAE,IAAI,CAACrL,MAAM,CAAC,CAAC,CAAC,GAC5G,MAAM,IAAI,CAACgL,YAAY,CAAC/J,OAAO,EAAE,IAAI,CAACjB,MAAM,CAAC;IACnD,OAAO,IAAI,CAACE,KAAK,CAACoB,KAAK,CAACC,MAAM,EAAE6J,aAAa,EAAE5J,YAAY,CAAC;EAChE;EACA,OAAOiB,eAAeA,CAACR,KAAK,EAAEhB,OAAO,EAAE;IACnC,OAAO,IAAI,CAACf,KAAK,CAACuC,eAAe,CAACR,KAAK,EAAE,MAAM,IAAI,CAAC+I,YAAY,CAAC/J,OAAO,EAAE,IAAI,CAACjB,MAAM,CAAC,CAAC;EAC3F;EACA,MAAM0C,MAAMA,CAACT,KAAK,EAAEhB,OAAO,EAAE;IACzB,OAAO,IAAI,CAACf,KAAK,CAACwC,MAAM,CAACT,KAAK,EAAE,MAAM,IAAI,CAAC+I,YAAY,CAAC/J,OAAO,EAAE,IAAI,CAACjB,MAAM,CAAC,CAAC;EAClF;EACA,OAAO4G,SAASA;EAChB;EACAC,SAAS,EAAE5F,OAAO,EAAE;IAChB,OAAO,IAAI,CAACf,KAAK,CAAC0G,SAAS,CAACC,SAAS,EAAE,MAAM,IAAI,CAACmE,YAAY,CAAC/J,OAAO,EAAE,IAAI,CAACjB,MAAM,CAAC,CAAC;EACzF;EACA,OAAOqI,YAAYA,CAACpG,KAAK,EAAEhB,OAAO,EAAE+F,aAAa,EAAE;IAC/C,OAAO,IAAI,CAAC9G,KAAK,CAACmI,YAAY,CAACpG,KAAK,EAAE;MAClC,IAAI,MAAM,IAAI,CAAC+I,YAAY,CAAC/J,OAAO,EAAE,IAAI,CAACjB,MAAM,CAAC,CAAC;MAClD0I,OAAO,EAAEzH,OAAO,CAACyH;IACrB,CAAC,EAAE1B,aAAa,CAAC;EACrB;EACA,OAAOsE,iBAAiBA;EACxB;EACAd;EACA;EAAA,EACE;IACE,OAAOA,KAAK,CAACtK,KAAK,IAAIjB,QAAQ,CAACsL,UAAU,CAACC,KAAK,CAACtK,KAAK,CAAC;EAC1D;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIwK,aAAaA,CAAAa,KAAA,EAA+B;IAAA,IAA9B;MAAEX,OAAO;MAAEC,KAAK;MAAEC;IAAS,CAAC,GAAAS,KAAA;IACtC,OAAO,IAAItL,eAAe,CAAC;MACvBC,KAAK,EAAE,IAAI,CAACA,KAAK;MACjBF,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBG,MAAM,EAAE,IAAI,CAACA,MAAM;MACnB4K,eAAe,EAAE,CACZ5K,MAAM,KAAM;QACT6C,SAAS,EAAE,CACP,IAAIvE,mBAAmB,CAAC;UACpB0B,MAAM;UACNyK,OAAO;UACPC,KAAK;UACLC;QACJ,CAAC,CAAC;MAEV,CAAC,CAAC;IAEV,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMzK,YAAY,SAASpB,QAAQ,CAAC;EACvC,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,cAAc;EACzB;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACsB,KAAK,GAAGK,MAAM,CAACL,KAAK;EAC7B;EACA;AACJ;AACA;AACA;AACA;EACIH,IAAIA,CAACC,MAAM,EAAE;IACT,OAAO,IAAIK,YAAY,CAAC;MACpBH,KAAK,EAAE,IAAI,CAACA,KAAK,CAACH,IAAI,CAACC,MAAM;IACjC,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMqC,MAAMA,CAACd,MAAM,EAAEpB,MAAM,EAAE;IACzB,OAAO,IAAI,CAACmD,eAAe,CAAC,IAAI,CAACkI,OAAO,EAAEjK,MAAM,EAAEpB,MAAM,CAAC;EAC7D;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMqL,OAAOA,CAACjK,MAAM,EAAEpB,MAAM,EAAEuD,UAAU,EAAE;IACtC,OAAO,IAAI,CAACxD,KAAK,CAACoB,KAAK,CAACC,MAAM,EAAEhD,WAAW,CAAC4B,MAAM,EAAE;MAAE6C,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAAC;IAAE,CAAC,CAAC,CAAC;EAC/F;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIf,aAAaA,CAAAgB,KAAA,EAA+B;IAAA,IAA9B;MAAEd,OAAO;MAAEC,KAAK;MAAEC;IAAS,CAAC,GAAAY,KAAA;IACtC,OAAO,IAAIrL,YAAY,CAAC;MACpBH,KAAK,EAAE,IAAI,CAACA,KAAK,CAACwK,aAAa,CAAC;QAAEE,OAAO;QAAEC,KAAK;QAAEC;MAAQ,CAAC;IAC/D,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMtK,aAAa,SAASP,eAAe,CAAC;EAC/C,OAAOH,OAAOA,CAAA,EAAG;IACb,OAAO,eAAe;EAC1B;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAAA,IAAAoL,qBAAA,EAAAC,qBAAA;IAChB,KAAK,CAACrL,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAC5CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACF;IACAQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAEA,CAAA,KAAM,CAAE;IACnB,CAAC,CAAC;IACF,IAAI,CAAC6B,gBAAgB,IAAAkL,qBAAA,GAAGpL,MAAM,CAACE,gBAAgB,cAAAkL,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAAClL,gBAAgB;IACxE,IAAI,CAACqB,eAAe,IAAA8J,qBAAA,GAAGrL,MAAM,CAACuB,eAAe,cAAA8J,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAAC9J,eAAe;EACzE;EACA+J,oBAAoBA,CAACC,OAAO,EAAE3L,MAAM,EAAEuD,UAAU,EAAE;IAC9C,MAAMqI,GAAG,GAAGD,OAAO,GAAG,CAAC,oBAAA/N,MAAA,CAAoB+N,OAAO,IAAK3K,SAAS;IAChE,OAAO5C,WAAW,CAAC4B,MAAM,EAAE;MAAE6C,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAACM,GAAG;IAAE,CAAC,CAAC;EACxE;EACA,MAAMP,OAAOA,CAACvJ,KAAK,EAAE9B,MAAM,EAAEuD,UAAU,EAAE;IACrC,OAAOlG,MAAM,CAAEwO,aAAa,IAAK,KAAK,CAAC3J,MAAM,CAACJ,KAAK,EAAE,IAAI,CAAC4J,oBAAoB,CAACG,aAAa,EAAE7L,MAAM,EAAEuD,UAAU,CAAC,CAAC,EAAE;MAChH5B,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCmK,OAAO,EAAEC,IAAI,CAACC,GAAG,CAAC,IAAI,CAAC1L,gBAAgB,GAAG,CAAC,EAAE,CAAC,CAAC;MAC/C2L,SAAS,EAAE;IACf,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM/J,MAAMA,CAACJ,KAAK,EAAE9B,MAAM,EAAE;IACxB,OAAO,IAAI,CAACmD,eAAe,CAAC,IAAI,CAACkI,OAAO,EAAEvJ,KAAK,EAAE9B,MAAM,CAAC;EAC5D;EACA,MAAMkM,MAAMA,CAAC9K,MAAM,EAAE+K,OAAO,EAAElI,WAAW,EAAE5C,YAAY,EAAE;IACrD,MAAM+K,UAAU,GAAG,CAAC,CAAC;IACrB,IAAI;MACA,MAAM/O,MAAM,CAAC,MAAOwO,aAAa,IAAK;QAClC,MAAMQ,gBAAgB,GAAGjL,MAAM,CAC1BnB,GAAG,CAAC,CAACqM,CAAC,EAAEvK,CAAC,KAAKA,CAAC,CAAC,CAChByH,MAAM,CAAEzH,CAAC,IAAKqK,UAAU,CAACrK,CAAC,CAACwK,QAAQ,CAAC,CAAC,CAAC,KAAKvL,SAAS;QACrD;QACAoL,UAAU,CAACrK,CAAC,CAACwK,QAAQ,CAAC,CAAC,CAAC,YAAYtL,KAAK,CAAC;QAC9C,MAAMuL,eAAe,GAAGH,gBAAgB,CAACpM,GAAG,CAAE8B,CAAC,IAAKX,MAAM,CAACW,CAAC,CAAC,CAAC;QAC9D,MAAM0K,cAAc,GAAGJ,gBAAgB,CAACpM,GAAG,CAAE8B,CAAC,IAAK,IAAI,CAAC2J,oBAAoB,CAACG,aAAa,EAAEM,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAGpK,CAAC,CAAC,EAAEkC,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAGlC,CAAC,CAAC,CAAC,CAAC;QAC5H,MAAM2K,OAAO,GAAG,MAAM,KAAK,CAACvL,KAAK,CAACqL,eAAe,EAAEC,cAAc,EAAE;UAC/D,GAAGpL,YAAY;UACfc,gBAAgB,EAAE;QACtB,CAAC,CAAC;QACF,IAAIwK,cAAc;QAClB,KAAK,IAAI5K,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2K,OAAO,CAAC3L,MAAM,EAAEgB,CAAC,IAAI,CAAC,EAAE;UACxC,MAAME,MAAM,GAAGyK,OAAO,CAAC3K,CAAC,CAAC;UACzB,MAAM6K,cAAc,GAAGP,gBAAgB,CAACtK,CAAC,CAAC;UAC1C;UACA,IAAIE,MAAM,YAAYhB,KAAK,EAAE;YACzB,IAAI0L,cAAc,KAAK3L,SAAS,EAAE;cAC9B2L,cAAc,GAAG1K,MAAM;YAC3B;UACJ;UACAmK,UAAU,CAACQ,cAAc,CAACL,QAAQ,CAAC,CAAC,CAAC,GAAGtK,MAAM;QAClD;QACA,IAAI0K,cAAc,EAAE;UAChB,MAAMA,cAAc;QACxB;QACA,OAAOD,OAAO;MAClB,CAAC,EAAE;QACC/K,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCmK,OAAO,EAAEC,IAAI,CAACC,GAAG,CAAC,IAAI,CAAC1L,gBAAgB,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/C2L,SAAS,EAAE;MACf,CAAC,CAAC;IACN,CAAC,CACD,OAAOrK,CAAC,EAAE;MACN,IAAI,CAAAP,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEc,gBAAgB,MAAK,IAAI,EAAE;QACzC,MAAMP,CAAC;MACX;IACJ;IACA,OAAO3C,MAAM,CAACiH,IAAI,CAACkG,UAAU,CAAC,CACzBS,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKC,QAAQ,CAACF,CAAC,EAAE,EAAE,CAAC,GAAGE,QAAQ,CAACD,CAAC,EAAE,EAAE,CAAC,CAAC,CACjD9M,GAAG,CAAEgN,GAAG,IAAKb,UAAU,CAACY,QAAQ,CAACC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;EACpD;EACA,MAAM9L,KAAKA,CAACC,MAAM,EAAEN,OAAO,EAAEO,YAAY,EAAE;IACvC,OAAO,IAAI,CAACyC,gBAAgB,CAAC,IAAI,CAACoI,MAAM,CAACtM,IAAI,CAAC,IAAI,CAAC,EAAEwB,MAAM,EAAEN,OAAO,EAAEO,YAAY,CAAC;EACvF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMwE,gBAAgB,SAAS/G,QAAQ,CAAC;EAC3C,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,kBAAkB;EAC7B;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAAA,IAAA8M,cAAA;IAChB,KAAK,CAAC9M,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACF;IACAQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;MAChCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACF,IAAI,CAACqH,KAAK,GAAG1F,MAAM,CAAC0F,KAAK;IACzB,IAAI,CAACqH,MAAM,IAAAD,cAAA,GAAG9M,MAAM,CAAC+M,MAAM,cAAAD,cAAA,cAAAA,cAAA,GAAI,IAAI,CAACC,MAAM;IAC1C,IAAI,CAACpH,IAAI,GAAG3F,MAAM,CAAC2F,IAAI;IACvB,IAAI,CAACrG,IAAI,GAAGU,MAAM,CAACV,IAAI;EAC3B;EACA,IAAI8G,KAAKA,CAAA,EAAG;IACR,OAAO,CAAC,IAAI,CAACV,KAAK,EAAE,GAAG,IAAI,CAACqH,MAAM,EAAE,IAAI,CAACpH,IAAI,CAAC;EAClD;EACA,MAAM7D,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,MAAMwC,gBAAgB,GAAG,MAAMpF,2BAA2B,CAAC4C,OAAO,CAAC;IACnE,MAAMyC,UAAU,GAAG,OAAMD,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEE,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAACsD,KAAK,EAAE,OAAO,CAAC,EAAEd,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkC,OAAO,CAAC;IACvK,IAAIoK,aAAa,GAAGtL,KAAK;IACzB,IAAI8C,WAAW;IACf,IAAI;MACA,MAAMyI,YAAY,GAAG,CAAC,IAAI,CAACvH,KAAK,EAAE,GAAG,IAAI,CAACqH,MAAM,CAAC;MACjD,KAAK,IAAIpL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsL,YAAY,CAACtM,MAAM,EAAEgB,CAAC,IAAI,CAAC,EAAE;QAC7C,MAAMuL,IAAI,GAAGD,YAAY,CAACtL,CAAC,CAAC;QAC5BqL,aAAa,GAAG,MAAME,IAAI,CAACpL,MAAM,CAACkL,aAAa,EAAEhP,WAAW,CAAC0C,OAAO,EAAE;UAClE+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,aAAA1N,MAAA,CAAamE,CAAC,GAAG,CAAC,CAAE;QACvD,CAAC,CAAC,CAAC;MACP;MACA;MACA6C,WAAW,GAAG,MAAM,IAAI,CAACmB,IAAI,CAAC7D,MAAM,CAACkL,aAAa,EAAEhP,WAAW,CAAC0C,OAAO,EAAE;QACrE+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,aAAA1N,MAAA,CAAa,IAAI,CAAC4I,KAAK,CAACzF,MAAM,CAAE;MACnE,CAAC,CAAC,CAAC;IACP,CAAC,CACD,OAAOa,CAAC,EAAE;MACN,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAChC,CAAC,CAAC;MACrC,MAAMA,CAAC;IACX;IACA,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAACoG,WAAW,EAAE,QAAQ,CAAC,CAAC;IACtE,OAAOA,WAAW;EACtB;EACA,MAAMzD,KAAKA,CAACC,MAAM,EAAEN,OAAO,EAAEO,YAAY,EAAE;IACvC,MAAMG,UAAU,GAAG,IAAI,CAACX,eAAe,CAACC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,CAAC,CAAC,EAAEM,MAAM,CAACL,MAAM,CAAC;IACrE,MAAMiD,gBAAgB,GAAG,MAAM5B,OAAO,CAACC,GAAG,CAACb,UAAU,CAACvB,GAAG,CAAC/B,2BAA2B,CAAC,CAAC;IACvF,MAAM+F,WAAW,GAAG,MAAM7B,OAAO,CAACC,GAAG,CAAC2B,gBAAgB,CAAC/D,GAAG,CAAC,CAACiE,eAAe,EAAEnC,CAAC,KAAKmC,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEV,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAAC4C,MAAM,CAACW,CAAC,CAAC,EAAE,OAAO,CAAC,EAAEf,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEQ,UAAU,CAACO,CAAC,CAAC,CAACiB,OAAO,CAAC,CAAC,CAAC;IAC3O;IACA,IAAIuK,cAAc,GAAGnM,MAAM;IAC3B,IAAI;MACA,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACyE,KAAK,CAACzF,MAAM,EAAEgB,CAAC,IAAI,CAAC,EAAE;QAC3C,MAAMuL,IAAI,GAAG,IAAI,CAAC9G,KAAK,CAACzE,CAAC,CAAC;QAC1BwL,cAAc,GAAG,MAAMD,IAAI,CAACnM,KAAK,CAACoM,cAAc,EAAEtJ,WAAW,CAAChE,GAAG,CAAC,CAACsD,UAAU,EAAEiK,CAAC,KAAK;UACjF,MAAMC,eAAe,GAAGlK,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,aAAA1N,MAAA,CAAamE,CAAC,GAAG,CAAC,CAAE,CAAC;UACjE,OAAO3D,WAAW,CAACoD,UAAU,CAACgM,CAAC,CAAC,EAAE;YAAE3K,SAAS,EAAE4K;UAAgB,CAAC,CAAC;QACrE,CAAC,CAAC,EAAEpM,YAAY,CAAC;MACrB;IACJ,CAAC,CACD,OAAOO,CAAC,EAAE;MACN,MAAMQ,OAAO,CAACC,GAAG,CAAC4B,WAAW,CAAChE,GAAG,CAAEsD,UAAU,IAAKA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAChC,CAAC,CAAC,CAAC,CAAC;MACnF,MAAMA,CAAC;IACX;IACA,MAAMQ,OAAO,CAACC,GAAG,CAAC4B,WAAW,CAAChE,GAAG,CAAEsD,UAAU,IAAKA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAAC+O,cAAc,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;IACvH,OAAOA,cAAc;EACzB;EACA,OAAOjL,eAAeA,CAACR,KAAK,EAAEhB,OAAO,EAAE;IACnC,MAAMwC,gBAAgB,GAAG,MAAMpF,2BAA2B,CAAC4C,OAAO,CAAC;IACnE,MAAMyC,UAAU,GAAG,OAAMD,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEE,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAACsD,KAAK,EAAE,OAAO,CAAC,EAAEd,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkC,OAAO,CAAC;IACvK,MAAMwD,KAAK,GAAG,CAAC,IAAI,CAACV,KAAK,EAAE,GAAG,IAAI,CAACqH,MAAM,EAAE,IAAI,CAACpH,IAAI,CAAC;IACrD,IAAI2H,eAAe,GAAG,IAAI;IAC1B,IAAI9I,WAAW;IACf,gBAAgBN,cAAcA,CAAA,EAAG;MAC7B,MAAMxC,KAAK;IACf;IACA,IAAI;MACA,IAAI6L,cAAc,GAAGnH,KAAK,CAAC,CAAC,CAAC,CAACC,SAAS,CAACnC,cAAc,CAAC,CAAC,EAAElG,WAAW,CAAC0C,OAAO,EAAE;QAC3E+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,aAAa;MAChD,CAAC,CAAC,CAAC;MACH,KAAK,IAAIvJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyE,KAAK,CAACzF,MAAM,EAAEgB,CAAC,IAAI,CAAC,EAAE;QACtC,MAAMuL,IAAI,GAAG9G,KAAK,CAACzE,CAAC,CAAC;QACrB4L,cAAc,GAAG,MAAML,IAAI,CAAC7G,SAAS,CAACkH,cAAc,EAAEvP,WAAW,CAAC0C,OAAO,EAAE;UACvE+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,aAAA1N,MAAA,CAAamE,CAAC,GAAG,CAAC,CAAE;QACvD,CAAC,CAAC,CAAC;MACP;MACA,WAAW,MAAMgD,KAAK,IAAI4I,cAAc,EAAE;QACtC,MAAM5I,KAAK;QACX,IAAI2I,eAAe,EAAE;UACjB,IAAI9I,WAAW,KAAK5D,SAAS,EAAE;YAC3B4D,WAAW,GAAGG,KAAK;UACvB,CAAC,MACI;YACD,IAAI;cACA;cACAH,WAAW,GAAGhH,MAAM,CAACgH,WAAW,EAAEG,KAAK,CAAC;YAC5C,CAAC,CACD,OAAOnD,CAAC,EAAE;cACNgD,WAAW,GAAG5D,SAAS;cACvB0M,eAAe,GAAG,KAAK;YAC3B;UACJ;QACJ;MACJ;IACJ,CAAC,CACD,OAAO9L,CAAC,EAAE;MACN,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAChC,CAAC,CAAC;MACrC,MAAMA,CAAC;IACX;IACA,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAACoG,WAAW,EAAE,QAAQ,CAAC,CAAC;EAC1E;EACAK,IAAIA,CAACW,UAAU,EAAE;IACb,IAAIC,gBAAgB,CAAC+H,kBAAkB,CAAChI,UAAU,CAAC,EAAE;MAAA,IAAAiI,WAAA;MACjD,OAAO,IAAIhI,gBAAgB,CAAC;QACxBC,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBqH,MAAM,EAAE,IAAI,CAACA,MAAM,CAACvP,MAAM,CAAC,CACvB,IAAI,CAACmI,IAAI,EACTH,UAAU,CAACE,KAAK,EAChB,GAAGF,UAAU,CAACuH,MAAM,CACvB,CAAC;QACFpH,IAAI,EAAEH,UAAU,CAACG,IAAI;QACrBrG,IAAI,GAAAmO,WAAA,GAAE,IAAI,CAACnO,IAAI,cAAAmO,WAAA,cAAAA,WAAA,GAAIjI,UAAU,CAAClG;MAClC,CAAC,CAAC;IACN,CAAC,MACI;MACD,OAAO,IAAImG,gBAAgB,CAAC;QACxBC,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBqH,MAAM,EAAE,CAAC,GAAG,IAAI,CAACA,MAAM,EAAE,IAAI,CAACpH,IAAI,CAAC;QACnCA,IAAI,EAAEC,iBAAiB,CAACJ,UAAU,CAAC;QACnClG,IAAI,EAAE,IAAI,CAACA;MACf,CAAC,CAAC;IACN;EACJ;EACA;EACA,OAAOkO,kBAAkBA,CAACvD,KAAK,EAAE;IAC7B,OAAO1L,KAAK,CAACC,OAAO,CAACyL,KAAK,CAAC8C,MAAM,CAAC,IAAIrO,QAAQ,CAACsL,UAAU,CAACC,KAAK,CAAC;EACpE;EACA;EACA,OAAOnJ,IAAIA,CAAA4M,KAAA,EAAwBpO,IAAI,EAAE;IAAA,IAA7B,CAACoG,KAAK,EAAE,GAAGiI,SAAS,CAAC,GAAAD,KAAA;IAC7B,OAAO,IAAIjI,gBAAgB,CAAC;MACxBC,KAAK,EAAEE,iBAAiB,CAACF,KAAK,CAAC;MAC/BqH,MAAM,EAAEY,SAAS,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC/N,GAAG,CAAC+F,iBAAiB,CAAC;MACrDD,IAAI,EAAEC,iBAAiB,CAAC+H,SAAS,CAACA,SAAS,CAAChN,MAAM,GAAG,CAAC,CAAC,CAAC;MACxDrB;IACJ,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM6G,WAAW,SAASzH,QAAQ,CAAC;EACtC,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,aAAa;EACxB;EACAsO,YAAYA,CAAA,EAAG;IACX,OAAOhP,MAAM,CAACiH,IAAI,CAAC,IAAI,CAACM,KAAK,CAAC;EAClC;EACAzH,WAAWA,CAACqB,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,OAAO,EAAE;MACjCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAAC+H,KAAK,GAAG,CAAC,CAAC;IACf,KAAK,MAAM,CAACyG,GAAG,EAAExO,KAAK,CAAC,IAAIQ,MAAM,CAACiP,OAAO,CAAC9N,MAAM,CAACoG,KAAK,CAAC,EAAE;MACrD,IAAI,CAACA,KAAK,CAACyG,GAAG,CAAC,GAAGjH,iBAAiB,CAACvH,KAAK,CAAC;IAC9C;EACJ;EACA,OAAOyC,IAAIA,CAACsF,KAAK,EAAE;IACf,OAAO,IAAID,WAAW,CAAC;MAAEC;IAAM,CAAC,CAAC;EACrC;EACA,MAAMtE,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,MAAMwC,gBAAgB,GAAG,MAAMpF,2BAA2B,CAAC4C,OAAO,CAAC;IACnE,MAAMyC,UAAU,GAAG,OAAMD,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEE,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAE;MACvE3B;IACJ,CAAC,EAAEd,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkC,OAAO,CAAC;IAChE;IACA,MAAMW,MAAM,GAAG,CAAC,CAAC;IACjB,IAAI;MACA,MAAMvB,OAAO,CAACC,GAAG,CAACpD,MAAM,CAACiP,OAAO,CAAC,IAAI,CAAC1H,KAAK,CAAC,CAACvG,GAAG,CAAC,MAAAkO,KAAA,IAA2B;QAAA,IAApB,CAAClB,GAAG,EAAEtM,QAAQ,CAAC,GAAAwN,KAAA;QACnExK,MAAM,CAACsJ,GAAG,CAAC,GAAG,MAAMtM,QAAQ,CAACuB,MAAM,CAACJ,KAAK,EAAE1D,WAAW,CAAC0C,OAAO,EAAE;UAC5D+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,YAAA1N,MAAA,CAAYqP,GAAG,CAAE;QACpD,CAAC,CAAC,CAAC;MACP,CAAC,CAAC,CAAC;IACP,CAAC,CACD,OAAOrL,CAAC,EAAE;MACN,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAChC,CAAC,CAAC;MACrC,MAAMA,CAAC;IACX;IACA,OAAM2B,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACF,MAAM,CAAC;IACxC,OAAOA,MAAM;EACjB;EACA,OAAOyK,UAAUA,CAAC1H,SAAS,EAAEnD,UAAU,EAAEzC,OAAO,EAAE;IAC9C;IACA,MAAM0F,KAAK,GAAG;MAAE,GAAG,IAAI,CAACA;IAAM,CAAC;IAC/B;IACA,MAAM6H,WAAW,GAAGxQ,IAAI,CAAC6I,SAAS,EAAEzH,MAAM,CAACiH,IAAI,CAACM,KAAK,CAAC,CAACzF,MAAM,CAAC;IAC9D;IACA,MAAMuN,KAAK,GAAG,IAAIC,GAAG,CAACtP,MAAM,CAACiP,OAAO,CAAC1H,KAAK,CAAC,CAACvG,GAAG,CAAC,CAAAuO,KAAA,EAAkBzM,CAAC,KAAK;MAAA,IAAvB,CAACkL,GAAG,EAAEtM,QAAQ,CAAC,GAAA6N,KAAA;MAC5D,MAAMC,GAAG,GAAG9N,QAAQ,CAAC8F,SAAS,CAAC4H,WAAW,CAACtM,CAAC,CAAC,EAAE3D,WAAW,CAAC0C,OAAO,EAAE;QAChE+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,YAAA1N,MAAA,CAAYqP,GAAG,CAAE;MACpD,CAAC,CAAC,CAAC;MACH,OAAO,CAACA,GAAG,EAAEwB,GAAG,CAACC,IAAI,CAAC,CAAC,CAACC,IAAI,CAAE1M,MAAM,KAAM;QAAEgL,GAAG;QAAEwB,GAAG;QAAExM;MAAO,CAAC,CAAC,CAAC,CAAC;IACrE,CAAC,CAAC,CAAC;IACH;IACA;IACA;IACA,OAAOqM,KAAK,CAACM,IAAI,EAAE;MACf,MAAM;QAAE3B,GAAG;QAAEhL,MAAM;QAAEwM;MAAI,CAAC,GAAG,MAAMrM,OAAO,CAACyM,IAAI,CAACP,KAAK,CAACQ,MAAM,CAAC,CAAC,CAAC;MAC/DR,KAAK,CAACS,MAAM,CAAC9B,GAAG,CAAC;MACjB,IAAI,CAAChL,MAAM,CAAC+M,IAAI,EAAE;QACd,MAAM;UAAE,CAAC/B,GAAG,GAAGhL,MAAM,CAACxD;QAAM,CAAC;QAC7B6P,KAAK,CAACW,GAAG,CAAChC,GAAG,EAAEwB,GAAG,CAACC,IAAI,CAAC,CAAC,CAACC,IAAI,CAAE1M,MAAM,KAAM;UAAEgL,GAAG;UAAEwB,GAAG;UAAExM;QAAO,CAAC,CAAC,CAAC,CAAC;MACvE;IACJ;EACJ;EACAwE,SAASA,CAACC,SAAS,EAAE5F,OAAO,EAAE;IAC1B,OAAO,IAAI,CAACuD,0BAA0B,CAACqC,SAAS,EAAE,IAAI,CAAC0H,UAAU,CAACxO,IAAI,CAAC,IAAI,CAAC,EAAEkB,OAAO,CAAC;EAC1F;EACA,MAAMyB,MAAMA,CAACT,KAAK,EAAEhB,OAAO,EAAE;IACzB,gBAAgB4F,SAASA,CAAA,EAAG;MACxB,MAAM5E,KAAK;IACf;IACA,MAAMU,gBAAgB,GAAG,IAAIzE,uBAAuB,CAAC,IAAI,CAAC0I,SAAS,CAACC,SAAS,CAAC,CAAC,EAAE5F,OAAO,CAAC,CAAC;IAC1F,MAAM0B,gBAAgB,CAACC,KAAK;IAC5B,OAAO9E,sBAAsB,CAAC+E,kBAAkB,CAACF,gBAAgB,CAAC;EACtE;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAM0M,cAAc,SAASpQ,QAAQ,CAAC;EACzC,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,gBAAgB;EAC3B;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;MAChCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAAC2E,IAAI,GAAGhD,MAAM,CAACgD,IAAI;EAC3B;EACA,OAAOlC,IAAIA,CAACkC,IAAI,EAAE;IACd,OAAO,IAAI8L,cAAc,CAAC;MACtB9L;IACJ,CAAC,CAAC;EACN;EACA,MAAMiI,OAAOA,CAACvJ,KAAK,EAAE9B,MAAM,EAAEuD,UAAU,EAAE;IACrC,IAAII,MAAM,GAAG,MAAM,IAAI,CAACP,IAAI,CAACtB,KAAK,EAAE;MAAE,GAAG9B,MAAM;MAAEA;IAAO,CAAC,CAAC;IAC1D,IAAI2D,MAAM,IAAI7E,QAAQ,CAACsL,UAAU,CAACzG,MAAM,CAAC,EAAE;MAAA,IAAAwL,qBAAA;MACvC,IAAI,CAAAnP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEiD,cAAc,MAAK,CAAC,EAAE;QAC9B,MAAM,IAAIhC,KAAK,CAAC,0BAA0B,CAAC;MAC/C;MACA0C,MAAM,GAAG,MAAMA,MAAM,CAACzB,MAAM,CAACJ,KAAK,EAAE1D,WAAW,CAAC4B,MAAM,EAAE;QACpD6C,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAAC,CAAC;QACjCrI,cAAc,EAAE,EAAAkM,qBAAA,GAACnP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEiD,cAAc,cAAAkM,qBAAA,cAAAA,qBAAA,GAAInR,uBAAuB,IAAI;MAC1E,CAAC,CAAC,CAAC;IACP;IACA,OAAO2F,MAAM;EACjB;EACA,MAAMzB,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,OAAO,IAAI,CAACqC,eAAe,CAAC,IAAI,CAACkI,OAAO,EAAEvJ,KAAK,EAAEhB,OAAO,CAAC;EAC7D;EACA,OAAOsN,UAAUA,CAAC1H,SAAS,EAAEnD,UAAU,EAAEvD,MAAM,EAAE;IAC7C,IAAI2G,UAAU;IACd,WAAW,MAAM5B,KAAK,IAAI2B,SAAS,EAAE;MACjC,IAAIC,UAAU,KAAK3F,SAAS,EAAE;QAC1B2F,UAAU,GAAG5B,KAAK;MACtB,CAAC,MACI;QACD;QACA,IAAI;UACA;UACA4B,UAAU,GAAG/I,MAAM,CAAC+I,UAAU,EAAE5B,KAAK,CAAC;QAC1C,CAAC,CACD,OAAOnD,CAAC,EAAE;UACN+E,UAAU,GAAG5B,KAAK;QACtB;MACJ;IACJ;IACA,MAAMpB,MAAM,GAAG,MAAM,IAAI,CAACP,IAAI,CAACuD,UAAU,EAAE;MAAE,GAAG3G,MAAM;MAAEA;IAAO,CAAC,CAAC;IACjE,IAAI2D,MAAM,IAAI7E,QAAQ,CAACsL,UAAU,CAACzG,MAAM,CAAC,EAAE;MAAA,IAAAyL,sBAAA;MACvC,IAAI,CAAApP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEiD,cAAc,MAAK,CAAC,EAAE;QAC9B,MAAM,IAAIhC,KAAK,CAAC,0BAA0B,CAAC;MAC/C;MACA,MAAMsB,MAAM,GAAG,MAAMoB,MAAM,CAACpB,MAAM,CAACoE,UAAU,EAAEvI,WAAW,CAAC4B,MAAM,EAAE;QAC/D6C,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAAC,CAAC;QACjCrI,cAAc,EAAE,EAAAmM,sBAAA,GAACpP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEiD,cAAc,cAAAmM,sBAAA,cAAAA,sBAAA,GAAIpR,uBAAuB,IAAI;MAC1E,CAAC,CAAC,CAAC;MACH,WAAW,MAAM+G,KAAK,IAAIxC,MAAM,EAAE;QAC9B,MAAMwC,KAAK;MACf;IACJ,CAAC,MACI;MACD,MAAMpB,MAAM;IAChB;EACJ;EACA8C,SAASA,CAACC,SAAS,EAAE5F,OAAO,EAAE;IAC1B,OAAO,IAAI,CAACuD,0BAA0B,CAACqC,SAAS,EAAE,IAAI,CAAC0H,UAAU,CAACxO,IAAI,CAAC,IAAI,CAAC,EAAEkB,OAAO,CAAC;EAC1F;EACA,MAAMyB,MAAMA,CAACT,KAAK,EAAEhB,OAAO,EAAE;IACzB,gBAAgB4F,SAASA,CAAA,EAAG;MACxB,MAAM5E,KAAK;IACf;IACA,MAAMU,gBAAgB,GAAG,IAAIzE,uBAAuB,CAAC,IAAI,CAAC0I,SAAS,CAACC,SAAS,CAAC,CAAC,EAAE5F,OAAO,CAAC,CAAC;IAC1F,MAAM0B,gBAAgB,CAACC,KAAK;IAC5B,OAAO9E,sBAAsB,CAAC+E,kBAAkB,CAACF,gBAAgB,CAAC;EACtE;AACJ;AACA,OAAO,MAAM6M,gBAAgB,SAAS9I,WAAW,CAAC;AAElD;AACA;AACA;AACA,OAAO,MAAM7F,qBAAqB,SAAS5B,QAAQ,CAAC;EAChD,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,uBAAuB;EAClC;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACpCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,WAAW,EAAE;MACrCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACkC,QAAQ,GAAGP,MAAM,CAACO,QAAQ;IAC/B,IAAI,CAACC,SAAS,GAAGR,MAAM,CAACQ,SAAS;EACrC;EACA,CAACmN,SAASA,CAAA,EAAG;IACT,MAAM,IAAI,CAACpN,QAAQ;IACnB,KAAK,MAAM2O,QAAQ,IAAI,IAAI,CAAC1O,SAAS,EAAE;MACnC,MAAM0O,QAAQ;IAClB;EACJ;EACA,MAAMpN,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,MAAMwC,gBAAgB,GAAG,MAAMhG,eAAe,CAACiS,SAAS,CAACzO,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE+B,SAAS,EAAE7B,SAAS,EAAEF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEgC,IAAI,EAAE9B,SAAS,EAAEF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEiC,QAAQ,CAAC;IACpI,MAAMQ,UAAU,GAAG,OAAMD,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAEE,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAACsD,KAAK,EAAE,OAAO,CAAC,EAAEd,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkC,OAAO,CAAC;IACvK,IAAIwM,UAAU;IACd,KAAK,MAAM7O,QAAQ,IAAI,IAAI,CAACoN,SAAS,CAAC,CAAC,EAAE;MACrC,IAAI;QACA,MAAMpK,MAAM,GAAG,MAAMhD,QAAQ,CAACuB,MAAM,CAACJ,KAAK,EAAE1D,WAAW,CAAC0C,OAAO,EAAE;UAAE+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAAC;QAAE,CAAC,CAAC,CAAC;QACxG,OAAM/H,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAACmF,MAAM,EAAE,QAAQ,CAAC,CAAC;QACjE,OAAOA,MAAM;MACjB,CAAC,CACD,OAAO/B,CAAC,EAAE;QACN,IAAI4N,UAAU,KAAKxO,SAAS,EAAE;UAC1BwO,UAAU,GAAG5N,CAAC;QAClB;MACJ;IACJ;IACA,IAAI4N,UAAU,KAAKxO,SAAS,EAAE;MAC1B,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;IAC1D;IACA,OAAMsC,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAC4L,UAAU,CAAC;IAC9C,MAAMA,UAAU;EACpB;EACA,MAAMrO,KAAKA,CAACC,MAAM,EAAEN,OAAO,EAAEO,YAAY,EAAE;IACvC,IAAIA,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEc,gBAAgB,EAAE;MAChC,MAAM,IAAIlB,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA,MAAMO,UAAU,GAAG,IAAI,CAACX,eAAe,CAACC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAI,CAAC,CAAC,EAAEM,MAAM,CAACL,MAAM,CAAC;IACrE,MAAMiD,gBAAgB,GAAG,MAAM5B,OAAO,CAACC,GAAG,CAACb,UAAU,CAACvB,GAAG,CAAED,MAAM,IAAK1C,eAAe,CAACiS,SAAS,CAACvP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE6C,SAAS,EAAE7B,SAAS,EAAEhB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE8C,IAAI,EAAE9B,SAAS,EAAEhB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAE+C,QAAQ,CAAC,CAAC,CAAC;IAC1K,MAAMkB,WAAW,GAAG,MAAM7B,OAAO,CAACC,GAAG,CAAC2B,gBAAgB,CAAC/D,GAAG,CAAC,CAACiE,eAAe,EAAEnC,CAAC,KAAKmC,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEV,gBAAgB,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,EAAEjF,aAAa,CAAC4C,MAAM,CAACW,CAAC,CAAC,EAAE,OAAO,CAAC,EAAEf,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAEQ,UAAU,CAACO,CAAC,CAAC,CAACiB,OAAO,CAAC,CAAC,CAAC;IAC3O;IACA,IAAIwM,UAAU;IACd,KAAK,MAAM7O,QAAQ,IAAI,IAAI,CAACoN,SAAS,CAAC,CAAC,EAAE;MACrC,IAAI;QACA,MAAM3J,OAAO,GAAG,MAAMzD,QAAQ,CAACQ,KAAK,CAACC,MAAM,EAAE6C,WAAW,CAAChE,GAAG,CAAC,CAACsD,UAAU,EAAEiK,CAAC,KAAKpP,WAAW,CAACoD,UAAU,CAACgM,CAAC,CAAC,EAAE;UACvG3K,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAAC;QACpC,CAAC,CAAC,CAAC,EAAEjK,YAAY,CAAC;QAClB,MAAMe,OAAO,CAACC,GAAG,CAAC4B,WAAW,CAAChE,GAAG,CAAC,CAACsD,UAAU,EAAExB,CAAC,KAAKwB,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,cAAc,CAACrF,aAAa,CAAC4F,OAAO,CAACrC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;QACtH,OAAOqC,OAAO;MAClB,CAAC,CACD,OAAOxC,CAAC,EAAE;QACN,IAAI4N,UAAU,KAAKxO,SAAS,EAAE;UAC1BwO,UAAU,GAAG5N,CAAC;QAClB;MACJ;IACJ;IACA,IAAI,CAAC4N,UAAU,EAAE;MACb,MAAM,IAAIvO,KAAK,CAAC,sCAAsC,CAAC;IAC3D;IACA,MAAMmB,OAAO,CAACC,GAAG,CAAC4B,WAAW,CAAChE,GAAG,CAAEsD,UAAU,IAAKA,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEK,gBAAgB,CAAC4L,UAAU,CAAC,CAAC,CAAC;IAC5F,MAAMA,UAAU;EACpB;AACJ;AACA;AACA,OAAO,SAASxJ,iBAAiBA,CAACJ,UAAU,EAAE;EAC1C,IAAI,OAAOA,UAAU,KAAK,UAAU,EAAE;IAClC,OAAO,IAAIsJ,cAAc,CAAC;MAAE9L,IAAI,EAAEwC;IAAW,CAAC,CAAC;EACnD,CAAC,MACI,IAAI9G,QAAQ,CAACsL,UAAU,CAACxE,UAAU,CAAC,EAAE;IACtC,OAAOA,UAAU;EACrB,CAAC,MACI,IAAI,CAACjH,KAAK,CAACC,OAAO,CAACgH,UAAU,CAAC,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;IACnE,MAAMmI,SAAS,GAAG,CAAC,CAAC;IACpB,KAAK,MAAM,CAACd,GAAG,EAAExO,KAAK,CAAC,IAAIQ,MAAM,CAACiP,OAAO,CAACtI,UAAU,CAAC,EAAE;MACnDmI,SAAS,CAACd,GAAG,CAAC,GAAGjH,iBAAiB,CAACvH,KAAK,CAAC;IAC7C;IACA,OAAO,IAAI8H,WAAW,CAAC;MACnBC,KAAK,EAAEuH;IACX,CAAC,CAAC;EACN,CAAC,MACI;IACD,MAAM,IAAI9M,KAAK,6EAA6E,CAAC;EACjG;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAMqF,cAAc,SAASxH,QAAQ,CAAC;EACzC,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,gBAAgB;EAC3B;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAChB;IACA,IAAIA,MAAM,YAAYmG,WAAW,EAAE;MAC/B;MACAnG,MAAM,GAAG;QAAEqP,MAAM,EAAErP;MAAO,CAAC;IAC/B;IACA,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACgR,MAAM,GAAGrP,MAAM,CAACqP,MAAM;EAC/B;EACA,MAAMvN,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,MAAM4O,YAAY,GAAG,MAAM,IAAI,CAACD,MAAM,CAACvN,MAAM,CAACJ,KAAK,EAAEhB,OAAO,CAAC;IAC7D,OAAO;MACH,GAAGgB,KAAK;MACR,GAAG4N;IACP,CAAC;EACL;EACA,OAAOtB,UAAUA,CAAC1H,SAAS,EAAEnD,UAAU,EAAEzC,OAAO,EAAE;IAC9C;IACA,MAAM6O,UAAU,GAAG,IAAI,CAACF,MAAM,CAACxB,YAAY,CAAC,CAAC;IAC7C;IACA,MAAM,CAAC2B,cAAc,EAAEC,SAAS,CAAC,GAAGhS,IAAI,CAAC6I,SAAS,CAAC;IACnD;IACA,MAAMoJ,YAAY,GAAG,IAAI,CAACL,MAAM,CAAChJ,SAAS,CAACoJ,SAAS,EAAEzR,WAAW,CAAC0C,OAAO,EAAE;MAAE+B,SAAS,EAAEU,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE+H,QAAQ,CAAC;IAAE,CAAC,CAAC,CAAC;IAClH;IACA,MAAMyE,uBAAuB,GAAGD,YAAY,CAACpB,IAAI,CAAC,CAAC;IACnD;IACA,WAAW,MAAM3J,KAAK,IAAI6K,cAAc,EAAE;MACtC,IAAI,OAAO7K,KAAK,KAAK,QAAQ,IAAIpG,KAAK,CAACC,OAAO,CAACmG,KAAK,CAAC,EAAE;QACnD,MAAM,IAAI9D,KAAK,+DAAArD,MAAA,CAA+D,OAAOmH,KAAK,CAAE,CAAC;MACjG;MACA,MAAMiL,QAAQ,GAAG/Q,MAAM,CAACgR,WAAW,CAAChR,MAAM,CAACiP,OAAO,CAACnJ,KAAK,CAAC,CAACyE,MAAM,CAAC0G,KAAA;QAAA,IAAC,CAACjD,GAAG,CAAC,GAAAiD,KAAA;QAAA,OAAK,CAACP,UAAU,CAACQ,QAAQ,CAAClD,GAAG,CAAC;MAAA,EAAC,CAAC;MACvG,IAAIhO,MAAM,CAACiH,IAAI,CAAC8J,QAAQ,CAAC,CAACjP,MAAM,GAAG,CAAC,EAAE;QAClC,MAAMiP,QAAQ;MAClB;IACJ;IACA;IACA,MAAM,CAAC,MAAMD,uBAAuB,EAAEtR,KAAK;IAC3C,WAAW,MAAMsG,KAAK,IAAI+K,YAAY,EAAE;MACpC,MAAM/K,KAAK;IACf;EACJ;EACA0B,SAASA,CAACC,SAAS,EAAE5F,OAAO,EAAE;IAC1B,OAAO,IAAI,CAACuD,0BAA0B,CAACqC,SAAS,EAAE,IAAI,CAAC0H,UAAU,CAACxO,IAAI,CAAC,IAAI,CAAC,EAAEkB,OAAO,CAAC;EAC1F;EACA,MAAMyB,MAAMA,CAACT,KAAK,EAAEhB,OAAO,EAAE;IACzB,gBAAgB4F,SAASA,CAAA,EAAG;MACxB,MAAM5E,KAAK;IACf;IACA,MAAMU,gBAAgB,GAAG,IAAIzE,uBAAuB,CAAC,IAAI,CAAC0I,SAAS,CAACC,SAAS,CAAC,CAAC,EAAE5F,OAAO,CAAC,CAAC;IAC1F,MAAM0B,gBAAgB,CAACC,KAAK;IAC5B,OAAO9E,sBAAsB,CAAC+E,kBAAkB,CAACF,gBAAgB,CAAC;EACtE;AACJ;AACA;AACA;AACA;AACA,OAAO,MAAM2D,YAAY,SAASrH,QAAQ,CAAC;EACvC,OAAOa,OAAOA,CAAA,EAAG;IACb,OAAO,cAAc;EACzB;EACAZ,WAAWA,CAACqB,MAAM,EAAE;IAChB,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIzB,KAAK,CAACC,OAAO,CAACwB,MAAM,CAAC,EAAE;MACrD;MACAA,MAAM,GAAG;QAAE8F,IAAI,EAAE9F;MAAO,CAAC;IAC7B;IACA,KAAK,CAACA,MAAM,CAAC;IACbnB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,CAAC,gBAAgB,EAAE,WAAW;IACzC,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE;IACX,CAAC,CAAC;IACFQ,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE;MAChCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdZ,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACyH,IAAI,GAAG9F,MAAM,CAAC8F,IAAI;EAC3B;EACA,MAAMkK,KAAKA,CAACtO,KAAK,EAAE;IACf,IAAI,OAAO,IAAI,CAACoE,IAAI,KAAK,QAAQ,EAAE;MAC/B,OAAOpE,KAAK,CAAC,IAAI,CAACoE,IAAI,CAAC;IAC3B,CAAC,MACI;MACD,MAAMmK,MAAM,GAAG,IAAI,CAACnK,IAAI,CACnBjG,GAAG,CAAEgN,GAAG,IAAK,CAACA,GAAG,EAAEnL,KAAK,CAACmL,GAAG,CAAC,CAAC,CAAC,CAC/BzD,MAAM,CAAE8G,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,KAAKtP,SAAS,CAAC;MACtC,OAAOqP,MAAM,CAACtP,MAAM,KAAK,CAAC,GAAGC,SAAS,GAAG/B,MAAM,CAACgR,WAAW,CAACI,MAAM,CAAC;IACvE;EACJ;EACA,MAAMnO,MAAMA,CAACJ,KAAK,EAAEhB,OAAO,EAAE;IACzB,OAAO,IAAI,CAACqC,eAAe,CAAC,IAAI,CAACiN,KAAK,CAACxQ,IAAI,CAAC,IAAI,CAAC,EAAEkC,KAAK,EAAEhB,OAAO,CAAC;EACtE;EACA,OAAOsN,UAAUA,CAAC1H,SAAS,EAAE;IACzB,WAAW,MAAM3B,KAAK,IAAI2B,SAAS,EAAE;MACjC,MAAM2J,MAAM,GAAG,MAAM,IAAI,CAACD,KAAK,CAACrL,KAAK,CAAC;MACtC,IAAIsL,MAAM,KAAKrP,SAAS,EAAE;QACtB,MAAMqP,MAAM;MAChB;IACJ;EACJ;EACA5J,SAASA,CAACC,SAAS,EAAE5F,OAAO,EAAE;IAC1B,OAAO,IAAI,CAACuD,0BAA0B,CAACqC,SAAS,EAAE,IAAI,CAAC0H,UAAU,CAACxO,IAAI,CAAC,IAAI,CAAC,EAAEkB,OAAO,CAAC;EAC1F;EACA,MAAMyB,MAAMA,CAACT,KAAK,EAAEhB,OAAO,EAAE;IACzB,gBAAgB4F,SAASA,CAAA,EAAG;MACxB,MAAM5E,KAAK;IACf;IACA,MAAMU,gBAAgB,GAAG,IAAIzE,uBAAuB,CAAC,IAAI,CAAC0I,SAAS,CAACC,SAAS,CAAC,CAAC,EAAE5F,OAAO,CAAC,CAAC;IAC1F,MAAM0B,gBAAgB,CAACC,KAAK;IAC5B,OAAO9E,sBAAsB,CAAC+E,kBAAkB,CAACF,gBAAgB,CAAC;EACtE;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}