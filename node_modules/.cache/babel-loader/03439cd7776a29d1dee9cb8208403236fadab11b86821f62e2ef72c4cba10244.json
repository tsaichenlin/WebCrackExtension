{"ast":null,"code":"import { Serializable } from \"../load/serializable.js\";\nfunction mergeContent(firstContent, secondContent) {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else {\n      return [{\n        type: \"text\",\n        text: firstContent\n      }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return [...firstContent, ...secondContent];\n    // If the first content is a list and second is a string\n  } else {\n    // Otherwise, add the second content as a new element of the list\n    return [...firstContent, {\n      type: \"text\",\n      text: secondContent\n    }];\n  }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport class BaseMessage extends Serializable {\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\"\n    };\n  }\n  /**\n   * @deprecated\n   * Use {@link BaseMessage.content} instead.\n   */\n  get text() {\n    return typeof this.content === \"string\" ? this.content : \"\";\n  }\n  constructor(fields, /** @deprecated */\n  kwargs) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        content: fields,\n        additional_kwargs: kwargs\n      };\n    }\n    // Make sure the default value for additional_kwargs is passed into super() for serialization\n    if (!fields.additional_kwargs) {\n      // eslint-disable-next-line no-param-reassign\n      fields.additional_kwargs = {};\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"messages\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    /** The content of the message. */\n    Object.defineProperty(this, \"content\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** The name of the message sender in a multi-user chat. */\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** Additional keyword arguments */\n    Object.defineProperty(this, \"additional_kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.content = fields.content;\n    this.additional_kwargs = fields.additional_kwargs;\n  }\n  toDict() {\n    return {\n      type: this._getType(),\n      data: this.toJSON().kwargs\n    };\n  }\n  toChunk() {\n    const type = this._getType();\n    if (type === \"human\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new HumanMessageChunk({\n        ...this\n      });\n    } else if (type === \"ai\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new AIMessageChunk({\n        ...this\n      });\n    } else if (type === \"system\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new SystemMessageChunk({\n        ...this\n      });\n    } else if (type === \"function\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new FunctionMessageChunk({\n        ...this\n      });\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    } else if (ChatMessage.isInstance(this)) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new ChatMessageChunk({\n        ...this\n      });\n    } else {\n      throw new Error(\"Unknown message type.\");\n    }\n  }\n}\nfunction isOpenAIToolCallArray(value) {\n  return Array.isArray(value) && value.every(v => typeof v.index === \"number\");\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport class BaseMessageChunk extends BaseMessage {\n  static _mergeAdditionalKwargs(left, right) {\n    const merged = {\n      ...left\n    };\n    for (const [key, value] of Object.entries(right)) {\n      if (merged[key] === undefined) {\n        merged[key] = value;\n      } else if (typeof merged[key] !== typeof value) {\n        throw new Error(`additional_kwargs[${key}] already exists in the message chunk, but with a different type.`);\n      } else if (typeof merged[key] === \"string\") {\n        merged[key] = merged[key] + value;\n      } else if (!Array.isArray(merged[key]) && typeof merged[key] === \"object\") {\n        merged[key] = this._mergeAdditionalKwargs(merged[key], value);\n      } else if (key === \"tool_calls\" && isOpenAIToolCallArray(merged[key]) && isOpenAIToolCallArray(value)) {\n        for (const toolCall of value) {\n          if (merged[key]?.[toolCall.index] !== undefined) {\n            merged[key] = merged[key]?.map((value, i) => {\n              if (i !== toolCall.index) {\n                return value;\n              }\n              return {\n                ...value,\n                ...toolCall,\n                function: {\n                  name: toolCall.function.name ?? value.function.name,\n                  arguments: (value.function.arguments ?? \"\") + (toolCall.function.arguments ?? \"\")\n                }\n              };\n            });\n          } else {\n            merged[key][toolCall.index] = toolCall;\n          }\n        }\n      } else {\n        throw new Error(`additional_kwargs[${key}] already exists in this message chunk.`);\n      }\n    }\n    return merged;\n  }\n}\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage extends BaseMessage {\n  static lc_name() {\n    return \"HumanMessage\";\n  }\n  _getType() {\n    return \"human\";\n  }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"HumanMessageChunk\";\n  }\n  _getType() {\n    return \"human\";\n  }\n  concat(chunk) {\n    return new HumanMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: HumanMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)\n    });\n  }\n}\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n  static lc_name() {\n    return \"AIMessage\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n  concat(chunk) {\n    return new AIMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: AIMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)\n    });\n  }\n}\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage extends BaseMessage {\n  static lc_name() {\n    return \"SystemMessage\";\n  }\n  _getType() {\n    return \"system\";\n  }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"SystemMessageChunk\";\n  }\n  _getType() {\n    return \"system\";\n  }\n  concat(chunk) {\n    return new SystemMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: SystemMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)\n    });\n  }\n}\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage extends BaseMessage {\n  static lc_name() {\n    return \"FunctionMessage\";\n  }\n  constructor(fields, /** @deprecated */\n  name) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        name: name\n      };\n    }\n    super(fields);\n  }\n  _getType() {\n    return \"function\";\n  }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"FunctionMessageChunk\";\n  }\n  _getType() {\n    return \"function\";\n  }\n  concat(chunk) {\n    return new FunctionMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: FunctionMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n      name: this.name ?? \"\"\n    });\n  }\n}\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage extends BaseMessage {\n  static lc_name() {\n    return \"ToolMessage\";\n  }\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      tool_call_id: \"tool_call_id\"\n    };\n  }\n  constructor(fields, tool_call_id, name) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        name,\n        tool_call_id: tool_call_id\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"tool_call_id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_id = fields.tool_call_id;\n  }\n  _getType() {\n    return \"tool\";\n  }\n  static isInstance(message) {\n    return message._getType() === \"tool\";\n  }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk extends BaseMessageChunk {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"tool_call_id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_id = fields.tool_call_id;\n  }\n  static lc_name() {\n    return \"ToolMessageChunk\";\n  }\n  _getType() {\n    return \"tool\";\n  }\n  concat(chunk) {\n    return new ToolMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: ToolMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n      tool_call_id: this.tool_call_id\n    });\n  }\n}\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage extends BaseMessage {\n  static lc_name() {\n    return \"ChatMessage\";\n  }\n  static _chatMessageClass() {\n    return ChatMessage;\n  }\n  constructor(fields, role) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        role: role\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"role\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.role = fields.role;\n  }\n  _getType() {\n    return \"generic\";\n  }\n  static isInstance(message) {\n    return message._getType() === \"generic\";\n  }\n}\nexport function isBaseMessage(messageLike) {\n  return typeof messageLike?._getType === \"function\";\n}\nexport function isBaseMessageChunk(messageLike) {\n  return isBaseMessage(messageLike) && typeof messageLike.concat === \"function\";\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  const [type, content] = messageLike;\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage({\n      content\n    });\n  } else if (type === \"ai\" || type === \"assistant\") {\n    return new AIMessage({\n      content\n    });\n  } else if (type === \"system\") {\n    return new SystemMessage({\n      content\n    });\n  } else {\n    throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n  }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"ChatMessageChunk\";\n  }\n  constructor(fields, role) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        role: role\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"role\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.role = fields.role;\n  }\n  _getType() {\n    return \"generic\";\n  }\n  concat(chunk) {\n    return new ChatMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: ChatMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n      role: this.role\n    });\n  }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    string_messages.push(`${role}: ${nameStr}${m.content}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if (message.data !== undefined) {\n    return message;\n  } else {\n    const v1Message = message;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined\n      }\n    };\n  }\n}\nexport function mapStoredMessageToChatMessage(message) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data);\n    case \"chat\":\n      {\n        if (storedMessage.data.role === undefined) {\n          throw new Error(\"Role must be defined for chat messages\");\n        }\n        return new ChatMessage(storedMessage.data);\n      }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n  return messages.map(message => message.toDict());\n}","map":{"version":3,"names":["Serializable","mergeContent","firstContent","secondContent","type","text","Array","isArray","BaseMessage","lc_aliases","additional_kwargs","content","constructor","fields","kwargs","Object","defineProperty","enumerable","configurable","writable","value","name","toDict","_getType","data","toJSON","toChunk","HumanMessageChunk","AIMessageChunk","SystemMessageChunk","FunctionMessageChunk","ChatMessage","isInstance","ChatMessageChunk","Error","isOpenAIToolCallArray","every","v","index","BaseMessageChunk","_mergeAdditionalKwargs","left","right","merged","key","entries","undefined","toolCall","map","i","function","arguments","HumanMessage","lc_name","concat","chunk","AIMessage","SystemMessage","FunctionMessage","ToolMessage","tool_call_id","message","ToolMessageChunk","_chatMessageClass","role","isBaseMessage","messageLike","isBaseMessageChunk","coerceMessageLikeToMessage","getBufferString","messages","humanPrefix","aiPrefix","string_messages","m","nameStr","push","join","mapV1MessageToStoredMessage","v1Message","mapStoredMessageToChatMessage","storedMessage","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/messages/index.js"],"sourcesContent":["import { Serializable } from \"../load/serializable.js\";\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return [...firstContent, ...secondContent];\n        // If the first content is a list and second is a string\n    }\n    else {\n        // Otherwise, add the second content as a new element of the list\n        return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport class BaseMessage extends Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { additional_kwargs: \"additional_kwargs\" };\n    }\n    /**\n     * @deprecated\n     * Use {@link BaseMessage.content} instead.\n     */\n    get text() {\n        return typeof this.content === \"string\" ? this.content : \"\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = { content: fields, additional_kwargs: kwargs };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    toChunk() {\n        const type = this._getType();\n        if (type === \"human\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new HumanMessageChunk({ ...this });\n        }\n        else if (type === \"ai\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new AIMessageChunk({ ...this });\n        }\n        else if (type === \"system\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new SystemMessageChunk({ ...this });\n        }\n        else if (type === \"function\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new FunctionMessageChunk({ ...this });\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        }\n        else if (ChatMessage.isInstance(this)) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new ChatMessageChunk({ ...this });\n        }\n        else {\n            throw new Error(\"Unknown message type.\");\n        }\n    }\n}\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport class BaseMessageChunk extends BaseMessage {\n    static _mergeAdditionalKwargs(left, right) {\n        const merged = { ...left };\n        for (const [key, value] of Object.entries(right)) {\n            if (merged[key] === undefined) {\n                merged[key] = value;\n            }\n            else if (typeof merged[key] !== typeof value) {\n                throw new Error(`additional_kwargs[${key}] already exists in the message chunk, but with a different type.`);\n            }\n            else if (typeof merged[key] === \"string\") {\n                merged[key] = merged[key] + value;\n            }\n            else if (!Array.isArray(merged[key]) &&\n                typeof merged[key] === \"object\") {\n                merged[key] = this._mergeAdditionalKwargs(merged[key], value);\n            }\n            else if (key === \"tool_calls\" &&\n                isOpenAIToolCallArray(merged[key]) &&\n                isOpenAIToolCallArray(value)) {\n                for (const toolCall of value) {\n                    if (merged[key]?.[toolCall.index] !== undefined) {\n                        merged[key] = merged[key]?.map((value, i) => {\n                            if (i !== toolCall.index) {\n                                return value;\n                            }\n                            return {\n                                ...value,\n                                ...toolCall,\n                                function: {\n                                    name: toolCall.function.name ?? value.function.name,\n                                    arguments: (value.function.arguments ?? \"\") +\n                                        (toolCall.function.arguments ?? \"\"),\n                                },\n                            };\n                        });\n                    }\n                    else {\n                        merged[key][toolCall.index] = toolCall;\n                    }\n                }\n            }\n            else {\n                throw new Error(`additional_kwargs[${key}] already exists in this message chunk.`);\n            }\n        }\n        return merged;\n    }\n}\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage extends BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: HumanMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n        });\n    }\n}\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    concat(chunk) {\n        return new AIMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: AIMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n        });\n    }\n}\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage extends BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: SystemMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n        });\n    }\n}\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage extends BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: FunctionMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n            name: this.name ?? \"\",\n        });\n    }\n}\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage extends BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk extends BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: ToolMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n            tool_call_id: this.tool_call_id,\n        });\n    }\n}\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage extends BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n}\nexport function isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nexport function isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new HumanMessage(messageLike);\n    }\n    else if (isBaseMessage(messageLike)) {\n        return messageLike;\n    }\n    const [type, content] = messageLike;\n    if (type === \"human\" || type === \"user\") {\n        return new HumanMessage({ content });\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        return new AIMessage({ content });\n    }\n    else if (type === \"system\") {\n        return new SystemMessage({ content });\n    }\n    else {\n        throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n    }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: ChatMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n            role: this.role,\n        });\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nexport function mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new AIMessage(storedMessage.data);\n        case \"system\":\n            return new SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new ToolMessage(storedMessage.data);\n        case \"chat\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}