{"ast":null,"code":"import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n  return CallbackManager.configure(config === null || config === void 0 ? void 0 : config.callbacks, undefined, config === null || config === void 0 ? void 0 : config.tags, undefined, config === null || config === void 0 ? void 0 : config.metadata);\n}\nexport function mergeConfigs() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const copy = ensureConfig();\n  for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {\n    configs[_key] = arguments[_key];\n  }\n  for (const options of configs.filter(c => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"tags\") {\n        var _options$key;\n        copy[key] = [...new Set(copy[key].concat((_options$key = options[key]) !== null && _options$key !== void 0 ? _options$key : []))];\n      } else if (key === \"configurable\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n              metadata: {\n                ...baseCallbacks.metadata,\n                ...providedCallbacks.metadata\n              }\n            });\n          }\n        }\n      } else {\n        var _options$typedKey;\n        const typedKey = key;\n        copy[typedKey] = (_options$typedKey = options[typedKey]) !== null && _options$typedKey !== void 0 ? _options$typedKey : copy[typedKey];\n      }\n    }\n  }\n  return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig(config) {\n  let empty = {\n    tags: [],\n    metadata: {},\n    callbacks: undefined,\n    recursionLimit: 25\n  };\n  if (config) {\n    empty = {\n      ...empty,\n      ...config\n    };\n  }\n  if (config !== null && config !== void 0 && config.configurable) {\n    for (const key of Object.keys(config.configurable)) {\n      var _empty$metadata;\n      if (PRIMITIVES.has(typeof config.configurable[key]) && !((_empty$metadata = empty.metadata) !== null && _empty$metadata !== void 0 && _empty$metadata[key])) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = config.configurable[key];\n      }\n    }\n  }\n  return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    callbacks,\n    maxConcurrency,\n    recursionLimit,\n    runName,\n    configurable\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = {\n      ...newConfig.configurable,\n      ...configurable\n    };\n  }\n  return newConfig;\n}","map":{"version":3,"names":["CallbackManager","ensureHandler","DEFAULT_RECURSION_LIMIT","getCallbackManagerForConfig","config","configure","callbacks","undefined","tags","metadata","mergeConfigs","copy","ensureConfig","_len","arguments","length","configs","Array","_key","options","filter","c","key","Object","keys","_options$key","Set","concat","baseCallbacks","providedCallbacks","isArray","manager","callback","addHandler","_parentRunId","handlers","inheritableHandlers","from","inheritableTags","_options$typedKey","typedKey","PRIMITIVES","empty","recursionLimit","configurable","_empty$metadata","has","patchConfig","maxConcurrency","runName","newConfig"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/config.js"],"sourcesContent":["import { CallbackManager, ensureHandler, } from \"../callbacks/manager.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n    return CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const copy = ensureConfig();\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                copy[key] = [...new Set(copy[key].concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig(config) {\n    let empty = {\n        tags: [],\n        metadata: {},\n        callbacks: undefined,\n        recursionLimit: 25,\n    };\n    if (config) {\n        empty = { ...empty, ...config };\n    }\n    if (config?.configurable) {\n        for (const key of Object.keys(config.configurable)) {\n            if (PRIMITIVES.has(typeof config.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = config.configurable[key];\n            }\n        }\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    return newConfig;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}