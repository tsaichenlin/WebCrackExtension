{"ast":null,"code":"import { deepCompareStrict } from \"./deep-compare-strict.js\";\nimport { dereference } from \"./dereference.js\";\nimport { fastFormat } from \"./format.js\";\nimport { encodePointer } from \"./pointer.js\";\nimport { ucs2length } from \"./ucs2-length.js\";\nexport function validate(instance, schema, draft = \"2019-09\", lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = \"#\", schemaLocation = \"#\", evaluated = Object.create(null)) {\n  if (schema === true) {\n    return {\n      valid: true,\n      errors: []\n    };\n  }\n  if (schema === false) {\n    return {\n      valid: false,\n      errors: [{\n        instanceLocation,\n        keyword: \"false\",\n        keywordLocation: instanceLocation,\n        error: \"False boolean schema.\"\n      }]\n    };\n  }\n  const rawInstanceType = typeof instance;\n  let instanceType;\n  switch (rawInstanceType) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      instanceType = rawInstanceType;\n      break;\n    case \"object\":\n      if (instance === null) {\n        instanceType = \"null\";\n      } else if (Array.isArray(instance)) {\n        instanceType = \"array\";\n      } else {\n        instanceType = \"object\";\n      }\n      break;\n    default:\n      // undefined, bigint, function, symbol\n      throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n  }\n  const {\n    $ref,\n    $recursiveRef,\n    $recursiveAnchor,\n    type: $type,\n    const: $const,\n    enum: $enum,\n    required: $required,\n    not: $not,\n    anyOf: $anyOf,\n    allOf: $allOf,\n    oneOf: $oneOf,\n    if: $if,\n    then: $then,\n    else: $else,\n    format: $format,\n    properties: $properties,\n    patternProperties: $patternProperties,\n    additionalProperties: $additionalProperties,\n    unevaluatedProperties: $unevaluatedProperties,\n    minProperties: $minProperties,\n    maxProperties: $maxProperties,\n    propertyNames: $propertyNames,\n    dependentRequired: $dependentRequired,\n    dependentSchemas: $dependentSchemas,\n    dependencies: $dependencies,\n    prefixItems: $prefixItems,\n    items: $items,\n    additionalItems: $additionalItems,\n    unevaluatedItems: $unevaluatedItems,\n    contains: $contains,\n    minContains: $minContains,\n    maxContains: $maxContains,\n    minItems: $minItems,\n    maxItems: $maxItems,\n    uniqueItems: $uniqueItems,\n    minimum: $minimum,\n    maximum: $maximum,\n    exclusiveMinimum: $exclusiveMinimum,\n    exclusiveMaximum: $exclusiveMaximum,\n    multipleOf: $multipleOf,\n    minLength: $minLength,\n    maxLength: $maxLength,\n    pattern: $pattern,\n    __absolute_ref__,\n    __absolute_recursive_ref__\n  } = schema;\n  const errors = [];\n  if ($recursiveAnchor === true && recursiveAnchor === null) {\n    recursiveAnchor = schema;\n  }\n  if ($recursiveRef === \"#\") {\n    const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;\n    const keywordLocation = `${schemaLocation}/$recursiveRef`;\n    const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"$recursiveRef\",\n        keywordLocation,\n        error: \"A subschema had errors.\"\n      }, ...result.errors);\n    }\n  }\n  if ($ref !== undefined) {\n    const uri = __absolute_ref__ || $ref;\n    const refSchema = lookup[uri];\n    if (refSchema === undefined) {\n      let message = `Unresolved $ref \"${$ref}\".`;\n      if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n        message += `  Absolute URI \"${__absolute_ref__}\".`;\n      }\n      message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join(\"\\n- \")}`;\n      throw new Error(message);\n    }\n    const keywordLocation = `${schemaLocation}/$ref`;\n    const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"$ref\",\n        keywordLocation,\n        error: \"A subschema had errors.\"\n      }, ...result.errors);\n    }\n    if (draft === \"4\" || draft === \"7\") {\n      return {\n        valid: errors.length === 0,\n        errors\n      };\n    }\n  }\n  if (Array.isArray($type)) {\n    let length = $type.length;\n    let valid = false;\n    for (let i = 0; i < length; i++) {\n      if (instanceType === $type[i] || $type[i] === \"integer\" && instanceType === \"number\" && instance % 1 === 0 && instance === instance) {\n        valid = true;\n        break;\n      }\n    }\n    if (!valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"type\",\n        keywordLocation: `${schemaLocation}/type`,\n        error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`\n      });\n    }\n  } else if ($type === \"integer\") {\n    if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n      errors.push({\n        instanceLocation,\n        keyword: \"type\",\n        keywordLocation: `${schemaLocation}/type`,\n        error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n      });\n    }\n  } else if ($type !== undefined && instanceType !== $type) {\n    errors.push({\n      instanceLocation,\n      keyword: \"type\",\n      keywordLocation: `${schemaLocation}/type`,\n      error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n    });\n  }\n  if ($const !== undefined) {\n    if (instanceType === \"object\" || instanceType === \"array\") {\n      if (!deepCompareStrict(instance, $const)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"const\",\n          keywordLocation: `${schemaLocation}/const`,\n          error: `Instance does not match ${JSON.stringify($const)}.`\n        });\n      }\n    } else if (instance !== $const) {\n      errors.push({\n        instanceLocation,\n        keyword: \"const\",\n        keywordLocation: `${schemaLocation}/const`,\n        error: `Instance does not match ${JSON.stringify($const)}.`\n      });\n    }\n  }\n  if ($enum !== undefined) {\n    if (instanceType === \"object\" || instanceType === \"array\") {\n      if (!$enum.some(value => deepCompareStrict(instance, value))) {\n        errors.push({\n          instanceLocation,\n          keyword: \"enum\",\n          keywordLocation: `${schemaLocation}/enum`,\n          error: `Instance does not match any of ${JSON.stringify($enum)}.`\n        });\n      }\n    } else if (!$enum.some(value => instance === value)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"enum\",\n        keywordLocation: `${schemaLocation}/enum`,\n        error: `Instance does not match any of ${JSON.stringify($enum)}.`\n      });\n    }\n  }\n  if ($not !== undefined) {\n    const keywordLocation = `${schemaLocation}/not`;\n    const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation /*,\n                                                                                                                            evaluated*/);\n    if (result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"not\",\n        keywordLocation,\n        error: 'Instance matched \"not\" schema.'\n      });\n    }\n  }\n  let subEvaluateds = [];\n  if ($anyOf !== undefined) {\n    const keywordLocation = `${schemaLocation}/anyOf`;\n    const errorsLength = errors.length;\n    let anyValid = false;\n    for (let i = 0; i < $anyOf.length; i++) {\n      const subSchema = $anyOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      anyValid = anyValid || result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (anyValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"anyOf\",\n        keywordLocation,\n        error: \"Instance does not match any subschemas.\"\n      });\n    }\n  }\n  if ($allOf !== undefined) {\n    const keywordLocation = `${schemaLocation}/allOf`;\n    const errorsLength = errors.length;\n    let allValid = true;\n    for (let i = 0; i < $allOf.length; i++) {\n      const subSchema = $allOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      allValid = allValid && result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (allValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"allOf\",\n        keywordLocation,\n        error: `Instance does not match every subschema.`\n      });\n    }\n  }\n  if ($oneOf !== undefined) {\n    const keywordLocation = `${schemaLocation}/oneOf`;\n    const errorsLength = errors.length;\n    const matches = $oneOf.filter((subSchema, i) => {\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n      return result.valid;\n    }).length;\n    if (matches === 1) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"oneOf\",\n        keywordLocation,\n        error: `Instance does not match exactly one subschema (${matches} matches).`\n      });\n    }\n  }\n  if (instanceType === \"object\" || instanceType === \"array\") {\n    Object.assign(evaluated, ...subEvaluateds);\n  }\n  if ($if !== undefined) {\n    const keywordLocation = `${schemaLocation}/if`;\n    const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n    if (conditionResult) {\n      if ($then !== undefined) {\n        const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n        if (!thenResult.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"if\",\n            keywordLocation,\n            error: `Instance does not match \"then\" schema.`\n          }, ...thenResult.errors);\n        }\n      }\n    } else if ($else !== undefined) {\n      const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n      if (!elseResult.valid) {\n        errors.push({\n          instanceLocation,\n          keyword: \"if\",\n          keywordLocation,\n          error: `Instance does not match \"else\" schema.`\n        }, ...elseResult.errors);\n      }\n    }\n  }\n  if (instanceType === \"object\") {\n    if ($required !== undefined) {\n      for (const key of $required) {\n        if (!(key in instance)) {\n          errors.push({\n            instanceLocation,\n            keyword: \"required\",\n            keywordLocation: `${schemaLocation}/required`,\n            error: `Instance does not have required property \"${key}\".`\n          });\n        }\n      }\n    }\n    const keys = Object.keys(instance);\n    if ($minProperties !== undefined && keys.length < $minProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minProperties\",\n        keywordLocation: `${schemaLocation}/minProperties`,\n        error: `Instance does not have at least ${$minProperties} properties.`\n      });\n    }\n    if ($maxProperties !== undefined && keys.length > $maxProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxProperties\",\n        keywordLocation: `${schemaLocation}/maxProperties`,\n        error: `Instance does not have at least ${$maxProperties} properties.`\n      });\n    }\n    if ($propertyNames !== undefined) {\n      const keywordLocation = `${schemaLocation}/propertyNames`;\n      for (const key in instance) {\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"propertyNames\",\n            keywordLocation,\n            error: `Property name \"${key}\" does not match schema.`\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($dependentRequired !== undefined) {\n      const keywordLocation = `${schemaLocation}/dependantRequired`;\n      for (const key in $dependentRequired) {\n        if (key in instance) {\n          const required = $dependentRequired[key];\n          for (const dependantKey of required) {\n            if (!(dependantKey in instance)) {\n              errors.push({\n                instanceLocation,\n                keyword: \"dependentRequired\",\n                keywordLocation,\n                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n              });\n            }\n          }\n        }\n      }\n    }\n    if ($dependentSchemas !== undefined) {\n      for (const key in $dependentSchemas) {\n        const keywordLocation = `${schemaLocation}/dependentSchemas`;\n        if (key in instance) {\n          const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n          if (!result.valid) {\n            errors.push({\n              instanceLocation,\n              keyword: \"dependentSchemas\",\n              keywordLocation,\n              error: `Instance has \"${key}\" but does not match dependant schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($dependencies !== undefined) {\n      const keywordLocation = `${schemaLocation}/dependencies`;\n      for (const key in $dependencies) {\n        if (key in instance) {\n          const propsOrSchema = $dependencies[key];\n          if (Array.isArray(propsOrSchema)) {\n            for (const dependantKey of propsOrSchema) {\n              if (!(dependantKey in instance)) {\n                errors.push({\n                  instanceLocation,\n                  keyword: \"dependencies\",\n                  keywordLocation,\n                  error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                });\n              }\n            }\n          } else {\n            const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n            if (!result.valid) {\n              errors.push({\n                instanceLocation,\n                keyword: \"dependencies\",\n                keywordLocation,\n                error: `Instance has \"${key}\" but does not match dependant schema.`\n              }, ...result.errors);\n            }\n          }\n        }\n      }\n    }\n    const thisEvaluated = Object.create(null);\n    let stop = false;\n    if ($properties !== undefined) {\n      const keywordLocation = `${schemaLocation}/properties`;\n      for (const key in $properties) {\n        if (!(key in instance)) {\n          continue;\n        }\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n        if (result.valid) {\n          evaluated[key] = thisEvaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"properties\",\n            keywordLocation,\n            error: `Property \"${key}\" does not match schema.`\n          }, ...result.errors);\n          if (stop) break;\n        }\n      }\n    }\n    if (!stop && $patternProperties !== undefined) {\n      const keywordLocation = `${schemaLocation}/patternProperties`;\n      for (const pattern in $patternProperties) {\n        const regex = new RegExp(pattern);\n        const subSchema = $patternProperties[pattern];\n        for (const key in instance) {\n          if (!regex.test(key)) {\n            continue;\n          }\n          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n          const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n          if (result.valid) {\n            evaluated[key] = thisEvaluated[key] = true;\n          } else {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"patternProperties\",\n              keywordLocation,\n              error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if (!stop && $additionalProperties !== undefined) {\n      const keywordLocation = `${schemaLocation}/additionalProperties`;\n      for (const key in instance) {\n        if (thisEvaluated[key]) {\n          continue;\n        }\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (result.valid) {\n          evaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"additionalProperties\",\n            keywordLocation,\n            error: `Property \"${key}\" does not match additional properties schema.`\n          }, ...result.errors);\n        }\n      }\n    } else if (!stop && $unevaluatedProperties !== undefined) {\n      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n      for (const key in instance) {\n        if (!evaluated[key]) {\n          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n          const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n          if (result.valid) {\n            evaluated[key] = true;\n          } else {\n            errors.push({\n              instanceLocation,\n              keyword: \"unevaluatedProperties\",\n              keywordLocation,\n              error: `Property \"${key}\" does not match unevaluated properties schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n  } else if (instanceType === \"array\") {\n    if ($maxItems !== undefined && instance.length > $maxItems) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxItems\",\n        keywordLocation: `${schemaLocation}/maxItems`,\n        error: `Array has too many items (${instance.length} > ${$maxItems}).`\n      });\n    }\n    if ($minItems !== undefined && instance.length < $minItems) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minItems\",\n        keywordLocation: `${schemaLocation}/minItems`,\n        error: `Array has too few items (${instance.length} < ${$minItems}).`\n      });\n    }\n    const length = instance.length;\n    let i = 0;\n    let stop = false;\n    if ($prefixItems !== undefined) {\n      const keywordLocation = `${schemaLocation}/prefixItems`;\n      const length2 = Math.min($prefixItems.length, length);\n      for (; i < length2; i++) {\n        const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n        evaluated[i] = true;\n        if (!result.valid) {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"prefixItems\",\n            keywordLocation,\n            error: `Items did not match schema.`\n          }, ...result.errors);\n          if (stop) break;\n        }\n      }\n    }\n    if ($items !== undefined) {\n      const keywordLocation = `${schemaLocation}/items`;\n      if (Array.isArray($items)) {\n        const length2 = Math.min($items.length, length);\n        for (; i < length2; i++) {\n          const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"items\",\n              keywordLocation,\n              error: `Items did not match schema.`\n            }, ...result.errors);\n            if (stop) break;\n          }\n        }\n      } else {\n        for (; i < length; i++) {\n          const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"items\",\n              keywordLocation,\n              error: `Items did not match schema.`\n            }, ...result.errors);\n            if (stop) break;\n          }\n        }\n      }\n      if (!stop && $additionalItems !== undefined) {\n        const keywordLocation = `${schemaLocation}/additionalItems`;\n        for (; i < length; i++) {\n          const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"additionalItems\",\n              keywordLocation,\n              error: `Items did not match additional items schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($contains !== undefined) {\n      if (length === 0 && $minContains === undefined) {\n        errors.push({\n          instanceLocation,\n          keyword: \"contains\",\n          keywordLocation: `${schemaLocation}/contains`,\n          error: `Array is empty. It must contain at least one item matching the schema.`\n        });\n      } else if ($minContains !== undefined && length < $minContains) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minContains\",\n          keywordLocation: `${schemaLocation}/minContains`,\n          error: `Array has less items (${length}) than minContains (${$minContains}).`\n        });\n      } else {\n        const keywordLocation = `${schemaLocation}/contains`;\n        const errorsLength = errors.length;\n        let contained = 0;\n        for (let j = 0; j < length; j++) {\n          const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n          if (result.valid) {\n            evaluated[j] = true;\n            contained++;\n          } else {\n            errors.push(...result.errors);\n          }\n        }\n        if (contained >= ($minContains || 0)) {\n          errors.length = errorsLength;\n        }\n        if ($minContains === undefined && $maxContains === undefined && contained === 0) {\n          errors.splice(errorsLength, 0, {\n            instanceLocation,\n            keyword: \"contains\",\n            keywordLocation,\n            error: `Array does not contain item matching schema.`\n          });\n        } else if ($minContains !== undefined && contained < $minContains) {\n          errors.push({\n            instanceLocation,\n            keyword: \"minContains\",\n            keywordLocation: `${schemaLocation}/minContains`,\n            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`\n          });\n        } else if ($maxContains !== undefined && contained > $maxContains) {\n          errors.push({\n            instanceLocation,\n            keyword: \"maxContains\",\n            keywordLocation: `${schemaLocation}/maxContains`,\n            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`\n          });\n        }\n      }\n    }\n    if (!stop && $unevaluatedItems !== undefined) {\n      const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n      for (i; i < length; i++) {\n        if (evaluated[i]) {\n          continue;\n        }\n        const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n        evaluated[i] = true;\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"unevaluatedItems\",\n            keywordLocation,\n            error: `Items did not match unevaluated items schema.`\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($uniqueItems) {\n      for (let j = 0; j < length; j++) {\n        const a = instance[j];\n        const ao = typeof a === \"object\" && a !== null;\n        for (let k = 0; k < length; k++) {\n          if (j === k) {\n            continue;\n          }\n          const b = instance[k];\n          const bo = typeof b === \"object\" && b !== null;\n          if (a === b || ao && bo && deepCompareStrict(a, b)) {\n            errors.push({\n              instanceLocation,\n              keyword: \"uniqueItems\",\n              keywordLocation: `${schemaLocation}/uniqueItems`,\n              error: `Duplicate items at indexes ${j} and ${k}.`\n            });\n            j = Number.MAX_SAFE_INTEGER;\n            k = Number.MAX_SAFE_INTEGER;\n          }\n        }\n      }\n    }\n  } else if (instanceType === \"number\") {\n    if (draft === \"4\") {\n      if ($minimum !== undefined && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minimum\",\n          keywordLocation: `${schemaLocation}/minimum`,\n          error: `${instance} is less than ${$exclusiveMinimum ? \"or equal to \" : \"\"} ${$minimum}.`\n        });\n      }\n      if ($maximum !== undefined && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"maximum\",\n          keywordLocation: `${schemaLocation}/maximum`,\n          error: `${instance} is greater than ${$exclusiveMaximum ? \"or equal to \" : \"\"} ${$maximum}.`\n        });\n      }\n    } else {\n      if ($minimum !== undefined && instance < $minimum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minimum\",\n          keywordLocation: `${schemaLocation}/minimum`,\n          error: `${instance} is less than ${$minimum}.`\n        });\n      }\n      if ($maximum !== undefined && instance > $maximum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"maximum\",\n          keywordLocation: `${schemaLocation}/maximum`,\n          error: `${instance} is greater than ${$maximum}.`\n        });\n      }\n      if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"exclusiveMinimum\",\n          keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n          error: `${instance} is less than ${$exclusiveMinimum}.`\n        });\n      }\n      if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"exclusiveMaximum\",\n          keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`\n        });\n      }\n    }\n    if ($multipleOf !== undefined) {\n      const remainder = instance % $multipleOf;\n      if (Math.abs(0 - remainder) >= 1.1920929e-7 && Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n        errors.push({\n          instanceLocation,\n          keyword: \"multipleOf\",\n          keywordLocation: `${schemaLocation}/multipleOf`,\n          error: `${instance} is not a multiple of ${$multipleOf}.`\n        });\n      }\n    }\n  } else if (instanceType === \"string\") {\n    const length = $minLength === undefined && $maxLength === undefined ? 0 : ucs2length(instance);\n    if ($minLength !== undefined && length < $minLength) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minLength\",\n        keywordLocation: `${schemaLocation}/minLength`,\n        error: `String is too short (${length} < ${$minLength}).`\n      });\n    }\n    if ($maxLength !== undefined && length > $maxLength) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxLength\",\n        keywordLocation: `${schemaLocation}/maxLength`,\n        error: `String is too long (${length} > ${$maxLength}).`\n      });\n    }\n    if ($pattern !== undefined && !new RegExp($pattern).test(instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"pattern\",\n        keywordLocation: `${schemaLocation}/pattern`,\n        error: `String does not match pattern.`\n      });\n    }\n    if ($format !== undefined && fastFormat[$format] && !fastFormat[$format](instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"format\",\n        keywordLocation: `${schemaLocation}/format`,\n        error: `String does not match format \"${$format}\".`\n      });\n    }\n  }\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}","map":{"version":3,"names":["deepCompareStrict","dereference","fastFormat","encodePointer","ucs2length","validate","instance","schema","draft","lookup","shortCircuit","recursiveAnchor","instanceLocation","schemaLocation","evaluated","Object","create","valid","errors","keyword","keywordLocation","error","rawInstanceType","instanceType","Array","isArray","Error","$ref","$recursiveRef","$recursiveAnchor","type","$type","const","$const","enum","$enum","required","$required","not","$not","anyOf","$anyOf","allOf","$allOf","oneOf","$oneOf","if","$if","then","$then","else","$else","format","$format","properties","$properties","patternProperties","$patternProperties","additionalProperties","$additionalProperties","unevaluatedProperties","$unevaluatedProperties","minProperties","$minProperties","maxProperties","$maxProperties","propertyNames","$propertyNames","dependentRequired","$dependentRequired","dependentSchemas","$dependentSchemas","dependencies","$dependencies","prefixItems","$prefixItems","items","$items","additionalItems","$additionalItems","unevaluatedItems","$unevaluatedItems","contains","$contains","minContains","$minContains","maxContains","$maxContains","minItems","$minItems","maxItems","$maxItems","uniqueItems","$uniqueItems","minimum","$minimum","maximum","$maximum","exclusiveMinimum","$exclusiveMinimum","exclusiveMaximum","$exclusiveMaximum","multipleOf","$multipleOf","minLength","$minLength","maxLength","$maxLength","pattern","$pattern","__absolute_ref__","__absolute_recursive_ref__","refSchema","result","push","undefined","uri","message","keys","join","length","i","JSON","stringify","some","value","subEvaluateds","errorsLength","anyValid","subSchema","subEvaluated","splice","allValid","matches","filter","assign","conditionResult","thenResult","elseResult","key","subInstancePointer","dependantKey","propsOrSchema","thisEvaluated","stop","regex","RegExp","test","length2","Math","min","contained","j","a","ao","k","b","bo","Number","MAX_SAFE_INTEGER","remainder","abs"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.js"],"sourcesContent":["import { deepCompareStrict } from \"./deep-compare-strict.js\";\nimport { dereference } from \"./dereference.js\";\nimport { fastFormat } from \"./format.js\";\nimport { encodePointer } from \"./pointer.js\";\nimport { ucs2length } from \"./ucs2-length.js\";\nexport function validate(instance, schema, draft = \"2019-09\", lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = \"#\", schemaLocation = \"#\", evaluated = Object.create(null)) {\n    if (schema === true) {\n        return { valid: true, errors: [] };\n    }\n    if (schema === false) {\n        return {\n            valid: false,\n            errors: [\n                {\n                    instanceLocation,\n                    keyword: \"false\",\n                    keywordLocation: instanceLocation,\n                    error: \"False boolean schema.\",\n                },\n            ],\n        };\n    }\n    const rawInstanceType = typeof instance;\n    let instanceType;\n    switch (rawInstanceType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            instanceType = rawInstanceType;\n            break;\n        case \"object\":\n            if (instance === null) {\n                instanceType = \"null\";\n            }\n            else if (Array.isArray(instance)) {\n                instanceType = \"array\";\n            }\n            else {\n                instanceType = \"object\";\n            }\n            break;\n        default:\n            // undefined, bigint, function, symbol\n            throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n    }\n    const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__, } = schema;\n    const errors = [];\n    if ($recursiveAnchor === true && recursiveAnchor === null) {\n        recursiveAnchor = schema;\n    }\n    if ($recursiveRef === \"#\") {\n        const refSchema = recursiveAnchor === null\n            ? lookup[__absolute_recursive_ref__]\n            : recursiveAnchor;\n        const keywordLocation = `${schemaLocation}/$recursiveRef`;\n        const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"$recursiveRef\",\n                keywordLocation,\n                error: \"A subschema had errors.\",\n            }, ...result.errors);\n        }\n    }\n    if ($ref !== undefined) {\n        const uri = __absolute_ref__ || $ref;\n        const refSchema = lookup[uri];\n        if (refSchema === undefined) {\n            let message = `Unresolved $ref \"${$ref}\".`;\n            if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                message += `  Absolute URI \"${__absolute_ref__}\".`;\n            }\n            message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join(\"\\n- \")}`;\n            throw new Error(message);\n        }\n        const keywordLocation = `${schemaLocation}/$ref`;\n        const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"$ref\",\n                keywordLocation,\n                error: \"A subschema had errors.\",\n            }, ...result.errors);\n        }\n        if (draft === \"4\" || draft === \"7\") {\n            return { valid: errors.length === 0, errors };\n        }\n    }\n    if (Array.isArray($type)) {\n        let length = $type.length;\n        let valid = false;\n        for (let i = 0; i < length; i++) {\n            if (instanceType === $type[i] ||\n                ($type[i] === \"integer\" &&\n                    instanceType === \"number\" &&\n                    instance % 1 === 0 &&\n                    instance === instance)) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"type\",\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`,\n            });\n        }\n    }\n    else if ($type === \"integer\") {\n        if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n            errors.push({\n                instanceLocation,\n                keyword: \"type\",\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n            });\n        }\n    }\n    else if ($type !== undefined && instanceType !== $type) {\n        errors.push({\n            instanceLocation,\n            keyword: \"type\",\n            keywordLocation: `${schemaLocation}/type`,\n            error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n        });\n    }\n    if ($const !== undefined) {\n        if (instanceType === \"object\" || instanceType === \"array\") {\n            if (!deepCompareStrict(instance, $const)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"const\",\n                    keywordLocation: `${schemaLocation}/const`,\n                    error: `Instance does not match ${JSON.stringify($const)}.`,\n                });\n            }\n        }\n        else if (instance !== $const) {\n            errors.push({\n                instanceLocation,\n                keyword: \"const\",\n                keywordLocation: `${schemaLocation}/const`,\n                error: `Instance does not match ${JSON.stringify($const)}.`,\n            });\n        }\n    }\n    if ($enum !== undefined) {\n        if (instanceType === \"object\" || instanceType === \"array\") {\n            if (!$enum.some((value) => deepCompareStrict(instance, value))) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"enum\",\n                    keywordLocation: `${schemaLocation}/enum`,\n                    error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n                });\n            }\n        }\n        else if (!$enum.some((value) => instance === value)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"enum\",\n                keywordLocation: `${schemaLocation}/enum`,\n                error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n            });\n        }\n    }\n    if ($not !== undefined) {\n        const keywordLocation = `${schemaLocation}/not`;\n        const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation /*,\n        evaluated*/);\n        if (result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"not\",\n                keywordLocation,\n                error: 'Instance matched \"not\" schema.',\n            });\n        }\n    }\n    let subEvaluateds = [];\n    if ($anyOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/anyOf`;\n        const errorsLength = errors.length;\n        let anyValid = false;\n        for (let i = 0; i < $anyOf.length; i++) {\n            const subSchema = $anyOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            anyValid = anyValid || result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (anyValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"anyOf\",\n                keywordLocation,\n                error: \"Instance does not match any subschemas.\",\n            });\n        }\n    }\n    if ($allOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/allOf`;\n        const errorsLength = errors.length;\n        let allValid = true;\n        for (let i = 0; i < $allOf.length; i++) {\n            const subSchema = $allOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            allValid = allValid && result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (allValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"allOf\",\n                keywordLocation,\n                error: `Instance does not match every subschema.`,\n            });\n        }\n    }\n    if ($oneOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/oneOf`;\n        const errorsLength = errors.length;\n        const matches = $oneOf.filter((subSchema, i) => {\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n            return result.valid;\n        }).length;\n        if (matches === 1) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"oneOf\",\n                keywordLocation,\n                error: `Instance does not match exactly one subschema (${matches} matches).`,\n            });\n        }\n    }\n    if (instanceType === \"object\" || instanceType === \"array\") {\n        Object.assign(evaluated, ...subEvaluateds);\n    }\n    if ($if !== undefined) {\n        const keywordLocation = `${schemaLocation}/if`;\n        const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n        if (conditionResult) {\n            if ($then !== undefined) {\n                const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                if (!thenResult.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"if\",\n                        keywordLocation,\n                        error: `Instance does not match \"then\" schema.`,\n                    }, ...thenResult.errors);\n                }\n            }\n        }\n        else if ($else !== undefined) {\n            const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n            if (!elseResult.valid) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"if\",\n                    keywordLocation,\n                    error: `Instance does not match \"else\" schema.`,\n                }, ...elseResult.errors);\n            }\n        }\n    }\n    if (instanceType === \"object\") {\n        if ($required !== undefined) {\n            for (const key of $required) {\n                if (!(key in instance)) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"required\",\n                        keywordLocation: `${schemaLocation}/required`,\n                        error: `Instance does not have required property \"${key}\".`,\n                    });\n                }\n            }\n        }\n        const keys = Object.keys(instance);\n        if ($minProperties !== undefined && keys.length < $minProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minProperties\",\n                keywordLocation: `${schemaLocation}/minProperties`,\n                error: `Instance does not have at least ${$minProperties} properties.`,\n            });\n        }\n        if ($maxProperties !== undefined && keys.length > $maxProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxProperties\",\n                keywordLocation: `${schemaLocation}/maxProperties`,\n                error: `Instance does not have at least ${$maxProperties} properties.`,\n            });\n        }\n        if ($propertyNames !== undefined) {\n            const keywordLocation = `${schemaLocation}/propertyNames`;\n            for (const key in instance) {\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"propertyNames\",\n                        keywordLocation,\n                        error: `Property name \"${key}\" does not match schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($dependentRequired !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependantRequired`;\n            for (const key in $dependentRequired) {\n                if (key in instance) {\n                    const required = $dependentRequired[key];\n                    for (const dependantKey of required) {\n                        if (!(dependantKey in instance)) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: \"dependentRequired\",\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if ($dependentSchemas !== undefined) {\n            for (const key in $dependentSchemas) {\n                const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                if (key in instance) {\n                    const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n                    if (!result.valid) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"dependentSchemas\",\n                            keywordLocation,\n                            error: `Instance has \"${key}\" but does not match dependant schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($dependencies !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependencies`;\n            for (const key in $dependencies) {\n                if (key in instance) {\n                    const propsOrSchema = $dependencies[key];\n                    if (Array.isArray(propsOrSchema)) {\n                        for (const dependantKey of propsOrSchema) {\n                            if (!(dependantKey in instance)) {\n                                errors.push({\n                                    instanceLocation,\n                                    keyword: \"dependencies\",\n                                    keywordLocation,\n                                    error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                                });\n                            }\n                        }\n                    }\n                    else {\n                        const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n                        if (!result.valid) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: \"dependencies\",\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not match dependant schema.`,\n                            }, ...result.errors);\n                        }\n                    }\n                }\n            }\n        }\n        const thisEvaluated = Object.create(null);\n        let stop = false;\n        if ($properties !== undefined) {\n            const keywordLocation = `${schemaLocation}/properties`;\n            for (const key in $properties) {\n                if (!(key in instance)) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n                if (result.valid) {\n                    evaluated[key] = thisEvaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"properties\",\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match schema.`,\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if (!stop && $patternProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/patternProperties`;\n            for (const pattern in $patternProperties) {\n                const regex = new RegExp(pattern);\n                const subSchema = $patternProperties[pattern];\n                for (const key in instance) {\n                    if (!regex.test(key)) {\n                        continue;\n                    }\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n                    if (result.valid) {\n                        evaluated[key] = thisEvaluated[key] = true;\n                    }\n                    else {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"patternProperties\",\n                            keywordLocation,\n                            error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if (!stop && $additionalProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/additionalProperties`;\n            for (const key in instance) {\n                if (thisEvaluated[key]) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (result.valid) {\n                    evaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"additionalProperties\",\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match additional properties schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        else if (!stop && $unevaluatedProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n            for (const key in instance) {\n                if (!evaluated[key]) {\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                    if (result.valid) {\n                        evaluated[key] = true;\n                    }\n                    else {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"unevaluatedProperties\",\n                            keywordLocation,\n                            error: `Property \"${key}\" does not match unevaluated properties schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === \"array\") {\n        if ($maxItems !== undefined && instance.length > $maxItems) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxItems\",\n                keywordLocation: `${schemaLocation}/maxItems`,\n                error: `Array has too many items (${instance.length} > ${$maxItems}).`,\n            });\n        }\n        if ($minItems !== undefined && instance.length < $minItems) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minItems\",\n                keywordLocation: `${schemaLocation}/minItems`,\n                error: `Array has too few items (${instance.length} < ${$minItems}).`,\n            });\n        }\n        const length = instance.length;\n        let i = 0;\n        let stop = false;\n        if ($prefixItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/prefixItems`;\n            const length2 = Math.min($prefixItems.length, length);\n            for (; i < length2; i++) {\n                const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"prefixItems\",\n                        keywordLocation,\n                        error: `Items did not match schema.`,\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if ($items !== undefined) {\n            const keywordLocation = `${schemaLocation}/items`;\n            if (Array.isArray($items)) {\n                const length2 = Math.min($items.length, length);\n                for (; i < length2; i++) {\n                    const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"items\",\n                            keywordLocation,\n                            error: `Items did not match schema.`,\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            else {\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"items\",\n                            keywordLocation,\n                            error: `Items did not match schema.`,\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            if (!stop && $additionalItems !== undefined) {\n                const keywordLocation = `${schemaLocation}/additionalItems`;\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"additionalItems\",\n                            keywordLocation,\n                            error: `Items did not match additional items schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($contains !== undefined) {\n            if (length === 0 && $minContains === undefined) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"contains\",\n                    keywordLocation: `${schemaLocation}/contains`,\n                    error: `Array is empty. It must contain at least one item matching the schema.`,\n                });\n            }\n            else if ($minContains !== undefined && length < $minContains) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minContains\",\n                    keywordLocation: `${schemaLocation}/minContains`,\n                    error: `Array has less items (${length}) than minContains (${$minContains}).`,\n                });\n            }\n            else {\n                const keywordLocation = `${schemaLocation}/contains`;\n                const errorsLength = errors.length;\n                let contained = 0;\n                for (let j = 0; j < length; j++) {\n                    const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                    if (result.valid) {\n                        evaluated[j] = true;\n                        contained++;\n                    }\n                    else {\n                        errors.push(...result.errors);\n                    }\n                }\n                if (contained >= ($minContains || 0)) {\n                    errors.length = errorsLength;\n                }\n                if ($minContains === undefined &&\n                    $maxContains === undefined &&\n                    contained === 0) {\n                    errors.splice(errorsLength, 0, {\n                        instanceLocation,\n                        keyword: \"contains\",\n                        keywordLocation,\n                        error: `Array does not contain item matching schema.`,\n                    });\n                }\n                else if ($minContains !== undefined && contained < $minContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"minContains\",\n                        keywordLocation: `${schemaLocation}/minContains`,\n                        error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`,\n                    });\n                }\n                else if ($maxContains !== undefined && contained > $maxContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"maxContains\",\n                        keywordLocation: `${schemaLocation}/maxContains`,\n                        error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`,\n                    });\n                }\n            }\n        }\n        if (!stop && $unevaluatedItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n            for (i; i < length; i++) {\n                if (evaluated[i]) {\n                    continue;\n                }\n                const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"unevaluatedItems\",\n                        keywordLocation,\n                        error: `Items did not match unevaluated items schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($uniqueItems) {\n            for (let j = 0; j < length; j++) {\n                const a = instance[j];\n                const ao = typeof a === \"object\" && a !== null;\n                for (let k = 0; k < length; k++) {\n                    if (j === k) {\n                        continue;\n                    }\n                    const b = instance[k];\n                    const bo = typeof b === \"object\" && b !== null;\n                    if (a === b || (ao && bo && deepCompareStrict(a, b))) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"uniqueItems\",\n                            keywordLocation: `${schemaLocation}/uniqueItems`,\n                            error: `Duplicate items at indexes ${j} and ${k}.`,\n                        });\n                        j = Number.MAX_SAFE_INTEGER;\n                        k = Number.MAX_SAFE_INTEGER;\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === \"number\") {\n        if (draft === \"4\") {\n            if ($minimum !== undefined &&\n                (($exclusiveMinimum === true && instance <= $minimum) ||\n                    instance < $minimum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minimum\",\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum ? \"or equal to \" : \"\"} ${$minimum}.`,\n                });\n            }\n            if ($maximum !== undefined &&\n                (($exclusiveMaximum === true && instance >= $maximum) ||\n                    instance > $maximum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"maximum\",\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$exclusiveMaximum ? \"or equal to \" : \"\"} ${$maximum}.`,\n                });\n            }\n        }\n        else {\n            if ($minimum !== undefined && instance < $minimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minimum\",\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$minimum}.`,\n                });\n            }\n            if ($maximum !== undefined && instance > $maximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"maximum\",\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$maximum}.`,\n                });\n            }\n            if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"exclusiveMinimum\",\n                    keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum}.`,\n                });\n            }\n            if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"exclusiveMaximum\",\n                    keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                    error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`,\n                });\n            }\n        }\n        if ($multipleOf !== undefined) {\n            const remainder = instance % $multipleOf;\n            if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"multipleOf\",\n                    keywordLocation: `${schemaLocation}/multipleOf`,\n                    error: `${instance} is not a multiple of ${$multipleOf}.`,\n                });\n            }\n        }\n    }\n    else if (instanceType === \"string\") {\n        const length = $minLength === undefined && $maxLength === undefined\n            ? 0\n            : ucs2length(instance);\n        if ($minLength !== undefined && length < $minLength) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minLength\",\n                keywordLocation: `${schemaLocation}/minLength`,\n                error: `String is too short (${length} < ${$minLength}).`,\n            });\n        }\n        if ($maxLength !== undefined && length > $maxLength) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxLength\",\n                keywordLocation: `${schemaLocation}/maxLength`,\n                error: `String is too long (${length} > ${$maxLength}).`,\n            });\n        }\n        if ($pattern !== undefined && !new RegExp($pattern).test(instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"pattern\",\n                keywordLocation: `${schemaLocation}/pattern`,\n                error: `String does not match pattern.`,\n            });\n        }\n        if ($format !== undefined &&\n            fastFormat[$format] &&\n            !fastFormat[$format](instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"format\",\n                keywordLocation: `${schemaLocation}/format`,\n                error: `String does not match format \"${$format}\".`,\n            });\n        }\n    }\n    return { valid: errors.length === 0, errors };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}