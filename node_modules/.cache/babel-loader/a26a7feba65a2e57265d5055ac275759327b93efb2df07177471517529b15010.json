{"ast":null,"code":"import { applyPatch } from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/index.js\";\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n  constructor(fields) {\n    var _fields$ops;\n    Object.defineProperty(this, \"ops\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.ops = (_fields$ops = fields.ops) !== null && _fields$ops !== void 0 ? _fields$ops : [];\n  }\n  concat(other) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch({}, ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument\n    });\n  }\n}\nexport class RunLog extends RunLogPatch {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"state\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.state = fields.state;\n  }\n  concat(other) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch(this.state, other.ops);\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument\n    });\n  }\n  static fromRunLogPatch(patch) {\n    const states = applyPatch({}, patch.ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops: patch.ops,\n      state: states[states.length - 1].newDocument\n    });\n  }\n}\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n  if (schemaFormat === \"original\") {\n    throw new Error(\"Do not assign inputs with original schema drop the key for now. \" + \"When inputs are added to streamLog they should be added with \" + \"standardized schema for streaming events.\");\n  }\n  const {\n    inputs\n  } = run;\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return inputs;\n  }\n  if (Object.keys(inputs).length === 1 && (inputs === null || inputs === void 0 ? void 0 : inputs.input) === \"\") {\n    return undefined;\n  }\n  // new style chains\n  // These nest an additional 'input' key inside the 'inputs' to make sure\n  // the input is always a dict. We need to unpack and user the inner value.\n  // We should try to fix this in Runnables and callbacks/tracers\n  // Runnables should be using a null type here not a placeholder\n  // dict.\n  return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n  const {\n    outputs\n  } = run;\n  if (schemaFormat === \"original\") {\n    // Return the old schema, without standardizing anything\n    return outputs;\n  }\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return outputs;\n  }\n  // TODO: Remove this hacky check\n  if (outputs !== undefined && Object.keys(outputs).length === 1 && (outputs === null || outputs === void 0 ? void 0 : outputs.output) !== undefined) {\n    return outputs.output;\n  }\n  return outputs;\n}\nfunction isChatGenerationChunk(x) {\n  return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler extends BaseTracer {\n  constructor(fields) {\n    var _fields$autoClose, _fields$_schemaFormat;\n    super(fields);\n    Object.defineProperty(this, \"autoClose\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"includeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_schemaFormat\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"original\"\n    });\n    Object.defineProperty(this, \"rootId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"keyMapByRunId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"counterMapByRunName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"transformStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"writer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"receiveStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"log_stream_tracer\"\n    });\n    this.autoClose = (_fields$autoClose = fields === null || fields === void 0 ? void 0 : fields.autoClose) !== null && _fields$autoClose !== void 0 ? _fields$autoClose : true;\n    this.includeNames = fields === null || fields === void 0 ? void 0 : fields.includeNames;\n    this.includeTypes = fields === null || fields === void 0 ? void 0 : fields.includeTypes;\n    this.includeTags = fields === null || fields === void 0 ? void 0 : fields.includeTags;\n    this.excludeNames = fields === null || fields === void 0 ? void 0 : fields.excludeNames;\n    this.excludeTypes = fields === null || fields === void 0 ? void 0 : fields.excludeTypes;\n    this.excludeTags = fields === null || fields === void 0 ? void 0 : fields.excludeTags;\n    this._schemaFormat = (_fields$_schemaFormat = fields === null || fields === void 0 ? void 0 : fields._schemaFormat) !== null && _fields$_schemaFormat !== void 0 ? _fields$_schemaFormat : this._schemaFormat;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n  }\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n  async persistRun(_run) {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n  _includeRun(run) {\n    var _run$tags;\n    if (run.id === this.rootId) {\n      return false;\n    }\n    const runTags = (_run$tags = run.tags) !== null && _run$tags !== void 0 ? _run$tags : [];\n    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.run_type);\n    }\n    if (this.includeTags !== undefined) {\n      include = include || runTags.find(tag => {\n        var _this$includeTags;\n        return (_this$includeTags = this.includeTags) === null || _this$includeTags === void 0 ? void 0 : _this$includeTags.includes(tag);\n      }) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.run_type);\n    }\n    if (this.excludeTags !== undefined) {\n      include = include && runTags.every(tag => {\n        var _this$excludeTags;\n        return !((_this$excludeTags = this.excludeTags) !== null && _this$excludeTags !== void 0 && _this$excludeTags.includes(tag));\n      });\n    }\n    return include;\n  }\n  async *tapOutputIterable(runId, output) {\n    // Tap an output async iterator to stream its values to the log.\n    for await (const chunk of output) {\n      // root run is handled in .streamLog()\n      if (runId !== this.rootId) {\n        // if we can't find the run silently ignore\n        // eg. because this run wasn't included in the log\n        const key = this.keyMapByRunId[runId];\n        if (key) {\n          await this.writer.write(new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: \"/logs/\".concat(key, \"/streamed_output/-\"),\n              value: chunk\n            }]\n          }));\n        }\n      }\n      yield chunk;\n    }\n  }\n  async onRunCreate(run) {\n    var _run$tags2, _run$extra$metadata, _run$extra;\n    if (this.rootId === undefined) {\n      this.rootId = run.id;\n      await this.writer.write(new RunLogPatch({\n        ops: [{\n          op: \"replace\",\n          path: \"\",\n          value: {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            streamed_output: [],\n            final_output: undefined,\n            logs: {}\n          }\n        }]\n      }));\n    }\n    if (!this._includeRun(run)) {\n      return;\n    }\n    if (this.counterMapByRunName[run.name] === undefined) {\n      this.counterMapByRunName[run.name] = 0;\n    }\n    this.counterMapByRunName[run.name] += 1;\n    const count = this.counterMapByRunName[run.name];\n    this.keyMapByRunId[run.id] = count === 1 ? run.name : \"\".concat(run.name, \":\").concat(count);\n    const logEntry = {\n      id: run.id,\n      name: run.name,\n      type: run.run_type,\n      tags: (_run$tags2 = run.tags) !== null && _run$tags2 !== void 0 ? _run$tags2 : [],\n      metadata: (_run$extra$metadata = (_run$extra = run.extra) === null || _run$extra === void 0 ? void 0 : _run$extra.metadata) !== null && _run$extra$metadata !== void 0 ? _run$extra$metadata : {},\n      start_time: new Date(run.start_time).toISOString(),\n      streamed_output: [],\n      streamed_output_str: [],\n      final_output: undefined,\n      end_time: undefined\n    };\n    if (this._schemaFormat === \"streaming_events\") {\n      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n    }\n    await this.writer.write(new RunLogPatch({\n      ops: [{\n        op: \"add\",\n        path: \"/logs/\".concat(this.keyMapByRunId[run.id]),\n        value: logEntry\n      }]\n    }));\n  }\n  async onRunUpdate(run) {\n    try {\n      const runName = this.keyMapByRunId[run.id];\n      if (runName === undefined) {\n        return;\n      }\n      const ops = [];\n      if (this._schemaFormat === \"streaming_events\") {\n        ops.push({\n          op: \"replace\",\n          path: \"/logs/\".concat(runName, \"/inputs\"),\n          value: await _getStandardizedInputs(run, this._schemaFormat)\n        });\n      }\n      ops.push({\n        op: \"add\",\n        path: \"/logs/\".concat(runName, \"/final_output\"),\n        value: await _getStandardizedOutputs(run, this._schemaFormat)\n      });\n      if (run.end_time !== undefined) {\n        ops.push({\n          op: \"add\",\n          path: \"/logs/\".concat(runName, \"/end_time\"),\n          value: new Date(run.end_time).toISOString()\n        });\n      }\n      const patch = new RunLogPatch({\n        ops\n      });\n      await this.writer.write(patch);\n    } finally {\n      if (run.id === this.rootId) {\n        const patch = new RunLogPatch({\n          ops: [{\n            op: \"replace\",\n            path: \"/final_output\",\n            value: await _getStandardizedOutputs(run, this._schemaFormat)\n          }]\n        });\n        await this.writer.write(patch);\n        if (this.autoClose) {\n          await this.writer.close();\n        }\n      }\n    }\n  }\n  async onLLMNewToken(run, token, kwargs) {\n    const runName = this.keyMapByRunId[run.id];\n    if (runName === undefined) {\n      return;\n    }\n    // TODO: Remove hack\n    const isChatModel = run.inputs.messages !== undefined;\n    let streamedOutputValue;\n    if (isChatModel) {\n      if (isChatGenerationChunk(kwargs === null || kwargs === void 0 ? void 0 : kwargs.chunk)) {\n        streamedOutputValue = kwargs === null || kwargs === void 0 ? void 0 : kwargs.chunk;\n      } else {\n        streamedOutputValue = new AIMessageChunk(token);\n      }\n    } else {\n      streamedOutputValue = token;\n    }\n    const patch = new RunLogPatch({\n      ops: [{\n        op: \"add\",\n        path: \"/logs/\".concat(runName, \"/streamed_output_str/-\"),\n        value: token\n      }, {\n        op: \"add\",\n        path: \"/logs/\".concat(runName, \"/streamed_output/-\"),\n        value: streamedOutputValue\n      }]\n    });\n    await this.writer.write(patch);\n  }\n}","map":{"version":3,"names":["applyPatch","BaseTracer","IterableReadableStream","AIMessageChunk","RunLogPatch","constructor","fields","_fields$ops","Object","defineProperty","enumerable","configurable","writable","value","ops","concat","other","states","RunLog","state","length","newDocument","fromRunLogPatch","patch","_getStandardizedInputs","run","schemaFormat","Error","inputs","includes","run_type","keys","input","undefined","_getStandardizedOutputs","outputs","output","isChatGenerationChunk","x","message","LogStreamCallbackHandler","_fields$autoClose","_fields$_schemaFormat","autoClose","includeNames","includeTypes","includeTags","excludeNames","excludeTypes","excludeTags","_schemaFormat","transformStream","TransformStream","writer","getWriter","receiveStream","fromReadableStream","readable","Symbol","asyncIterator","persistRun","_run","_includeRun","_run$tags","id","rootId","runTags","tags","include","name","find","tag","_this$includeTags","every","_this$excludeTags","tapOutputIterable","runId","chunk","key","keyMapByRunId","write","op","path","onRunCreate","_run$tags2","_run$extra$metadata","_run$extra","type","streamed_output","final_output","logs","counterMapByRunName","count","logEntry","metadata","extra","start_time","Date","toISOString","streamed_output_str","end_time","onRunUpdate","runName","push","close","onLLMNewToken","token","kwargs","isChatModel","messages","streamedOutputValue"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/tracers/log_stream.js"],"sourcesContent":["import { applyPatch, } from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/index.js\";\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = applyPatch({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexport class RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = applyPatch(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = applyPatch({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler extends BaseTracer {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new AIMessageChunk(token);\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}