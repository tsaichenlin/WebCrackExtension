{"ast":null,"code":"import { AIMessage, HumanMessage, isBaseMessage } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n  constructor(fields) {\n    let historyChain = new RunnableLambda({\n      func: (input, options) => this._enterHistory(input, options ?? {})\n    }).withConfig({\n      runName: \"loadHistory\"\n    });\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain\n      }).withConfig({\n        runName: \"insertHistory\"\n      });\n    }\n    const bound = historyChain.pipe(fields.runnable.withListeners({\n      onEnd: (run, config) => this._exitHistory(run, config ?? {})\n    })).withConfig({\n      runName: \"RunnableWithMessageHistory\"\n    });\n    const config = fields.config ?? {};\n    super({\n      ...fields,\n      config,\n      bound\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"historyMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"getMessageHistory\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n  _getInputMessages(inputValue) {\n    if (typeof inputValue === \"string\") {\n      return [new HumanMessage(inputValue)];\n    } else if (Array.isArray(inputValue)) {\n      return inputValue;\n    } else {\n      return [inputValue];\n    }\n  }\n  _getOutputMessages(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  outputValue) {\n    let newOutputValue = outputValue;\n    if (!Array.isArray(outputValue) && !isBaseMessage(outputValue) && typeof outputValue !== \"string\") {\n      newOutputValue = outputValue[this.outputMessagesKey ?? \"output\"];\n    }\n    if (typeof newOutputValue === \"string\") {\n      return [new AIMessage(newOutputValue)];\n    } else if (Array.isArray(newOutputValue)) {\n      return newOutputValue;\n    } else if (isBaseMessage(newOutputValue)) {\n      return [newOutputValue];\n    }\n    throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(newOutputValue, null, 2)}`);\n  }\n  async _enterHistory(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input, kwargs) {\n    const history = kwargs?.config?.configurable?.messageHistory;\n    if (this.historyMessagesKey) {\n      return history.getMessages();\n    }\n    const inputVal = input || (this.inputMessagesKey ? input[this.inputMessagesKey] : undefined);\n    const historyMessages = history ? await history.getMessages() : [];\n    const returnType = [...historyMessages, ...this._getInputMessages(inputVal)];\n    return returnType;\n  }\n  async _exitHistory(run, config) {\n    const history = config.configurable?.messageHistory;\n    // Get input messages\n    const {\n      inputs\n    } = run;\n    const inputValue = inputs[this.inputMessagesKey ?? \"input\"];\n    const inputMessages = this._getInputMessages(inputValue);\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    for await (const message of [...inputMessages, ...outputMessages]) {\n      await history.addMessage(message);\n    }\n  }\n  async _mergeConfig(...configs) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\"\n      };\n      const exampleConfig = {\n        configurable: {\n          sessionId: \"123\"\n        }\n      };\n      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` + `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n    }\n    // attach messageHistory\n    const {\n      sessionId\n    } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n    return config;\n  }\n}","map":{"version":3,"names":["AIMessage","HumanMessage","isBaseMessage","RunnableBinding","RunnableLambda","RunnablePassthrough","RunnableWithMessageHistory","constructor","fields","historyChain","func","input","options","_enterHistory","withConfig","runName","messagesKey","historyMessagesKey","inputMessagesKey","assign","bound","pipe","runnable","withListeners","onEnd","run","config","_exitHistory","Object","defineProperty","enumerable","configurable","writable","value","getMessageHistory","outputMessagesKey","_getInputMessages","inputValue","Array","isArray","_getOutputMessages","outputValue","newOutputValue","Error","JSON","stringify","kwargs","history","messageHistory","getMessages","inputVal","undefined","historyMessages","returnType","inputs","inputMessages","outputs","outputMessages","message","addMessage","_mergeConfig","configs","sessionId","exampleInput","exampleConfig"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/history.js"],"sourcesContent":["import { AIMessage, HumanMessage, isBaseMessage, } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda, } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n    constructor(fields) {\n        let historyChain = new RunnableLambda({\n            func: (input, options) => this._enterHistory(input, options ?? {}),\n        }).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(inputValue) {\n        if (typeof inputValue === \"string\") {\n            return [new HumanMessage(inputValue)];\n        }\n        else if (Array.isArray(inputValue)) {\n            return inputValue;\n        }\n        else {\n            return [inputValue];\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let newOutputValue = outputValue;\n        if (!Array.isArray(outputValue) &&\n            !isBaseMessage(outputValue) &&\n            typeof outputValue !== \"string\") {\n            newOutputValue = outputValue[this.outputMessagesKey ?? \"output\"];\n        }\n        if (typeof newOutputValue === \"string\") {\n            return [new AIMessage(newOutputValue)];\n        }\n        else if (Array.isArray(newOutputValue)) {\n            return newOutputValue;\n        }\n        else if (isBaseMessage(newOutputValue)) {\n            return [newOutputValue];\n        }\n        throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(newOutputValue, null, 2)}`);\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.config?.configurable?.messageHistory;\n        if (this.historyMessagesKey) {\n            return history.getMessages();\n        }\n        const inputVal = input ||\n            (this.inputMessagesKey ? input[this.inputMessagesKey] : undefined);\n        const historyMessages = history ? await history.getMessages() : [];\n        const returnType = [\n            ...historyMessages,\n            ...this._getInputMessages(inputVal),\n        ];\n        return returnType;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        const { inputs } = run;\n        const inputValue = inputs[this.inputMessagesKey ?? \"input\"];\n        const inputMessages = this._getInputMessages(inputValue);\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        for await (const message of [...inputMessages, ...outputMessages]) {\n            await history.addMessage(message);\n        }\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}