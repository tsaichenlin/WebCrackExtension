{"ast":null,"code":"import { Runnable, _coerceToDict, _coerceToRunnable } from \"./base.js\";\nimport { getCallbackManagerForConfig, patchConfig } from \"./config.js\";\nimport { concat } from \"../utils/stream.js\";\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch extends Runnable {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"default\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"branches\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from(branches) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1);\n    const coercedBranches = branchLikes.map(_ref => {\n      let [condition, runnable] = _ref;\n      return [_coerceToRunnable(condition), _coerceToRunnable(runnable)];\n    });\n    const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch\n    });\n  }\n  async _invoke(input, config, runManager) {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(input, patchConfig(config, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"condition:\".concat(i + 1))\n      }));\n      if (conditionValue) {\n        result = await branchRunnable.invoke(input, patchConfig(config, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"branch:\".concat(i + 1))\n        }));\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(input, patchConfig(config, {\n        callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"branch:default\")\n      }));\n    }\n    return result;\n  }\n  async invoke(input) {\n    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this._callWithConfig(this._invoke, input, config);\n  }\n  async *_streamIterator(input, config) {\n    var _finalOutput;\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, config === null || config === void 0 ? void 0 : config.runName));\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(input, patchConfig(config, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"condition:\".concat(i + 1))\n        }));\n        if (conditionValue) {\n          stream = await branchRunnable.stream(input, patchConfig(config, {\n            callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"branch:\".concat(i + 1))\n          }));\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch (e) {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(input, patchConfig(config, {\n          callbacks: runManager === null || runManager === void 0 ? void 0 : runManager.getChild(\"branch:default\")\n        }));\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk);\n              } catch (e) {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd((_finalOutput = finalOutput) !== null && _finalOutput !== void 0 ? _finalOutput : {}));\n  }\n}","map":{"version":3,"names":["Runnable","_coerceToDict","_coerceToRunnable","getCallbackManagerForConfig","patchConfig","concat","RunnableBranch","lc_name","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","branches","default","from","length","Error","branchLikes","slice","coercedBranches","map","_ref","condition","runnable","defaultBranch","_invoke","input","config","runManager","result","i","branchRunnable","conditionValue","invoke","callbacks","getChild","arguments","undefined","_callWithConfig","_streamIterator","_finalOutput","callbackManager_","handleChainStart","toJSON","runName","finalOutput","finalOutputSupported","stream","chunk","e","handleChainError","handleChainEnd"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/branch.js"],"sourcesContent":["import { Runnable, _coerceToDict, _coerceToRunnable, } from \"./base.js\";\nimport { getCallbackManagerForConfig, patchConfig, } from \"./config.js\";\nimport { concat } from \"../utils/stream.js\";\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch extends Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            _coerceToRunnable(condition),\n            _coerceToRunnable(runnable),\n        ]);\n        const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, patchConfig(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = concat(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}