{"ast":null,"code":"import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n  return CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const copy = ensureConfig();\n  for (const options of configs.filter(c => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"tags\") {\n        copy[key] = [...new Set(copy[key].concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n              metadata: {\n                ...baseCallbacks.metadata,\n                ...providedCallbacks.metadata\n              }\n            });\n          }\n        }\n      } else {\n        const typedKey = key;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig(config) {\n  let empty = {\n    tags: [],\n    metadata: {},\n    callbacks: undefined,\n    recursionLimit: 25\n  };\n  if (config) {\n    empty = {\n      ...empty,\n      ...config\n    };\n  }\n  if (config?.configurable) {\n    for (const key of Object.keys(config.configurable)) {\n      if (PRIMITIVES.has(typeof config.configurable[key]) && !empty.metadata?.[key]) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = config.configurable[key];\n      }\n    }\n  }\n  return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, {\n  callbacks,\n  maxConcurrency,\n  recursionLimit,\n  runName,\n  configurable\n} = {}) {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = {\n      ...newConfig.configurable,\n      ...configurable\n    };\n  }\n  return newConfig;\n}","map":{"version":3,"names":["CallbackManager","ensureHandler","DEFAULT_RECURSION_LIMIT","getCallbackManagerForConfig","config","configure","callbacks","undefined","tags","metadata","mergeConfigs","configs","copy","ensureConfig","options","filter","c","key","Object","keys","Set","concat","baseCallbacks","providedCallbacks","Array","isArray","manager","callback","addHandler","_parentRunId","handlers","inheritableHandlers","from","inheritableTags","typedKey","PRIMITIVES","empty","recursionLimit","configurable","has","patchConfig","maxConcurrency","runName","newConfig"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/config.js"],"sourcesContent":["import { CallbackManager, ensureHandler, } from \"../callbacks/manager.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n    return CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const copy = ensureConfig();\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                copy[key] = [...new Set(copy[key].concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig(config) {\n    let empty = {\n        tags: [],\n        metadata: {},\n        callbacks: undefined,\n        recursionLimit: 25,\n    };\n    if (config) {\n        empty = { ...empty, ...config };\n    }\n    if (config?.configurable) {\n        for (const key of Object.keys(config.configurable)) {\n            if (PRIMITIVES.has(typeof config.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = config.configurable[key];\n            }\n        }\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    return newConfig;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}