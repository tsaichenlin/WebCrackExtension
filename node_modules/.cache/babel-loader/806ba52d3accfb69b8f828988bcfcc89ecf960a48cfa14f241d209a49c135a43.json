{"ast":null,"code":"import { Runnable } from \"./base.js\";\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnables = fields.runnables;\n  }\n  async invoke(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(\"No runnable associated with key \\\"\".concat(key, \"\\\".\"));\n    }\n    return runnable.invoke(actualInput, options);\n  }\n  async batch(inputs, options, batchOptions) {\n    var _optionsList$0$maxCon, _optionsList$;\n    const keys = inputs.map(input => input.key);\n    const actualInputs = inputs.map(input => input.input);\n    const missingKey = keys.find(key => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(\"One or more keys do not have a corresponding runnable.\");\n    }\n    const runnables = keys.map(key => this.runnables[key]);\n    const optionsList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const maxConcurrency = (_optionsList$0$maxCon = (_optionsList$ = optionsList[0]) === null || _optionsList$ === void 0 ? void 0 : _optionsList$.maxConcurrency) !== null && _optionsList$0$maxCon !== void 0 ? _optionsList$0$maxCon : batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.maxConcurrency;\n    const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs.slice(i, i + batchSize).map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  async stream(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(\"No runnable associated with key \\\"\".concat(key, \"\\\".\"));\n    }\n    return runnable.stream(actualInput, options);\n  }\n}","map":{"version":3,"names":["Runnable","RouterRunnable","lc_name","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","runnables","invoke","input","options","key","actualInput","runnable","undefined","Error","concat","batch","inputs","batchOptions","_optionsList$0$maxCon","_optionsList$","keys","map","actualInputs","missingKey","find","optionsList","_getOptionsList","length","maxConcurrency","batchSize","batchResults","i","batchPromises","slice","batchResult","Promise","all","push","flat","stream"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/runnables/router.js"],"sourcesContent":["import { Runnable } from \"./base.js\";\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, options);\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}