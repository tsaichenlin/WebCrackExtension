{"ast":null,"code":"import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser extends BaseCumulativeTransformOutputParser {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"output_parsers\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"JsonOutputParser\";\n  }\n  _diff(prev, next) {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{\n        op: \"replace\",\n        path: \"\",\n        value: next\n      }];\n    }\n    return compare(prev, next);\n  }\n  // This should actually return Partial<T>, but there's no way\n  // to specify emitted chunks as instances separate from the main output type.\n  async parsePartialResult(generations) {\n    return parseJsonMarkdown(generations[0].text);\n  }\n  async parse(text) {\n    return parseJsonMarkdown(text, JSON.parse);\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n}\nexport function parseJsonMarkdown(s) {\n  let parser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parsePartialJson;\n  // eslint-disable-next-line no-param-reassign\n  s = s.trim();\n  const match = /```(json)?(.*)```/s.exec(s);\n  if (!match) {\n    return parser(s);\n  } else {\n    return parser(match[2]);\n  }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nexport function parsePartialJson(s) {\n  // If the input is undefined, return null to indicate failure.\n  if (typeof s === \"undefined\") {\n    return null;\n  }\n  // Attempt to parse the string as-is.\n  try {\n    return JSON.parse(s);\n  } catch (error) {\n    // Pass\n  }\n  // Initialize variables.\n  let new_s = \"\";\n  const stack = [];\n  let isInsideString = false;\n  let escaped = false;\n  // Process each character in the string one at a time.\n  for (let char of s) {\n    if (isInsideString) {\n      if (char === '\"' && !escaped) {\n        isInsideString = false;\n      } else if (char === \"\\n\" && !escaped) {\n        char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n      } else if (char === \"\\\\\") {\n        escaped = !escaped;\n      } else {\n        escaped = false;\n      }\n    } else {\n      if (char === '\"') {\n        isInsideString = true;\n        escaped = false;\n      } else if (char === \"{\") {\n        stack.push(\"}\");\n      } else if (char === \"[\") {\n        stack.push(\"]\");\n      } else if (char === \"}\" || char === \"]\") {\n        if (stack && stack[stack.length - 1] === char) {\n          stack.pop();\n        } else {\n          // Mismatched closing character; the input is malformed.\n          return null;\n        }\n      }\n    }\n    // Append the processed character to the new string.\n    new_s += char;\n  }\n  // If we're still inside a string at the end of processing,\n  // we need to close the string.\n  if (isInsideString) {\n    new_s += '\"';\n  }\n  // Close any remaining open structures in the reverse order that they were opened.\n  for (let i = stack.length - 1; i >= 0; i -= 1) {\n    new_s += stack[i];\n  }\n  // Attempt to parse the modified string as JSON.\n  try {\n    return JSON.parse(new_s);\n  } catch (error) {\n    // If we still can't parse the string as JSON, return null to indicate failure.\n    return null;\n  }\n}","map":{"version":3,"names":["BaseCumulativeTransformOutputParser","compare","JsonOutputParser","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","value","lc_name","_diff","prev","next","undefined","op","path","parsePartialResult","generations","parseJsonMarkdown","text","parse","JSON","getFormatInstructions","s","parser","length","parsePartialJson","trim","match","exec","error","new_s","stack","isInsideString","escaped","char","push","pop","i"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/output_parsers/json.js"],"sourcesContent":["import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser extends BaseCumulativeTransformOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"JsonOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return compare(prev, next);\n    }\n    // This should actually return Partial<T>, but there's no way\n    // to specify emitted chunks as instances separate from the main output type.\n    async parsePartialResult(generations) {\n        return parseJsonMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseJsonMarkdown(text, JSON.parse);\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\nexport function parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const match = /```(json)?(.*)```/s.exec(s);\n    if (!match) {\n        return parser(s);\n    }\n    else {\n        return parser(match[2]);\n    }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nexport function parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}