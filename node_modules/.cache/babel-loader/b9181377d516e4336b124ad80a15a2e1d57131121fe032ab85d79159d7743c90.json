{"ast":null,"code":"function isAnyOfProp(prop) {\n  return prop.anyOf !== undefined && Array.isArray(prop.anyOf);\n}\n// When OpenAI use functions in the prompt, they format them as TypeScript definitions rather than OpenAPI JSON schemas.\n// This function converts the JSON schemas into TypeScript definitions.\nexport function formatFunctionDefinitions(functions) {\n  const lines = [\"namespace functions {\", \"\"];\n  for (const f of functions) {\n    var _f$parameters$propert;\n    if (f.description) {\n      lines.push(\"// \".concat(f.description));\n    }\n    if (Object.keys((_f$parameters$propert = f.parameters.properties) !== null && _f$parameters$propert !== void 0 ? _f$parameters$propert : {}).length > 0) {\n      lines.push(\"type \".concat(f.name, \" = (_: {\"));\n      lines.push(formatObjectProperties(f.parameters, 0));\n      lines.push(\"}) => any;\");\n    } else {\n      lines.push(\"type \".concat(f.name, \" = () => any;\"));\n    }\n    lines.push(\"\");\n  }\n  lines.push(\"} // namespace functions\");\n  return lines.join(\"\\n\");\n}\n// Format just the properties of an object (not including the surrounding braces)\nfunction formatObjectProperties(obj, indent) {\n  const lines = [];\n  for (const [name, param] of Object.entries((_obj$properties = obj.properties) !== null && _obj$properties !== void 0 ? _obj$properties : {})) {\n    var _obj$properties, _obj$required;\n    if (param.description && indent < 2) {\n      lines.push(\"// \".concat(param.description));\n    }\n    if ((_obj$required = obj.required) !== null && _obj$required !== void 0 && _obj$required.includes(name)) {\n      lines.push(\"\".concat(name, \": \").concat(formatType(param, indent), \",\"));\n    } else {\n      lines.push(\"\".concat(name, \"?: \").concat(formatType(param, indent), \",\"));\n    }\n  }\n  return lines.map(line => \" \".repeat(indent) + line).join(\"\\n\");\n}\n// Format a single property type\nfunction formatType(param, indent) {\n  if (isAnyOfProp(param)) {\n    return param.anyOf.map(v => formatType(v, indent)).join(\" | \");\n  }\n  switch (param.type) {\n    case \"string\":\n      if (param.enum) {\n        return param.enum.map(v => \"\\\"\".concat(v, \"\\\"\")).join(\" | \");\n      }\n      return \"string\";\n    case \"number\":\n      if (param.enum) {\n        return param.enum.map(v => \"\".concat(v)).join(\" | \");\n      }\n      return \"number\";\n    case \"integer\":\n      if (param.enum) {\n        return param.enum.map(v => \"\".concat(v)).join(\" | \");\n      }\n      return \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"null\":\n      return \"null\";\n    case \"object\":\n      return [\"{\", formatObjectProperties(param, indent + 2), \"}\"].join(\"\\n\");\n    case \"array\":\n      if (param.items) {\n        return \"\".concat(formatType(param.items, indent), \"[]\");\n      }\n      return \"any[]\";\n    default:\n      return \"\";\n  }\n}","map":{"version":3,"names":["isAnyOfProp","prop","anyOf","undefined","Array","isArray","formatFunctionDefinitions","functions","lines","f","_f$parameters$propert","description","push","concat","Object","keys","parameters","properties","length","name","formatObjectProperties","join","obj","indent","param","entries","_obj$properties","_obj$required","required","includes","formatType","map","line","repeat","v","type","enum","items"],"sources":["/Users/mandylin/Desktop/WebCrack React 2/webcrack/node_modules/@langchain/openai/dist/utils/openai-format-fndef.js"],"sourcesContent":["function isAnyOfProp(prop) {\n    return (prop.anyOf !== undefined &&\n        Array.isArray(prop.anyOf));\n}\n// When OpenAI use functions in the prompt, they format them as TypeScript definitions rather than OpenAPI JSON schemas.\n// This function converts the JSON schemas into TypeScript definitions.\nexport function formatFunctionDefinitions(functions) {\n    const lines = [\"namespace functions {\", \"\"];\n    for (const f of functions) {\n        if (f.description) {\n            lines.push(`// ${f.description}`);\n        }\n        if (Object.keys(f.parameters.properties ?? {}).length > 0) {\n            lines.push(`type ${f.name} = (_: {`);\n            lines.push(formatObjectProperties(f.parameters, 0));\n            lines.push(\"}) => any;\");\n        }\n        else {\n            lines.push(`type ${f.name} = () => any;`);\n        }\n        lines.push(\"\");\n    }\n    lines.push(\"} // namespace functions\");\n    return lines.join(\"\\n\");\n}\n// Format just the properties of an object (not including the surrounding braces)\nfunction formatObjectProperties(obj, indent) {\n    const lines = [];\n    for (const [name, param] of Object.entries(obj.properties ?? {})) {\n        if (param.description && indent < 2) {\n            lines.push(`// ${param.description}`);\n        }\n        if (obj.required?.includes(name)) {\n            lines.push(`${name}: ${formatType(param, indent)},`);\n        }\n        else {\n            lines.push(`${name}?: ${formatType(param, indent)},`);\n        }\n    }\n    return lines.map((line) => \" \".repeat(indent) + line).join(\"\\n\");\n}\n// Format a single property type\nfunction formatType(param, indent) {\n    if (isAnyOfProp(param)) {\n        return param.anyOf.map((v) => formatType(v, indent)).join(\" | \");\n    }\n    switch (param.type) {\n        case \"string\":\n            if (param.enum) {\n                return param.enum.map((v) => `\"${v}\"`).join(\" | \");\n            }\n            return \"string\";\n        case \"number\":\n            if (param.enum) {\n                return param.enum.map((v) => `${v}`).join(\" | \");\n            }\n            return \"number\";\n        case \"integer\":\n            if (param.enum) {\n                return param.enum.map((v) => `${v}`).join(\" | \");\n            }\n            return \"number\";\n        case \"boolean\":\n            return \"boolean\";\n        case \"null\":\n            return \"null\";\n        case \"object\":\n            return [\"{\", formatObjectProperties(param, indent + 2), \"}\"].join(\"\\n\");\n        case \"array\":\n            if (param.items) {\n                return `${formatType(param.items, indent)}[]`;\n            }\n            return \"any[]\";\n        default:\n            return \"\";\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}