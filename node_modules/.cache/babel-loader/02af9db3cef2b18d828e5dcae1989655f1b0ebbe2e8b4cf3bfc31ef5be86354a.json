{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n  const runtimeEnv = await getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  return runs.map(run => {\n    var _run$extra, _run$revision_id;\n    const extra = (_run$extra = run.extra) !== null && _run$extra !== void 0 ? _run$extra : {};\n    const metadata = extra.metadata;\n    run.extra = {\n      ...extra,\n      runtime: {\n        ...runtimeEnv,\n        ...(extra === null || extra === void 0 ? void 0 : extra.runtime)\n      },\n      metadata: {\n        ...envVars,\n        ...(envVars.revision_id || run.revision_id ? {\n          revision_id: (_run$revision_id = run.revision_id) !== null && _run$revision_id !== void 0 ? _run$revision_id : envVars.revision_id\n        } : {}),\n        ...metadata\n      }\n    };\n    return run;\n  });\n}\nconst getTracingSamplingRate = () => {\n  const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(\"LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: \".concat(samplingRate));\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(\"Failed to \".concat(operation, \": \").concat(response.status, \" \").concat(response.statusText, \" \").concat(body));\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n  if (!uuid.validate(str)) {\n    throw new Error(\"Invalid UUID: \".concat(str));\n  }\n}\nexport class Queue {\n  constructor() {\n    Object.defineProperty(this, \"items\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n  }\n  get size() {\n    return this.items.length;\n  }\n  push(item) {\n    // this.items.push is synchronous with promise creation:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n    return new Promise(resolve => {\n      this.items.push([item, resolve]);\n    });\n  }\n  pop(upToN) {\n    if (upToN < 1) {\n      throw new Error(\"Number of items to pop off may not be less than 1.\");\n    }\n    const popped = [];\n    while (popped.length < upToN && this.items.length) {\n      const item = this.items.shift();\n      if (item) {\n        popped.push(item);\n      } else {\n        break;\n      }\n    }\n    return [popped.map(it => it[0]), () => popped.forEach(it => it[1]())];\n  }\n}\nexport class Client {\n  constructor() {\n    var _trimQuotes, _config$apiUrl, _config$apiKey, _config$webUrl, _config$timeout_ms, _config$callerOptions, _config$hideInputs, _config$hideOutputs, _config$autoBatchTrac, _config$pendingAutoBa;\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sampledPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"batchEndpointSupported\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchQueue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Queue()\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 50\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate();\n    this.apiUrl = (_trimQuotes = trimQuotes((_config$apiUrl = config.apiUrl) !== null && _config$apiUrl !== void 0 ? _config$apiUrl : defaultConfig.apiUrl)) !== null && _trimQuotes !== void 0 ? _trimQuotes : \"\";\n    this.apiKey = trimQuotes((_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : defaultConfig.apiKey);\n    this.webUrl = trimQuotes((_config$webUrl = config.webUrl) !== null && _config$webUrl !== void 0 ? _config$webUrl : defaultConfig.webUrl);\n    this.validateApiKeyIfHosted();\n    this.timeout_ms = (_config$timeout_ms = config.timeout_ms) !== null && _config$timeout_ms !== void 0 ? _config$timeout_ms : 12000;\n    this.caller = new AsyncCaller((_config$callerOptions = config.callerOptions) !== null && _config$callerOptions !== void 0 ? _config$callerOptions : {});\n    this.hideInputs = (_config$hideInputs = config.hideInputs) !== null && _config$hideInputs !== void 0 ? _config$hideInputs : defaultConfig.hideInputs;\n    this.hideOutputs = (_config$hideOutputs = config.hideOutputs) !== null && _config$hideOutputs !== void 0 ? _config$hideOutputs : defaultConfig.hideOutputs;\n    this.autoBatchTracing = (_config$autoBatchTrac = config.autoBatchTracing) !== null && _config$autoBatchTrac !== void 0 ? _config$autoBatchTrac : this.autoBatchTracing;\n    this.pendingAutoBatchedRunLimit = (_config$pendingAutoBa = config.pendingAutoBatchedRunLimit) !== null && _config$pendingAutoBa !== void 0 ? _config$pendingAutoBa : this.pendingAutoBatchedRunLimit;\n  }\n  static getDefaultClientConfig() {\n    var _getEnvironmentVariab;\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = (_getEnvironmentVariab = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\")) !== null && _getEnvironmentVariab !== void 0 ? _getEnvironmentVariab : \"https://api.smith.langchain.com\";\n    const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  validateApiKeyIfHosted() {\n    const isLocal = isLocalhost(this.apiUrl);\n    if (!isLocal && !this.apiKey) {\n      throw new Error(\"API key must be provided when using hosted LangSmith API\");\n    }\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost\";\n      return \"http://localhost\";\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return \"https://dev.smith.langchain.com\";\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return \"https://smith.langchain.com\";\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": \"langsmith-js/\".concat(__version__)\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = \"\".concat(this.apiKey);\n    }\n    return headers;\n  }\n  processInputs(inputs) {\n    if (this.hideInputs) {\n      return {};\n    }\n    return inputs;\n  }\n  processOutputs(outputs) {\n    if (this.hideOutputs) {\n      return {};\n    }\n    return outputs;\n  }\n  prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    var _queryParams$toString;\n    const paramsString = (_queryParams$toString = queryParams === null || queryParams === void 0 ? void 0 : queryParams.toString()) !== null && _queryParams$toString !== void 0 ? _queryParams$toString : \"\";\n    const url = \"\".concat(this.apiUrl).concat(path, \"?\").concat(paramsString);\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  _getPaginated(path) {\n    try {\n      var _this = this;\n      let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();\n      return async function* () {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n          queryParams.set(\"offset\", String(offset));\n          queryParams.set(\"limit\", String(limit));\n          const url = \"\".concat(_this.apiUrl).concat(path, \"?\").concat(queryParams);\n          const response = await _this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: _this.headers,\n            signal: AbortSignal.timeout(_this.timeout_ms)\n          });\n          if (!response.ok) {\n            throw new Error(\"Failed to fetch \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n          }\n          const items = await response.json();\n          if (items.length === 0) {\n            break;\n          }\n          yield items;\n          if (items.length < limit) {\n            break;\n          }\n          offset += items.length;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _getCursorPaginatedList(path) {\n    try {\n      var _this2 = this;\n      let body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let requestMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"POST\";\n      let dataKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"runs\";\n      return async function* () {\n        const bodyParams = body ? {\n          ...body\n        } : {};\n        while (true) {\n          const response = await _this2.caller.call(fetch, \"\".concat(_this2.apiUrl).concat(path), {\n            method: requestMethod,\n            headers: {\n              ..._this2.headers,\n              \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(_this2.timeout_ms),\n            body: JSON.stringify(bodyParams)\n          });\n          const responseBody = await response.json();\n          if (!responseBody) {\n            break;\n          }\n          if (!responseBody[dataKey]) {\n            break;\n          }\n          yield responseBody[dataKey];\n          const cursors = responseBody.cursors;\n          if (!cursors) {\n            break;\n          }\n          if (!cursors.next) {\n            break;\n          }\n          bodyParams.cursor = cursors.next;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _filterForSampling(runs) {\n    let patch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (this.sampledPostUuids.has(run.id)) {\n          sampled.push(run);\n          this.sampledPostUuids.delete(run.id);\n        }\n      }\n      return sampled;\n    } else {\n      const sampled = [];\n      for (const run of runs) {\n        if (Math.random() < this.tracingSampleRate) {\n          sampled.push(run);\n          this.sampledPostUuids.add(run.id);\n        }\n      }\n      return sampled;\n    }\n  }\n  async drainAutoBatchQueue() {\n    while (this.autoBatchQueue.size >= 0) {\n      const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n      if (!batch.length) {\n        done();\n        return;\n      }\n      try {\n        await this.batchIngestRuns({\n          runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n          runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n        });\n      } finally {\n        done();\n      }\n    }\n  }\n  async processRunOperation(item, immediatelyTriggerBatch) {\n    const oldTimeout = this.autoBatchTimeout;\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    const itemPromise = this.autoBatchQueue.push(item);\n    if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n      await this.drainAutoBatchQueue();\n    }\n    if (this.autoBatchQueue.size > 0) {\n      this.autoBatchTimeout = setTimeout(() => {\n        this.autoBatchTimeout = undefined;\n        void this.drainAutoBatchQueue();\n      }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n    }\n    return itemPromise;\n  }\n  async batchEndpointIsSupported() {\n    const response = await fetch(\"\".concat(this.apiUrl, \"/info\"), {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      // consume the response body to release the connection\n      // https://undici.nodejs.org/#/?id=garbage-collection\n      await response.text();\n      return false;\n    }\n    return true;\n  }\n  async createRun(run) {\n    var _run$start_time;\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: (_run$start_time = run.start_time) !== null && _run$start_time !== void 0 ? _run$start_time : Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      void this.processRunOperation({\n        action: \"create\",\n        item: runCreate\n      });\n      return;\n    }\n    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([runCreate]);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs\"), {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(mergedRunCreateParams[0]),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns(_ref) {\n    var _runCreates$map, _runUpdates$map;\n    let {\n      runCreates,\n      runUpdates\n    } = _ref;\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = (_runCreates$map = runCreates === null || runCreates === void 0 ? void 0 : runCreates.map(create => this.prepareRunCreateOrUpdateInputs(create))) !== null && _runCreates$map !== void 0 ? _runCreates$map : [];\n    let preparedUpdateParams = (_runUpdates$map = runUpdates === null || runUpdates === void 0 ? void 0 : runUpdates.map(update => this.prepareRunCreateOrUpdateInputs(update))) !== null && _runUpdates$map !== void 0 ? _runUpdates$map : [];\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const body = {\n      post: this._filterForSampling(preparedCreateParams),\n      patch: this._filterForSampling(preparedUpdateParams, true)\n    };\n    if (!body.post.length && !body.patch.length) {\n      return;\n    }\n    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n    if (this.batchEndpointSupported === undefined) {\n      this.batchEndpointSupported = await this.batchEndpointIsSupported();\n    }\n    if (!this.batchEndpointSupported) {\n      this.autoBatchTracing = false;\n      for (const preparedCreateParam of body.post) {\n        await this.createRun(preparedCreateParam);\n      }\n      for (const preparedUpdateParam of body.patch) {\n        if (preparedUpdateParam.id !== undefined) {\n          await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n        }\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/batch\"), {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"batch create run\");\n  }\n  async updateRun(runId, run) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      if (run.end_time !== undefined && data.parent_run_id === undefined) {\n        // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n        // in serverless environments.\n        await this.processRunOperation({\n          action: \"update\",\n          item: data\n        }, true);\n        return;\n      } else {\n        void this.processRunOperation({\n          action: \"update\",\n          item: data\n        });\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId), {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId) {\n    let {\n      loadChildRuns\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      loadChildRuns: false\n    };\n    assertUuid(runId);\n    let run = await this._get(\"/runs/\".concat(runId));\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl(_ref2) {\n    let {\n      runId,\n      run,\n      projectOpts\n    } = _ref2;\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts !== null && projectOpts !== void 0 && projectOpts.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts === null || projectOpts === void 0 ? void 0 : projectOpts.projectName\n        })).id;\n      } else if (projectOpts !== null && projectOpts !== void 0 && projectOpts.projectId) {\n        sessionId = projectOpts === null || projectOpts === void 0 ? void 0 : projectOpts.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return \"\".concat(this.getHostUrl(), \"/o/\").concat(tenantId, \"/projects/p/\").concat(sessionId, \"/r/\").concat(run.id, \"?poll=true\");\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(\"Run \".concat(runId, \" has no app_path\"));\n      }\n      const baseUrl = this.getHostUrl();\n      return \"\".concat(baseUrl).concat(run_.app_path);\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => {\n      var _a$dotted_order, _b$dotted_order;\n      return ((_a$dotted_order = a === null || a === void 0 ? void 0 : a.dotted_order) !== null && _a$dotted_order !== void 0 ? _a$dotted_order : \"\").localeCompare((_b$dotted_order = b === null || b === void 0 ? void 0 : b.dotted_order) !== null && _b$dotted_order !== void 0 ? _b$dotted_order : \"\");\n    });\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(\"Child run \".concat(childRun.id, \" has no parent\"));\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  listRuns(_ref3) {\n    try {\n      var _this3 = this;\n      let {\n        projectId,\n        projectName,\n        parentRunId,\n        traceId,\n        referenceExampleId,\n        startTime,\n        executionOrder,\n        runType,\n        error,\n        id,\n        query,\n        filter,\n        limit\n      } = _ref3;\n      return async function* () {\n        let projectIds = [];\n        if (projectId) {\n          projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n          const projectNames = Array.isArray(projectName) ? projectName : [projectName];\n          const projectIds_ = await Promise.all(projectNames.map(name => _this3.readProject({\n            projectName: name\n          }).then(project => project.id)));\n          projectIds.push(...projectIds_);\n        }\n        const body = {\n          session: projectIds.length ? projectIds : null,\n          run_type: runType,\n          reference_example: referenceExampleId,\n          query,\n          filter,\n          execution_order: executionOrder,\n          parent_run: parentRunId ? [parentRunId] : null,\n          start_time: startTime ? startTime.toISOString() : null,\n          error,\n          id,\n          limit,\n          trace: traceId\n        };\n        for await (const runs of _this3._getCursorPaginatedList(\"/runs/query\", body)) {\n          yield* runs;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async shareRun(runId) {\n    let {\n      shareId\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId, \"/share\"), {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return \"\".concat(this.getHostUrl(), \"/public/\").concat(result[\"share_token\"], \"/r\");\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId, \"/share\"), {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId, \"/share\"), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return \"\".concat(this.getHostUrl(), \"/public/\").concat(result[\"share_token\"], \"/r\");\n  }\n  async listSharedRuns(shareToken) {\n    let {\n      runIds\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/public/\").concat(shareToken, \"/runs\").concat(queryParams), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets/\").concat(datasetId, \"/share\"), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = \"\".concat(this.getHostUrl(), \"/public/\").concat(shareSchema.share_token, \"/d\");\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets/\").concat(datasetId, \"/share\"), {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = \"\".concat(this.getHostUrl(), \"/public/\").concat(shareSchema.share_token, \"/d\");\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets/\").concat(datasetId, \"/share\"), {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare dataset\");\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/public/\").concat(shareToken, \"/datasets\"), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  async createProject(_ref4) {\n    let {\n      projectName,\n      description = null,\n      metadata = null,\n      upsert = false,\n      projectExtra = null,\n      referenceDatasetId = null\n    } = _ref4;\n    const upsert_ = upsert ? \"?upsert=true\" : \"\";\n    const endpoint = \"\".concat(this.apiUrl, \"/sessions\").concat(upsert_);\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(\"Failed to create session \".concat(projectName, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    return result;\n  }\n  async updateProject(projectId, _ref5) {\n    let {\n      name = null,\n      description = null,\n      metadata = null,\n      projectExtra = null,\n      endTime = null\n    } = _ref5;\n    const endpoint = \"\".concat(this.apiUrl, \"/sessions/\").concat(projectId);\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(\"Failed to update project \".concat(projectId, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    return result;\n  }\n  async hasProject(_ref6) {\n    let {\n      projectId,\n      projectName\n    } = _ref6;\n    // TODO: Add a head request\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += \"/\".concat(projectId);\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl).concat(path, \"?\").concat(params), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    try {\n      const result = await response.json();\n      if (!response.ok) {\n        return false;\n      }\n      // If it's OK and we're querying by name, need to check the list is not empty\n      if (Array.isArray(result)) {\n        return result.length > 0;\n      }\n      // projectId querying\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async readProject(_ref7) {\n    let {\n      projectId,\n      projectName,\n      includeStats\n    } = _ref7;\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += \"/\".concat(projectId);\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(\"Project[id=\".concat(projectId, \", name=\").concat(projectName, \"] not found\"));\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  listProjects() {\n    try {\n      var _this4 = this;\n      let {\n        projectIds,\n        name,\n        nameContains,\n        referenceDatasetId,\n        referenceDatasetName,\n        referenceFree\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n          for (const projectId of projectIds) {\n            params.append(\"id\", projectId);\n          }\n        }\n        if (name !== undefined) {\n          params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n          params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n          params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n          const dataset = await _this4.readDataset({\n            datasetName: referenceDatasetName\n          });\n          params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n          params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of _this4._getPaginated(\"/sessions\", params)) {\n          yield* projects;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async deleteProject(_ref8) {\n    let {\n      projectId,\n      projectName\n    } = _ref8;\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/sessions/\").concat(projectId_), {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"delete session \".concat(projectId_, \" (\").concat(projectName, \")\"));\n  }\n  async uploadCsv(_ref9) {\n    let {\n      csvFile,\n      fileName,\n      inputKeys,\n      outputKeys,\n      description,\n      dataType,\n      name\n    } = _ref9;\n    const url = \"\".concat(this.apiUrl, \"/datasets/upload\");\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(\"Dataset \".concat(fileName, \" already exists\"));\n      }\n      throw new Error(\"Failed to upload CSV: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name) {\n    let {\n      description,\n      dataType\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets\"), {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(\"Dataset \".concat(name, \" already exists\"));\n      }\n      throw new Error(\"Failed to create dataset \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset(_ref10) {\n    let {\n      datasetId,\n      datasetName\n    } = _ref10;\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      assertUuid(datasetId);\n      path += \"/\".concat(datasetId);\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(\"Dataset[id=\".concat(datasetId, \", name=\").concat(datasetName, \"] not found\"));\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async readDatasetOpenaiFinetuning(_ref11) {\n    let {\n      datasetId,\n      datasetName\n    } = _ref11;\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._getResponse(\"\".concat(path, \"/\").concat(datasetId, \"/openai_ft\"));\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  listDatasets() {\n    try {\n      var _this5 = this;\n      let {\n        limit = 100,\n        offset = 0,\n        datasetIds,\n        datasetName,\n        datasetNameContains\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n          limit: limit.toString(),\n          offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n          for (const id_ of datasetIds) {\n            params.append(\"id\", id_);\n          }\n        }\n        if (datasetName !== undefined) {\n          params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n          params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of _this5._getPaginated(path, params)) {\n          yield* datasets;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async deleteDataset(_ref12) {\n    let {\n      datasetId,\n      datasetName\n    } = _ref12;\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += \"/\".concat(datasetId_);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to delete \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, _ref13) {\n    let {\n      datasetId,\n      datasetName,\n      createdAt,\n      exampleId\n    } = _ref13;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_ === null || createdAt_ === void 0 ? void 0 : createdAt_.toISOString(),\n      id: exampleId\n    };\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/examples\"), {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to create example: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createExamples(props) {\n    const {\n      inputs,\n      outputs,\n      sourceRunIds,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = props;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs ? outputs[idx] : undefined,\n        id: exampleIds ? exampleIds[idx] : undefined,\n        source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n      };\n    });\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/examples/bulk\"), {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(formattedExamples),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to create examples: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = \"/examples/\".concat(exampleId);\n    return await this._get(path);\n  }\n  listExamples() {\n    try {\n      var _this6 = this;\n      let {\n        datasetId,\n        datasetName,\n        exampleIds\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n          throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n          datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n          const dataset = await _this6.readDataset({\n            datasetName\n          });\n          datasetId_ = dataset.id;\n        } else {\n          throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n          dataset: datasetId_\n        });\n        if (exampleIds !== undefined) {\n          for (const id_ of exampleIds) {\n            params.append(\"id\", id_);\n          }\n        }\n        for await (const examples of _this6._getPaginated(\"/examples\", params)) {\n          yield* examples;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = \"/examples/\".concat(exampleId);\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to delete \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    assertUuid(exampleId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/examples/\").concat(exampleId), {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to update example \".concat(exampleId, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator) {\n    var _feedbackResult$targe;\n    let {\n      sourceInfo,\n      loadChildRuns,\n      referenceExample\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      loadChildRuns: false\n    };\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(\"Invalid run type: \".concat(typeof run));\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo !== null && sourceInfo !== void 0 ? sourceInfo : {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    const runId = (_feedbackResult$targe = feedbackResult.targetRunId) !== null && _feedbackResult$targe !== void 0 ? _feedbackResult$targe : run_.id;\n    return await this.createFeedback(runId, feedbackResult.key, {\n      score: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.score,\n      value: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.value,\n      comment: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.comment,\n      correction: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"model\",\n      sourceRunId: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.sourceRunId\n    });\n  }\n  async createFeedback(runId, key, _ref14) {\n    var _feedback_source$meta;\n    let {\n      score,\n      value,\n      correction,\n      comment,\n      sourceInfo,\n      feedbackSourceType = \"api\",\n      sourceRunId,\n      feedbackId,\n      eager = false\n    } = _ref14;\n    const feedback_source = {\n      type: feedbackSourceType !== null && feedbackSourceType !== void 0 ? feedbackSourceType : \"api\",\n      metadata: sourceInfo !== null && sourceInfo !== void 0 ? sourceInfo : {}\n    };\n    if (sourceRunId !== undefined && (feedback_source === null || feedback_source === void 0 ? void 0 : feedback_source.metadata) !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if ((feedback_source === null || feedback_source === void 0 ? void 0 : feedback_source.metadata) !== undefined && ((_feedback_source$meta = feedback_source.metadata[\"__run\"]) === null || _feedback_source$meta === void 0 ? void 0 : _feedback_source$meta.run_id) !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId !== null && feedbackId !== void 0 ? feedbackId : uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source\n    };\n    const url = \"\".concat(this.apiUrl, \"/feedback\") + (eager ? \"/eager\" : \"\");\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create feedback\");\n    return feedback;\n  }\n  async updateFeedback(feedbackId, _ref15) {\n    let {\n      score,\n      value,\n      correction,\n      comment\n    } = _ref15;\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/feedback/\").concat(feedbackId), {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update feedback\");\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = \"/feedback/\".concat(feedbackId);\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = \"/feedback/\".concat(feedbackId);\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to delete \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    await response.json();\n  }\n  listFeedback() {\n    try {\n      var _this7 = this;\n      let {\n        runIds,\n        feedbackKeys,\n        feedbackSourceTypes\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n          queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n          for (const key of feedbackKeys) {\n            queryParams.append(\"key\", key);\n          }\n        }\n        if (feedbackSourceTypes) {\n          for (const type of feedbackSourceTypes) {\n            queryParams.append(\"source\", type);\n          }\n        }\n        for await (const feedbacks of _this7._getPaginated(\"/feedback\", queryParams)) {\n          yield* feedbacks;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getRuntimeEnvironment","__version__","mergeRuntimeEnvIntoRunCreates","runs","runtimeEnv","envVars","map","run","_run$extra","_run$revision_id","extra","metadata","runtime","revision_id","getTracingSamplingRate","samplingRateStr","undefined","samplingRate","parseFloat","Error","concat","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","trim","assertUuid","validate","Queue","constructor","Object","defineProperty","enumerable","configurable","writable","value","size","items","length","Promise","resolve","pop","upToN","popped","shift","it","forEach","Client","_trimQuotes","_config$apiUrl","_config$apiKey","_config$webUrl","_config$timeout_ms","_config$callerOptions","_config$hideInputs","_config$hideOutputs","_config$autoBatchTrac","_config$pendingAutoBa","config","arguments","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","apiUrl","apiKey","webUrl","validateApiKeyIfHosted","timeout_ms","caller","callerOptions","hideInputs","hideOutputs","autoBatchTracing","pendingAutoBatchedRunLimit","_getEnvironmentVariab","isLocal","getHostUrl","includes","endsWith","headers","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","path","queryParams","_queryParams$toString","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","_get","json","_getPaginated","_this","URLSearchParams","offset","Number","get","limit","set","String","e","reject","_getCursorPaginatedList","_this2","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_filterForSampling","patch","sampled","sampledPostUuids","has","id","delete","Math","random","add","drainAutoBatchQueue","autoBatchQueue","batch","done","batchIngestRuns","runCreates","filter","action","runUpdates","processRunOperation","immediatelyTriggerBatch","oldTimeout","autoBatchTimeout","clearTimeout","itemPromise","setTimeout","autoBatchAggregationDelayMs","autoBatchInitialDelayMs","batchEndpointIsSupported","Accept","createRun","_run$start_time","session_name","project_name","runCreate","start_time","Date","now","trace_id","dotted_order","mergedRunCreateParams","_ref","_runCreates$map","_runUpdates$map","preparedCreateParams","create","preparedUpdateParams","update","createById","reduce","params","standaloneUpdates","updateParam","values","post","batchEndpointSupported","preparedCreateParam","preparedUpdateParam","updateRun","runId","data","end_time","parent_run_id","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","_ref2","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","treemap","sort","a","b","_a$dotted_order","_b$dotted_order","localeCompare","childRun","child_runs","_ref3","_this3","parentRunId","traceId","referenceExampleId","startTime","executionOrder","runType","error","query","projectIds","Array","isArray","projectNames","projectIds_","all","name","then","session","run_type","reference_example","execution_order","parent_run","toISOString","trace","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","runIds","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","createProject","_ref4","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","updateProject","_ref5","endTime","hasProject","_ref6","_ref7","includeStats","_tenantId","projects","tenant_id","listProjects","_this4","nameContains","referenceDatasetName","referenceFree","deleteProject","_ref8","projectId_","uploadCsv","_ref9","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","key","detail","createDataset","data_type","_ref10","readDatasetOpenaiFinetuning","_ref11","datasetText","line","parse","listDatasets","_this5","datasetIds","datasetNameContains","id_","datasets","deleteDataset","_ref12","datasetId_","createExample","_ref13","createdAt","exampleId","createdAt_","created_at","createExamples","props","sourceRunIds","exampleIds","formattedExamples","input","idx","source_run_id","createLLMExample","generation","options","output","createChatExample","generations","finalInput","message","finalOutput","readExample","listExamples","_this6","examples","deleteExample","updateExample","evaluateRun","evaluator","_feedbackResult$targe","sourceInfo","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","targetRunId","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","_ref14","_feedback_source$meta","feedbackId","eager","feedback_source","type","feedback","updateFeedback","_ref15","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","_this7","feedbackKeys","feedbackSourceTypes","join","feedbacks"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    return runs.map((run) => {\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime,\n            },\n            metadata: {\n                ...envVars,\n                ...(envVars.revision_id || run.revision_id\n                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n                    : {}),\n                ...metadata,\n            },\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid.validate(str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nexport class Queue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    get size() {\n        return this.items.length;\n    }\n    push(item) {\n        // this.items.push is synchronous with promise creation:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n        return new Promise((resolve) => {\n            this.items.push([item, resolve]);\n        });\n    }\n    pop(upToN) {\n        if (upToN < 1) {\n            throw new Error(\"Number of items to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        while (popped.length < upToN && this.items.length) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n            }\n            else {\n                break;\n            }\n        }\n        return [popped.map((it) => it[0]), () => popped.forEach((it) => it[1]())];\n    }\n}\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"batchEndpointSupported\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit =\n            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs) {\n            return {};\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs) {\n            return {};\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async drainAutoBatchQueue() {\n        while (this.autoBatchQueue.size >= 0) {\n            const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                await this.batchIngestRuns({\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                });\n            }\n            finally {\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (immediatelyTriggerBatch ||\n            this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {\n            await this.drainAutoBatchQueue();\n        }\n        if (this.autoBatchQueue.size > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue();\n            }, oldTimeout\n                ? this.autoBatchAggregationDelayMs\n                : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async batchEndpointIsSupported() {\n        const response = await fetch(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: { Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            // consume the response body to release the connection\n            // https://undici.nodejs.org/#/?id=garbage-collection\n            await response.text();\n            return false;\n        }\n        return true;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n            });\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate,\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const body = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!body.post.length && !body.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        if (this.batchEndpointSupported === undefined) {\n            this.batchEndpointSupported = await this.batchEndpointIsSupported();\n        }\n        if (!this.batchEndpointSupported) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of body.post) {\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of body.patch) {\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({ action: \"update\", item: data }, true);\n                return;\n            }\n            else {\n                void this.processRunOperation({ action: \"update\", item: data });\n            }\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, limit, }) {\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            execution_order: executionOrder,\n            parent_run: parentRunId ? [parentRunId] : null,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId,\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, eager = false, }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n        };\n        const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}