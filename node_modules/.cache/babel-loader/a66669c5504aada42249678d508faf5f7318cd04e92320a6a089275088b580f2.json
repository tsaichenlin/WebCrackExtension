{"ast":null,"code":"import { BaseCallbackHandler } from \"../callbacks/base.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\nfunction stripNonAlphanumeric(input) {\n  return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId) {\n  return stripNonAlphanumeric(\"\".concat(new Date(epoch).toISOString().slice(0, -1), \"000Z\")) + runId;\n}\nexport class BaseTracer extends BaseCallbackHandler {\n  constructor(_fields) {\n    super(...arguments);\n    Object.defineProperty(this, \"runMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n  }\n  copy() {\n    return this;\n  }\n  stringifyError(error) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error !== null && error !== void 0 && error.stack ? \"\\n\\n\".concat(error.stack) : \"\");\n    }\n    if (typeof error === \"string\") {\n      return error;\n    }\n    return \"\".concat(error);\n  }\n  _addChildRun(parentRun, childRun) {\n    parentRun.child_runs.push(childRun);\n  }\n  async _startTrace(run) {\n    var _this$onRunCreate;\n    const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id);\n    const storedRun = {\n      ...run\n    };\n    if (storedRun.parent_run_id !== undefined) {\n      const parentRun = this.runMap.get(storedRun.parent_run_id);\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(\".\");\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n    }\n    this.runMap.set(storedRun.id, storedRun);\n    await ((_this$onRunCreate = this.onRunCreate) === null || _this$onRunCreate === void 0 ? void 0 : _this$onRunCreate.call(this, storedRun));\n  }\n  async _endTrace(run) {\n    var _this$onRunUpdate;\n    const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n    } else {\n      await this.persistRun(run);\n    }\n    this.runMap.delete(run.id);\n    await ((_this$onRunUpdate = this.onRunUpdate) === null || _this$onRunUpdate === void 0 ? void 0 : _this$onRunUpdate.call(this, run));\n  }\n  _getExecutionOrder(parentRunId) {\n    const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n    return parentRun.child_execution_order + 1;\n  }\n  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n    var _this$onLLMStart;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata ? {\n      ...extraParams,\n      metadata\n    } : extraParams;\n    const run = {\n      id: runId,\n      name: name !== null && name !== void 0 ? name : llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        prompts\n      },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams !== null && finalExtraParams !== void 0 ? finalExtraParams : {},\n      tags: tags || []\n    };\n    await this._startTrace(run);\n    await ((_this$onLLMStart = this.onLLMStart) === null || _this$onLLMStart === void 0 ? void 0 : _this$onLLMStart.call(this, run));\n    return run;\n  }\n  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n    var _this$onLLMStart2;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata ? {\n      ...extraParams,\n      metadata\n    } : extraParams;\n    const run = {\n      id: runId,\n      name: name !== null && name !== void 0 ? name : llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        messages\n      },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams !== null && finalExtraParams !== void 0 ? finalExtraParams : {},\n      tags: tags || []\n    };\n    await this._startTrace(run);\n    await ((_this$onLLMStart2 = this.onLLMStart) === null || _this$onLLMStart2 === void 0 ? void 0 : _this$onLLMStart2.call(this, run));\n    return run;\n  }\n  async handleLLMEnd(output, runId) {\n    var _this$onLLMEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await ((_this$onLLMEnd = this.onLLMEnd) === null || _this$onLLMEnd === void 0 ? void 0 : _this$onLLMEnd.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleLLMError(error, runId) {\n    var _this$onLLMError;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await ((_this$onLLMError = this.onLLMError) === null || _this$onLLMError === void 0 ? void 0 : _this$onLLMError.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n    var _this$onChainStart;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: name !== null && name !== void 0 ? name : chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType !== null && runType !== void 0 ? runType : \"chain\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    await this._startTrace(run);\n    await ((_this$onChainStart = this.onChainStart) === null || _this$onChainStart === void 0 ? void 0 : _this$onChainStart.call(this, run));\n    return run;\n  }\n  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n    var _this$onChainEnd;\n    const run = this.runMap.get(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    if ((kwargs === null || kwargs === void 0 ? void 0 : kwargs.inputs) !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await ((_this$onChainEnd = this.onChainEnd) === null || _this$onChainEnd === void 0 ? void 0 : _this$onChainEnd.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n    var _this$onChainError;\n    const run = this.runMap.get(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    if ((kwargs === null || kwargs === void 0 ? void 0 : kwargs.inputs) !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await ((_this$onChainError = this.onChainError) === null || _this$onChainError === void 0 ? void 0 : _this$onChainError.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n    var _this$onToolStart;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: name !== null && name !== void 0 ? name : tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        input\n      },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    await this._startTrace(run);\n    await ((_this$onToolStart = this.onToolStart) === null || _this$onToolStart === void 0 ? void 0 : _this$onToolStart.call(this, run));\n    return run;\n  }\n  async handleToolEnd(output, runId) {\n    var _this$onToolEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = {\n      output\n    };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await ((_this$onToolEnd = this.onToolEnd) === null || _this$onToolEnd === void 0 ? void 0 : _this$onToolEnd.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleToolError(error, runId) {\n    var _this$onToolError;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await ((_this$onToolError = this.onToolError) === null || _this$onToolError === void 0 ? void 0 : _this$onToolError.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleAgentAction(action, runId) {\n    var _this$onAgentAction;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"chain\") {\n      return;\n    }\n    const agentRun = run;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: {\n        action\n      }\n    });\n    await ((_this$onAgentAction = this.onAgentAction) === null || _this$onAgentAction === void 0 ? void 0 : _this$onAgentAction.call(this, run));\n  }\n  async handleAgentEnd(action, runId) {\n    var _this$onAgentEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: {\n        action\n      }\n    });\n    await ((_this$onAgentEnd = this.onAgentEnd) === null || _this$onAgentEnd === void 0 ? void 0 : _this$onAgentEnd.call(this, run));\n  }\n  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n    var _this$onRetrieverStar;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: name !== null && name !== void 0 ? name : retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        query\n      },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    await this._startTrace(run);\n    await ((_this$onRetrieverStar = this.onRetrieverStart) === null || _this$onRetrieverStar === void 0 ? void 0 : _this$onRetrieverStar.call(this, run));\n    return run;\n  }\n  async handleRetrieverEnd(documents, runId) {\n    var _this$onRetrieverEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = {\n      documents\n    };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await ((_this$onRetrieverEnd = this.onRetrieverEnd) === null || _this$onRetrieverEnd === void 0 ? void 0 : _this$onRetrieverEnd.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleRetrieverError(error, runId) {\n    var _this$onRetrieverErro;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await ((_this$onRetrieverErro = this.onRetrieverError) === null || _this$onRetrieverErro === void 0 ? void 0 : _this$onRetrieverErro.call(this, run));\n    await this._endTrace(run);\n    return run;\n  }\n  async handleText(text, runId) {\n    var _this$onText;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: {\n        text\n      }\n    });\n    await ((_this$onText = this.onText) === null || _this$onText === void 0 ? void 0 : _this$onText.call(this, run));\n  }\n  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n    var _this$onLLMNewToken;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"llm\") {\n      throw new Error(\"Invalid \\\"runId\\\" provided to \\\"handleLLMNewToken\\\" callback.\");\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: {\n        token,\n        idx,\n        chunk: fields === null || fields === void 0 ? void 0 : fields.chunk\n      }\n    });\n    await ((_this$onLLMNewToken = this.onLLMNewToken) === null || _this$onLLMNewToken === void 0 ? void 0 : _this$onLLMNewToken.call(this, run, token, {\n      chunk: fields === null || fields === void 0 ? void 0 : fields.chunk\n    }));\n    return run;\n  }\n}","map":{"version":3,"names":["BaseCallbackHandler","_coerceToDict","value","defaultKey","Array","isArray","stripNonAlphanumeric","input","replace","convertToDottedOrderFormat","epoch","runId","concat","Date","toISOString","slice","BaseTracer","constructor","_fields","arguments","Object","defineProperty","enumerable","configurable","writable","Map","copy","stringifyError","error","Error","message","stack","_addChildRun","parentRun","childRun","child_runs","push","_startTrace","run","_this$onRunCreate","currentDottedOrder","start_time","id","storedRun","parent_run_id","undefined","runMap","get","child_execution_order","Math","max","trace_id","dotted_order","join","set","onRunCreate","call","_endTrace","_this$onRunUpdate","persistRun","delete","onRunUpdate","_getExecutionOrder","parentRunId","handleLLMStart","llm","prompts","extraParams","tags","metadata","name","_this$onLLMStart","execution_order","now","finalExtraParams","length","serialized","events","time","inputs","run_type","extra","onLLMStart","handleChatModelStart","messages","_this$onLLMStart2","handleLLMEnd","output","_this$onLLMEnd","end_time","outputs","onLLMEnd","handleLLMError","_this$onLLMError","onLLMError","handleChainStart","chain","runType","_this$onChainStart","onChainStart","handleChainEnd","_parentRunId","_tags","kwargs","_this$onChainEnd","onChainEnd","handleChainError","_this$onChainError","onChainError","handleToolStart","tool","_this$onToolStart","onToolStart","handleToolEnd","_this$onToolEnd","onToolEnd","handleToolError","_this$onToolError","onToolError","handleAgentAction","action","_this$onAgentAction","agentRun","actions","onAgentAction","handleAgentEnd","_this$onAgentEnd","onAgentEnd","handleRetrieverStart","retriever","query","_this$onRetrieverStar","onRetrieverStart","handleRetrieverEnd","documents","_this$onRetrieverEnd","onRetrieverEnd","handleRetrieverError","_this$onRetrieverErro","onRetrieverError","handleText","text","_this$onText","onText","handleLLMNewToken","token","idx","fields","_this$onLLMNewToken","chunk","onLLMNewToken"],"sources":["/Users/mandylin/Desktop/WebCrack React 2/webcrack/node_modules/@langchain/core/dist/tracers/base.js"],"sourcesContent":["import { BaseCallbackHandler, } from \"../callbacks/base.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId) {\n    return (stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}000Z`) +\n        runId);\n}\nexport class BaseTracer extends BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    copy() {\n        return this;\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    async _startTrace(run) {\n        const currentDottedOrder = convertToDottedOrderFormat(run.start_time, run.id);\n        const storedRun = { ...run };\n        if (storedRun.parent_run_id !== undefined) {\n            const parentRun = this.runMap.get(storedRun.parent_run_id);\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n        }\n        this.runMap.set(storedRun.id, storedRun);\n        await this.onRunCreate?.(storedRun);\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        this.runMap.delete(run.id);\n        await this.onRunUpdate?.(run);\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    async handleToolEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        await this._startTrace(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}