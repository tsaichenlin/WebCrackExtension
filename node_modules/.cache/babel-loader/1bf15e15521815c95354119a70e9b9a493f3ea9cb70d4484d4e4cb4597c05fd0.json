{"ast":null,"code":"import { deepCompareStrict } from \"./deep-compare-strict.js\";\nimport { dereference } from \"./dereference.js\";\nimport { fastFormat } from \"./format.js\";\nimport { encodePointer } from \"./pointer.js\";\nimport { ucs2length } from \"./ucs2-length.js\";\nexport function validate(instance, schema) {\n  let draft = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"2019-09\";\n  let lookup = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : dereference(schema);\n  let shortCircuit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let recursiveAnchor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  let instanceLocation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : \"#\";\n  let schemaLocation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : \"#\";\n  let evaluated = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Object.create(null);\n  if (schema === true) {\n    return {\n      valid: true,\n      errors: []\n    };\n  }\n  if (schema === false) {\n    return {\n      valid: false,\n      errors: [{\n        instanceLocation,\n        keyword: \"false\",\n        keywordLocation: instanceLocation,\n        error: \"False boolean schema.\"\n      }]\n    };\n  }\n  const rawInstanceType = typeof instance;\n  let instanceType;\n  switch (rawInstanceType) {\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n      instanceType = rawInstanceType;\n      break;\n    case \"object\":\n      if (instance === null) {\n        instanceType = \"null\";\n      } else if (Array.isArray(instance)) {\n        instanceType = \"array\";\n      } else {\n        instanceType = \"object\";\n      }\n      break;\n    default:\n      // undefined, bigint, function, symbol\n      throw new Error(\"Instances of \\\"\".concat(rawInstanceType, \"\\\" type are not supported.\"));\n  }\n  const {\n    $ref,\n    $recursiveRef,\n    $recursiveAnchor,\n    type: $type,\n    const: $const,\n    enum: $enum,\n    required: $required,\n    not: $not,\n    anyOf: $anyOf,\n    allOf: $allOf,\n    oneOf: $oneOf,\n    if: $if,\n    then: $then,\n    else: $else,\n    format: $format,\n    properties: $properties,\n    patternProperties: $patternProperties,\n    additionalProperties: $additionalProperties,\n    unevaluatedProperties: $unevaluatedProperties,\n    minProperties: $minProperties,\n    maxProperties: $maxProperties,\n    propertyNames: $propertyNames,\n    dependentRequired: $dependentRequired,\n    dependentSchemas: $dependentSchemas,\n    dependencies: $dependencies,\n    prefixItems: $prefixItems,\n    items: $items,\n    additionalItems: $additionalItems,\n    unevaluatedItems: $unevaluatedItems,\n    contains: $contains,\n    minContains: $minContains,\n    maxContains: $maxContains,\n    minItems: $minItems,\n    maxItems: $maxItems,\n    uniqueItems: $uniqueItems,\n    minimum: $minimum,\n    maximum: $maximum,\n    exclusiveMinimum: $exclusiveMinimum,\n    exclusiveMaximum: $exclusiveMaximum,\n    multipleOf: $multipleOf,\n    minLength: $minLength,\n    maxLength: $maxLength,\n    pattern: $pattern,\n    __absolute_ref__,\n    __absolute_recursive_ref__\n  } = schema;\n  const errors = [];\n  if ($recursiveAnchor === true && recursiveAnchor === null) {\n    recursiveAnchor = schema;\n  }\n  if ($recursiveRef === \"#\") {\n    const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;\n    const keywordLocation = \"\".concat(schemaLocation, \"/$recursiveRef\");\n    const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"$recursiveRef\",\n        keywordLocation,\n        error: \"A subschema had errors.\"\n      }, ...result.errors);\n    }\n  }\n  if ($ref !== undefined) {\n    const uri = __absolute_ref__ || $ref;\n    const refSchema = lookup[uri];\n    if (refSchema === undefined) {\n      let message = \"Unresolved $ref \\\"\".concat($ref, \"\\\".\");\n      if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n        message += \"  Absolute URI \\\"\".concat(__absolute_ref__, \"\\\".\");\n      }\n      message += \"\\nKnown schemas:\\n- \".concat(Object.keys(lookup).join(\"\\n- \"));\n      throw new Error(message);\n    }\n    const keywordLocation = \"\".concat(schemaLocation, \"/$ref\");\n    const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"$ref\",\n        keywordLocation,\n        error: \"A subschema had errors.\"\n      }, ...result.errors);\n    }\n    if (draft === \"4\" || draft === \"7\") {\n      return {\n        valid: errors.length === 0,\n        errors\n      };\n    }\n  }\n  if (Array.isArray($type)) {\n    let length = $type.length;\n    let valid = false;\n    for (let i = 0; i < length; i++) {\n      if (instanceType === $type[i] || $type[i] === \"integer\" && instanceType === \"number\" && instance % 1 === 0 && instance === instance) {\n        valid = true;\n        break;\n      }\n    }\n    if (!valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"type\",\n        keywordLocation: \"\".concat(schemaLocation, \"/type\"),\n        error: \"Instance type \\\"\".concat(instanceType, \"\\\" is invalid. Expected \\\"\").concat($type.join('\", \"'), \"\\\".\")\n      });\n    }\n  } else if ($type === \"integer\") {\n    if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n      errors.push({\n        instanceLocation,\n        keyword: \"type\",\n        keywordLocation: \"\".concat(schemaLocation, \"/type\"),\n        error: \"Instance type \\\"\".concat(instanceType, \"\\\" is invalid. Expected \\\"\").concat($type, \"\\\".\")\n      });\n    }\n  } else if ($type !== undefined && instanceType !== $type) {\n    errors.push({\n      instanceLocation,\n      keyword: \"type\",\n      keywordLocation: \"\".concat(schemaLocation, \"/type\"),\n      error: \"Instance type \\\"\".concat(instanceType, \"\\\" is invalid. Expected \\\"\").concat($type, \"\\\".\")\n    });\n  }\n  if ($const !== undefined) {\n    if (instanceType === \"object\" || instanceType === \"array\") {\n      if (!deepCompareStrict(instance, $const)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"const\",\n          keywordLocation: \"\".concat(schemaLocation, \"/const\"),\n          error: \"Instance does not match \".concat(JSON.stringify($const), \".\")\n        });\n      }\n    } else if (instance !== $const) {\n      errors.push({\n        instanceLocation,\n        keyword: \"const\",\n        keywordLocation: \"\".concat(schemaLocation, \"/const\"),\n        error: \"Instance does not match \".concat(JSON.stringify($const), \".\")\n      });\n    }\n  }\n  if ($enum !== undefined) {\n    if (instanceType === \"object\" || instanceType === \"array\") {\n      if (!$enum.some(value => deepCompareStrict(instance, value))) {\n        errors.push({\n          instanceLocation,\n          keyword: \"enum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/enum\"),\n          error: \"Instance does not match any of \".concat(JSON.stringify($enum), \".\")\n        });\n      }\n    } else if (!$enum.some(value => instance === value)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"enum\",\n        keywordLocation: \"\".concat(schemaLocation, \"/enum\"),\n        error: \"Instance does not match any of \".concat(JSON.stringify($enum), \".\")\n      });\n    }\n  }\n  if ($not !== undefined) {\n    const keywordLocation = \"\".concat(schemaLocation, \"/not\");\n    const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation /*,\n                                                                                                                            evaluated*/);\n    if (result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: \"not\",\n        keywordLocation,\n        error: 'Instance matched \"not\" schema.'\n      });\n    }\n  }\n  let subEvaluateds = [];\n  if ($anyOf !== undefined) {\n    const keywordLocation = \"\".concat(schemaLocation, \"/anyOf\");\n    const errorsLength = errors.length;\n    let anyValid = false;\n    for (let i = 0; i < $anyOf.length; i++) {\n      const subSchema = $anyOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, \"\".concat(keywordLocation, \"/\").concat(i), subEvaluated);\n      errors.push(...result.errors);\n      anyValid = anyValid || result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (anyValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"anyOf\",\n        keywordLocation,\n        error: \"Instance does not match any subschemas.\"\n      });\n    }\n  }\n  if ($allOf !== undefined) {\n    const keywordLocation = \"\".concat(schemaLocation, \"/allOf\");\n    const errorsLength = errors.length;\n    let allValid = true;\n    for (let i = 0; i < $allOf.length; i++) {\n      const subSchema = $allOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, \"\".concat(keywordLocation, \"/\").concat(i), subEvaluated);\n      errors.push(...result.errors);\n      allValid = allValid && result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (allValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"allOf\",\n        keywordLocation,\n        error: \"Instance does not match every subschema.\"\n      });\n    }\n  }\n  if ($oneOf !== undefined) {\n    const keywordLocation = \"\".concat(schemaLocation, \"/oneOf\");\n    const errorsLength = errors.length;\n    const matches = $oneOf.filter((subSchema, i) => {\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, \"\".concat(keywordLocation, \"/\").concat(i), subEvaluated);\n      errors.push(...result.errors);\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n      return result.valid;\n    }).length;\n    if (matches === 1) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: \"oneOf\",\n        keywordLocation,\n        error: \"Instance does not match exactly one subschema (\".concat(matches, \" matches).\")\n      });\n    }\n  }\n  if (instanceType === \"object\" || instanceType === \"array\") {\n    Object.assign(evaluated, ...subEvaluateds);\n  }\n  if ($if !== undefined) {\n    const keywordLocation = \"\".concat(schemaLocation, \"/if\");\n    const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n    if (conditionResult) {\n      if ($then !== undefined) {\n        const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, \"\".concat(schemaLocation, \"/then\"), evaluated);\n        if (!thenResult.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"if\",\n            keywordLocation,\n            error: \"Instance does not match \\\"then\\\" schema.\"\n          }, ...thenResult.errors);\n        }\n      }\n    } else if ($else !== undefined) {\n      const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, \"\".concat(schemaLocation, \"/else\"), evaluated);\n      if (!elseResult.valid) {\n        errors.push({\n          instanceLocation,\n          keyword: \"if\",\n          keywordLocation,\n          error: \"Instance does not match \\\"else\\\" schema.\"\n        }, ...elseResult.errors);\n      }\n    }\n  }\n  if (instanceType === \"object\") {\n    if ($required !== undefined) {\n      for (const key of $required) {\n        if (!(key in instance)) {\n          errors.push({\n            instanceLocation,\n            keyword: \"required\",\n            keywordLocation: \"\".concat(schemaLocation, \"/required\"),\n            error: \"Instance does not have required property \\\"\".concat(key, \"\\\".\")\n          });\n        }\n      }\n    }\n    const keys = Object.keys(instance);\n    if ($minProperties !== undefined && keys.length < $minProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minProperties\",\n        keywordLocation: \"\".concat(schemaLocation, \"/minProperties\"),\n        error: \"Instance does not have at least \".concat($minProperties, \" properties.\")\n      });\n    }\n    if ($maxProperties !== undefined && keys.length > $maxProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxProperties\",\n        keywordLocation: \"\".concat(schemaLocation, \"/maxProperties\"),\n        error: \"Instance does not have at least \".concat($maxProperties, \" properties.\")\n      });\n    }\n    if ($propertyNames !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/propertyNames\");\n      for (const key in instance) {\n        const subInstancePointer = \"\".concat(instanceLocation, \"/\").concat(encodePointer(key));\n        const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"propertyNames\",\n            keywordLocation,\n            error: \"Property name \\\"\".concat(key, \"\\\" does not match schema.\")\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($dependentRequired !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/dependantRequired\");\n      for (const key in $dependentRequired) {\n        if (key in instance) {\n          const required = $dependentRequired[key];\n          for (const dependantKey of required) {\n            if (!(dependantKey in instance)) {\n              errors.push({\n                instanceLocation,\n                keyword: \"dependentRequired\",\n                keywordLocation,\n                error: \"Instance has \\\"\".concat(key, \"\\\" but does not have \\\"\").concat(dependantKey, \"\\\".\")\n              });\n            }\n          }\n        }\n      }\n    }\n    if ($dependentSchemas !== undefined) {\n      for (const key in $dependentSchemas) {\n        const keywordLocation = \"\".concat(schemaLocation, \"/dependentSchemas\");\n        if (key in instance) {\n          const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, \"\".concat(keywordLocation, \"/\").concat(encodePointer(key)), evaluated);\n          if (!result.valid) {\n            errors.push({\n              instanceLocation,\n              keyword: \"dependentSchemas\",\n              keywordLocation,\n              error: \"Instance has \\\"\".concat(key, \"\\\" but does not match dependant schema.\")\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($dependencies !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/dependencies\");\n      for (const key in $dependencies) {\n        if (key in instance) {\n          const propsOrSchema = $dependencies[key];\n          if (Array.isArray(propsOrSchema)) {\n            for (const dependantKey of propsOrSchema) {\n              if (!(dependantKey in instance)) {\n                errors.push({\n                  instanceLocation,\n                  keyword: \"dependencies\",\n                  keywordLocation,\n                  error: \"Instance has \\\"\".concat(key, \"\\\" but does not have \\\"\").concat(dependantKey, \"\\\".\")\n                });\n              }\n            }\n          } else {\n            const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, \"\".concat(keywordLocation, \"/\").concat(encodePointer(key)));\n            if (!result.valid) {\n              errors.push({\n                instanceLocation,\n                keyword: \"dependencies\",\n                keywordLocation,\n                error: \"Instance has \\\"\".concat(key, \"\\\" but does not match dependant schema.\")\n              }, ...result.errors);\n            }\n          }\n        }\n      }\n    }\n    const thisEvaluated = Object.create(null);\n    let stop = false;\n    if ($properties !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/properties\");\n      for (const key in $properties) {\n        if (!(key in instance)) {\n          continue;\n        }\n        const subInstancePointer = \"\".concat(instanceLocation, \"/\").concat(encodePointer(key));\n        const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, \"\".concat(keywordLocation, \"/\").concat(encodePointer(key)));\n        if (result.valid) {\n          evaluated[key] = thisEvaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"properties\",\n            keywordLocation,\n            error: \"Property \\\"\".concat(key, \"\\\" does not match schema.\")\n          }, ...result.errors);\n          if (stop) break;\n        }\n      }\n    }\n    if (!stop && $patternProperties !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/patternProperties\");\n      for (const pattern in $patternProperties) {\n        const regex = new RegExp(pattern);\n        const subSchema = $patternProperties[pattern];\n        for (const key in instance) {\n          if (!regex.test(key)) {\n            continue;\n          }\n          const subInstancePointer = \"\".concat(instanceLocation, \"/\").concat(encodePointer(key));\n          const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, \"\".concat(keywordLocation, \"/\").concat(encodePointer(pattern)));\n          if (result.valid) {\n            evaluated[key] = thisEvaluated[key] = true;\n          } else {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"patternProperties\",\n              keywordLocation,\n              error: \"Property \\\"\".concat(key, \"\\\" matches pattern \\\"\").concat(pattern, \"\\\" but does not match associated schema.\")\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if (!stop && $additionalProperties !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/additionalProperties\");\n      for (const key in instance) {\n        if (thisEvaluated[key]) {\n          continue;\n        }\n        const subInstancePointer = \"\".concat(instanceLocation, \"/\").concat(encodePointer(key));\n        const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (result.valid) {\n          evaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"additionalProperties\",\n            keywordLocation,\n            error: \"Property \\\"\".concat(key, \"\\\" does not match additional properties schema.\")\n          }, ...result.errors);\n        }\n      }\n    } else if (!stop && $unevaluatedProperties !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/unevaluatedProperties\");\n      for (const key in instance) {\n        if (!evaluated[key]) {\n          const subInstancePointer = \"\".concat(instanceLocation, \"/\").concat(encodePointer(key));\n          const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n          if (result.valid) {\n            evaluated[key] = true;\n          } else {\n            errors.push({\n              instanceLocation,\n              keyword: \"unevaluatedProperties\",\n              keywordLocation,\n              error: \"Property \\\"\".concat(key, \"\\\" does not match unevaluated properties schema.\")\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n  } else if (instanceType === \"array\") {\n    if ($maxItems !== undefined && instance.length > $maxItems) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxItems\",\n        keywordLocation: \"\".concat(schemaLocation, \"/maxItems\"),\n        error: \"Array has too many items (\".concat(instance.length, \" > \").concat($maxItems, \").\")\n      });\n    }\n    if ($minItems !== undefined && instance.length < $minItems) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minItems\",\n        keywordLocation: \"\".concat(schemaLocation, \"/minItems\"),\n        error: \"Array has too few items (\".concat(instance.length, \" < \").concat($minItems, \").\")\n      });\n    }\n    const length = instance.length;\n    let i = 0;\n    let stop = false;\n    if ($prefixItems !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/prefixItems\");\n      const length2 = Math.min($prefixItems.length, length);\n      for (; i < length2; i++) {\n        const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, \"\".concat(instanceLocation, \"/\").concat(i), \"\".concat(keywordLocation, \"/\").concat(i));\n        evaluated[i] = true;\n        if (!result.valid) {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: \"prefixItems\",\n            keywordLocation,\n            error: \"Items did not match schema.\"\n          }, ...result.errors);\n          if (stop) break;\n        }\n      }\n    }\n    if ($items !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/items\");\n      if (Array.isArray($items)) {\n        const length2 = Math.min($items.length, length);\n        for (; i < length2; i++) {\n          const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, \"\".concat(instanceLocation, \"/\").concat(i), \"\".concat(keywordLocation, \"/\").concat(i));\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"items\",\n              keywordLocation,\n              error: \"Items did not match schema.\"\n            }, ...result.errors);\n            if (stop) break;\n          }\n        }\n      } else {\n        for (; i < length; i++) {\n          const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, \"\".concat(instanceLocation, \"/\").concat(i), keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"items\",\n              keywordLocation,\n              error: \"Items did not match schema.\"\n            }, ...result.errors);\n            if (stop) break;\n          }\n        }\n      }\n      if (!stop && $additionalItems !== undefined) {\n        const keywordLocation = \"\".concat(schemaLocation, \"/additionalItems\");\n        for (; i < length; i++) {\n          const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, \"\".concat(instanceLocation, \"/\").concat(i), keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: \"additionalItems\",\n              keywordLocation,\n              error: \"Items did not match additional items schema.\"\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($contains !== undefined) {\n      if (length === 0 && $minContains === undefined) {\n        errors.push({\n          instanceLocation,\n          keyword: \"contains\",\n          keywordLocation: \"\".concat(schemaLocation, \"/contains\"),\n          error: \"Array is empty. It must contain at least one item matching the schema.\"\n        });\n      } else if ($minContains !== undefined && length < $minContains) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minContains\",\n          keywordLocation: \"\".concat(schemaLocation, \"/minContains\"),\n          error: \"Array has less items (\".concat(length, \") than minContains (\").concat($minContains, \").\")\n        });\n      } else {\n        const keywordLocation = \"\".concat(schemaLocation, \"/contains\");\n        const errorsLength = errors.length;\n        let contained = 0;\n        for (let j = 0; j < length; j++) {\n          const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, \"\".concat(instanceLocation, \"/\").concat(j), keywordLocation);\n          if (result.valid) {\n            evaluated[j] = true;\n            contained++;\n          } else {\n            errors.push(...result.errors);\n          }\n        }\n        if (contained >= ($minContains || 0)) {\n          errors.length = errorsLength;\n        }\n        if ($minContains === undefined && $maxContains === undefined && contained === 0) {\n          errors.splice(errorsLength, 0, {\n            instanceLocation,\n            keyword: \"contains\",\n            keywordLocation,\n            error: \"Array does not contain item matching schema.\"\n          });\n        } else if ($minContains !== undefined && contained < $minContains) {\n          errors.push({\n            instanceLocation,\n            keyword: \"minContains\",\n            keywordLocation: \"\".concat(schemaLocation, \"/minContains\"),\n            error: \"Array must contain at least \".concat($minContains, \" items matching schema. Only \").concat(contained, \" items were found.\")\n          });\n        } else if ($maxContains !== undefined && contained > $maxContains) {\n          errors.push({\n            instanceLocation,\n            keyword: \"maxContains\",\n            keywordLocation: \"\".concat(schemaLocation, \"/maxContains\"),\n            error: \"Array may contain at most \".concat($maxContains, \" items matching schema. \").concat(contained, \" items were found.\")\n          });\n        }\n      }\n    }\n    if (!stop && $unevaluatedItems !== undefined) {\n      const keywordLocation = \"\".concat(schemaLocation, \"/unevaluatedItems\");\n      for (i; i < length; i++) {\n        if (evaluated[i]) {\n          continue;\n        }\n        const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, \"\".concat(instanceLocation, \"/\").concat(i), keywordLocation);\n        evaluated[i] = true;\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: \"unevaluatedItems\",\n            keywordLocation,\n            error: \"Items did not match unevaluated items schema.\"\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($uniqueItems) {\n      for (let j = 0; j < length; j++) {\n        const a = instance[j];\n        const ao = typeof a === \"object\" && a !== null;\n        for (let k = 0; k < length; k++) {\n          if (j === k) {\n            continue;\n          }\n          const b = instance[k];\n          const bo = typeof b === \"object\" && b !== null;\n          if (a === b || ao && bo && deepCompareStrict(a, b)) {\n            errors.push({\n              instanceLocation,\n              keyword: \"uniqueItems\",\n              keywordLocation: \"\".concat(schemaLocation, \"/uniqueItems\"),\n              error: \"Duplicate items at indexes \".concat(j, \" and \").concat(k, \".\")\n            });\n            j = Number.MAX_SAFE_INTEGER;\n            k = Number.MAX_SAFE_INTEGER;\n          }\n        }\n      }\n    }\n  } else if (instanceType === \"number\") {\n    if (draft === \"4\") {\n      if ($minimum !== undefined && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minimum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/minimum\"),\n          error: \"\".concat(instance, \" is less than \").concat($exclusiveMinimum ? \"or equal to \" : \"\", \" \").concat($minimum, \".\")\n        });\n      }\n      if ($maximum !== undefined && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {\n        errors.push({\n          instanceLocation,\n          keyword: \"maximum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/maximum\"),\n          error: \"\".concat(instance, \" is greater than \").concat($exclusiveMaximum ? \"or equal to \" : \"\", \" \").concat($maximum, \".\")\n        });\n      }\n    } else {\n      if ($minimum !== undefined && instance < $minimum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"minimum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/minimum\"),\n          error: \"\".concat(instance, \" is less than \").concat($minimum, \".\")\n        });\n      }\n      if ($maximum !== undefined && instance > $maximum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"maximum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/maximum\"),\n          error: \"\".concat(instance, \" is greater than \").concat($maximum, \".\")\n        });\n      }\n      if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"exclusiveMinimum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/exclusiveMinimum\"),\n          error: \"\".concat(instance, \" is less than \").concat($exclusiveMinimum, \".\")\n        });\n      }\n      if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n        errors.push({\n          instanceLocation,\n          keyword: \"exclusiveMaximum\",\n          keywordLocation: \"\".concat(schemaLocation, \"/exclusiveMaximum\"),\n          error: \"\".concat(instance, \" is greater than or equal to \").concat($exclusiveMaximum, \".\")\n        });\n      }\n    }\n    if ($multipleOf !== undefined) {\n      const remainder = instance % $multipleOf;\n      if (Math.abs(0 - remainder) >= 1.1920929e-7 && Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n        errors.push({\n          instanceLocation,\n          keyword: \"multipleOf\",\n          keywordLocation: \"\".concat(schemaLocation, \"/multipleOf\"),\n          error: \"\".concat(instance, \" is not a multiple of \").concat($multipleOf, \".\")\n        });\n      }\n    }\n  } else if (instanceType === \"string\") {\n    const length = $minLength === undefined && $maxLength === undefined ? 0 : ucs2length(instance);\n    if ($minLength !== undefined && length < $minLength) {\n      errors.push({\n        instanceLocation,\n        keyword: \"minLength\",\n        keywordLocation: \"\".concat(schemaLocation, \"/minLength\"),\n        error: \"String is too short (\".concat(length, \" < \").concat($minLength, \").\")\n      });\n    }\n    if ($maxLength !== undefined && length > $maxLength) {\n      errors.push({\n        instanceLocation,\n        keyword: \"maxLength\",\n        keywordLocation: \"\".concat(schemaLocation, \"/maxLength\"),\n        error: \"String is too long (\".concat(length, \" > \").concat($maxLength, \").\")\n      });\n    }\n    if ($pattern !== undefined && !new RegExp($pattern).test(instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"pattern\",\n        keywordLocation: \"\".concat(schemaLocation, \"/pattern\"),\n        error: \"String does not match pattern.\"\n      });\n    }\n    if ($format !== undefined && fastFormat[$format] && !fastFormat[$format](instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: \"format\",\n        keywordLocation: \"\".concat(schemaLocation, \"/format\"),\n        error: \"String does not match format \\\"\".concat($format, \"\\\".\")\n      });\n    }\n  }\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}","map":{"version":3,"names":["deepCompareStrict","dereference","fastFormat","encodePointer","ucs2length","validate","instance","schema","draft","arguments","length","undefined","lookup","shortCircuit","recursiveAnchor","instanceLocation","schemaLocation","evaluated","Object","create","valid","errors","keyword","keywordLocation","error","rawInstanceType","instanceType","Array","isArray","Error","concat","$ref","$recursiveRef","$recursiveAnchor","type","$type","const","$const","enum","$enum","required","$required","not","$not","anyOf","$anyOf","allOf","$allOf","oneOf","$oneOf","if","$if","then","$then","else","$else","format","$format","properties","$properties","patternProperties","$patternProperties","additionalProperties","$additionalProperties","unevaluatedProperties","$unevaluatedProperties","minProperties","$minProperties","maxProperties","$maxProperties","propertyNames","$propertyNames","dependentRequired","$dependentRequired","dependentSchemas","$dependentSchemas","dependencies","$dependencies","prefixItems","$prefixItems","items","$items","additionalItems","$additionalItems","unevaluatedItems","$unevaluatedItems","contains","$contains","minContains","$minContains","maxContains","$maxContains","minItems","$minItems","maxItems","$maxItems","uniqueItems","$uniqueItems","minimum","$minimum","maximum","$maximum","exclusiveMinimum","$exclusiveMinimum","exclusiveMaximum","$exclusiveMaximum","multipleOf","$multipleOf","minLength","$minLength","maxLength","$maxLength","pattern","$pattern","__absolute_ref__","__absolute_recursive_ref__","refSchema","result","push","uri","message","keys","join","i","JSON","stringify","some","value","subEvaluateds","errorsLength","anyValid","subSchema","subEvaluated","splice","allValid","matches","filter","assign","conditionResult","thenResult","elseResult","key","subInstancePointer","dependantKey","propsOrSchema","thisEvaluated","stop","regex","RegExp","test","length2","Math","min","contained","j","a","ao","k","b","bo","Number","MAX_SAFE_INTEGER","remainder","abs"],"sources":["/Users/mandylin/Desktop/WebCrack React/webcrack/node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/validate.js"],"sourcesContent":["import { deepCompareStrict } from \"./deep-compare-strict.js\";\nimport { dereference } from \"./dereference.js\";\nimport { fastFormat } from \"./format.js\";\nimport { encodePointer } from \"./pointer.js\";\nimport { ucs2length } from \"./ucs2-length.js\";\nexport function validate(instance, schema, draft = \"2019-09\", lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = \"#\", schemaLocation = \"#\", evaluated = Object.create(null)) {\n    if (schema === true) {\n        return { valid: true, errors: [] };\n    }\n    if (schema === false) {\n        return {\n            valid: false,\n            errors: [\n                {\n                    instanceLocation,\n                    keyword: \"false\",\n                    keywordLocation: instanceLocation,\n                    error: \"False boolean schema.\",\n                },\n            ],\n        };\n    }\n    const rawInstanceType = typeof instance;\n    let instanceType;\n    switch (rawInstanceType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            instanceType = rawInstanceType;\n            break;\n        case \"object\":\n            if (instance === null) {\n                instanceType = \"null\";\n            }\n            else if (Array.isArray(instance)) {\n                instanceType = \"array\";\n            }\n            else {\n                instanceType = \"object\";\n            }\n            break;\n        default:\n            // undefined, bigint, function, symbol\n            throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n    }\n    const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__, } = schema;\n    const errors = [];\n    if ($recursiveAnchor === true && recursiveAnchor === null) {\n        recursiveAnchor = schema;\n    }\n    if ($recursiveRef === \"#\") {\n        const refSchema = recursiveAnchor === null\n            ? lookup[__absolute_recursive_ref__]\n            : recursiveAnchor;\n        const keywordLocation = `${schemaLocation}/$recursiveRef`;\n        const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"$recursiveRef\",\n                keywordLocation,\n                error: \"A subschema had errors.\",\n            }, ...result.errors);\n        }\n    }\n    if ($ref !== undefined) {\n        const uri = __absolute_ref__ || $ref;\n        const refSchema = lookup[uri];\n        if (refSchema === undefined) {\n            let message = `Unresolved $ref \"${$ref}\".`;\n            if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                message += `  Absolute URI \"${__absolute_ref__}\".`;\n            }\n            message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join(\"\\n- \")}`;\n            throw new Error(message);\n        }\n        const keywordLocation = `${schemaLocation}/$ref`;\n        const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"$ref\",\n                keywordLocation,\n                error: \"A subschema had errors.\",\n            }, ...result.errors);\n        }\n        if (draft === \"4\" || draft === \"7\") {\n            return { valid: errors.length === 0, errors };\n        }\n    }\n    if (Array.isArray($type)) {\n        let length = $type.length;\n        let valid = false;\n        for (let i = 0; i < length; i++) {\n            if (instanceType === $type[i] ||\n                ($type[i] === \"integer\" &&\n                    instanceType === \"number\" &&\n                    instance % 1 === 0 &&\n                    instance === instance)) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"type\",\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`,\n            });\n        }\n    }\n    else if ($type === \"integer\") {\n        if (instanceType !== \"number\" || instance % 1 || instance !== instance) {\n            errors.push({\n                instanceLocation,\n                keyword: \"type\",\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n            });\n        }\n    }\n    else if ($type !== undefined && instanceType !== $type) {\n        errors.push({\n            instanceLocation,\n            keyword: \"type\",\n            keywordLocation: `${schemaLocation}/type`,\n            error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`,\n        });\n    }\n    if ($const !== undefined) {\n        if (instanceType === \"object\" || instanceType === \"array\") {\n            if (!deepCompareStrict(instance, $const)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"const\",\n                    keywordLocation: `${schemaLocation}/const`,\n                    error: `Instance does not match ${JSON.stringify($const)}.`,\n                });\n            }\n        }\n        else if (instance !== $const) {\n            errors.push({\n                instanceLocation,\n                keyword: \"const\",\n                keywordLocation: `${schemaLocation}/const`,\n                error: `Instance does not match ${JSON.stringify($const)}.`,\n            });\n        }\n    }\n    if ($enum !== undefined) {\n        if (instanceType === \"object\" || instanceType === \"array\") {\n            if (!$enum.some((value) => deepCompareStrict(instance, value))) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"enum\",\n                    keywordLocation: `${schemaLocation}/enum`,\n                    error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n                });\n            }\n        }\n        else if (!$enum.some((value) => instance === value)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"enum\",\n                keywordLocation: `${schemaLocation}/enum`,\n                error: `Instance does not match any of ${JSON.stringify($enum)}.`,\n            });\n        }\n    }\n    if ($not !== undefined) {\n        const keywordLocation = `${schemaLocation}/not`;\n        const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation /*,\n        evaluated*/);\n        if (result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: \"not\",\n                keywordLocation,\n                error: 'Instance matched \"not\" schema.',\n            });\n        }\n    }\n    let subEvaluateds = [];\n    if ($anyOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/anyOf`;\n        const errorsLength = errors.length;\n        let anyValid = false;\n        for (let i = 0; i < $anyOf.length; i++) {\n            const subSchema = $anyOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            anyValid = anyValid || result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (anyValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"anyOf\",\n                keywordLocation,\n                error: \"Instance does not match any subschemas.\",\n            });\n        }\n    }\n    if ($allOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/allOf`;\n        const errorsLength = errors.length;\n        let allValid = true;\n        for (let i = 0; i < $allOf.length; i++) {\n            const subSchema = $allOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            allValid = allValid && result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (allValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"allOf\",\n                keywordLocation,\n                error: `Instance does not match every subschema.`,\n            });\n        }\n    }\n    if ($oneOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/oneOf`;\n        const errorsLength = errors.length;\n        const matches = $oneOf.filter((subSchema, i) => {\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n            return result.valid;\n        }).length;\n        if (matches === 1) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: \"oneOf\",\n                keywordLocation,\n                error: `Instance does not match exactly one subschema (${matches} matches).`,\n            });\n        }\n    }\n    if (instanceType === \"object\" || instanceType === \"array\") {\n        Object.assign(evaluated, ...subEvaluateds);\n    }\n    if ($if !== undefined) {\n        const keywordLocation = `${schemaLocation}/if`;\n        const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n        if (conditionResult) {\n            if ($then !== undefined) {\n                const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                if (!thenResult.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"if\",\n                        keywordLocation,\n                        error: `Instance does not match \"then\" schema.`,\n                    }, ...thenResult.errors);\n                }\n            }\n        }\n        else if ($else !== undefined) {\n            const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n            if (!elseResult.valid) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"if\",\n                    keywordLocation,\n                    error: `Instance does not match \"else\" schema.`,\n                }, ...elseResult.errors);\n            }\n        }\n    }\n    if (instanceType === \"object\") {\n        if ($required !== undefined) {\n            for (const key of $required) {\n                if (!(key in instance)) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"required\",\n                        keywordLocation: `${schemaLocation}/required`,\n                        error: `Instance does not have required property \"${key}\".`,\n                    });\n                }\n            }\n        }\n        const keys = Object.keys(instance);\n        if ($minProperties !== undefined && keys.length < $minProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minProperties\",\n                keywordLocation: `${schemaLocation}/minProperties`,\n                error: `Instance does not have at least ${$minProperties} properties.`,\n            });\n        }\n        if ($maxProperties !== undefined && keys.length > $maxProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxProperties\",\n                keywordLocation: `${schemaLocation}/maxProperties`,\n                error: `Instance does not have at least ${$maxProperties} properties.`,\n            });\n        }\n        if ($propertyNames !== undefined) {\n            const keywordLocation = `${schemaLocation}/propertyNames`;\n            for (const key in instance) {\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"propertyNames\",\n                        keywordLocation,\n                        error: `Property name \"${key}\" does not match schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($dependentRequired !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependantRequired`;\n            for (const key in $dependentRequired) {\n                if (key in instance) {\n                    const required = $dependentRequired[key];\n                    for (const dependantKey of required) {\n                        if (!(dependantKey in instance)) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: \"dependentRequired\",\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if ($dependentSchemas !== undefined) {\n            for (const key in $dependentSchemas) {\n                const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                if (key in instance) {\n                    const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n                    if (!result.valid) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"dependentSchemas\",\n                            keywordLocation,\n                            error: `Instance has \"${key}\" but does not match dependant schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($dependencies !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependencies`;\n            for (const key in $dependencies) {\n                if (key in instance) {\n                    const propsOrSchema = $dependencies[key];\n                    if (Array.isArray(propsOrSchema)) {\n                        for (const dependantKey of propsOrSchema) {\n                            if (!(dependantKey in instance)) {\n                                errors.push({\n                                    instanceLocation,\n                                    keyword: \"dependencies\",\n                                    keywordLocation,\n                                    error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`,\n                                });\n                            }\n                        }\n                    }\n                    else {\n                        const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n                        if (!result.valid) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: \"dependencies\",\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not match dependant schema.`,\n                            }, ...result.errors);\n                        }\n                    }\n                }\n            }\n        }\n        const thisEvaluated = Object.create(null);\n        let stop = false;\n        if ($properties !== undefined) {\n            const keywordLocation = `${schemaLocation}/properties`;\n            for (const key in $properties) {\n                if (!(key in instance)) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n                if (result.valid) {\n                    evaluated[key] = thisEvaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"properties\",\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match schema.`,\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if (!stop && $patternProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/patternProperties`;\n            for (const pattern in $patternProperties) {\n                const regex = new RegExp(pattern);\n                const subSchema = $patternProperties[pattern];\n                for (const key in instance) {\n                    if (!regex.test(key)) {\n                        continue;\n                    }\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n                    if (result.valid) {\n                        evaluated[key] = thisEvaluated[key] = true;\n                    }\n                    else {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"patternProperties\",\n                            keywordLocation,\n                            error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if (!stop && $additionalProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/additionalProperties`;\n            for (const key in instance) {\n                if (thisEvaluated[key]) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (result.valid) {\n                    evaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"additionalProperties\",\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match additional properties schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        else if (!stop && $unevaluatedProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n            for (const key in instance) {\n                if (!evaluated[key]) {\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                    if (result.valid) {\n                        evaluated[key] = true;\n                    }\n                    else {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"unevaluatedProperties\",\n                            keywordLocation,\n                            error: `Property \"${key}\" does not match unevaluated properties schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === \"array\") {\n        if ($maxItems !== undefined && instance.length > $maxItems) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxItems\",\n                keywordLocation: `${schemaLocation}/maxItems`,\n                error: `Array has too many items (${instance.length} > ${$maxItems}).`,\n            });\n        }\n        if ($minItems !== undefined && instance.length < $minItems) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minItems\",\n                keywordLocation: `${schemaLocation}/minItems`,\n                error: `Array has too few items (${instance.length} < ${$minItems}).`,\n            });\n        }\n        const length = instance.length;\n        let i = 0;\n        let stop = false;\n        if ($prefixItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/prefixItems`;\n            const length2 = Math.min($prefixItems.length, length);\n            for (; i < length2; i++) {\n                const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"prefixItems\",\n                        keywordLocation,\n                        error: `Items did not match schema.`,\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if ($items !== undefined) {\n            const keywordLocation = `${schemaLocation}/items`;\n            if (Array.isArray($items)) {\n                const length2 = Math.min($items.length, length);\n                for (; i < length2; i++) {\n                    const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"items\",\n                            keywordLocation,\n                            error: `Items did not match schema.`,\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            else {\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"items\",\n                            keywordLocation,\n                            error: `Items did not match schema.`,\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            if (!stop && $additionalItems !== undefined) {\n                const keywordLocation = `${schemaLocation}/additionalItems`;\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"additionalItems\",\n                            keywordLocation,\n                            error: `Items did not match additional items schema.`,\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($contains !== undefined) {\n            if (length === 0 && $minContains === undefined) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"contains\",\n                    keywordLocation: `${schemaLocation}/contains`,\n                    error: `Array is empty. It must contain at least one item matching the schema.`,\n                });\n            }\n            else if ($minContains !== undefined && length < $minContains) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minContains\",\n                    keywordLocation: `${schemaLocation}/minContains`,\n                    error: `Array has less items (${length}) than minContains (${$minContains}).`,\n                });\n            }\n            else {\n                const keywordLocation = `${schemaLocation}/contains`;\n                const errorsLength = errors.length;\n                let contained = 0;\n                for (let j = 0; j < length; j++) {\n                    const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                    if (result.valid) {\n                        evaluated[j] = true;\n                        contained++;\n                    }\n                    else {\n                        errors.push(...result.errors);\n                    }\n                }\n                if (contained >= ($minContains || 0)) {\n                    errors.length = errorsLength;\n                }\n                if ($minContains === undefined &&\n                    $maxContains === undefined &&\n                    contained === 0) {\n                    errors.splice(errorsLength, 0, {\n                        instanceLocation,\n                        keyword: \"contains\",\n                        keywordLocation,\n                        error: `Array does not contain item matching schema.`,\n                    });\n                }\n                else if ($minContains !== undefined && contained < $minContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"minContains\",\n                        keywordLocation: `${schemaLocation}/minContains`,\n                        error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`,\n                    });\n                }\n                else if ($maxContains !== undefined && contained > $maxContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"maxContains\",\n                        keywordLocation: `${schemaLocation}/maxContains`,\n                        error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`,\n                    });\n                }\n            }\n        }\n        if (!stop && $unevaluatedItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n            for (i; i < length; i++) {\n                if (evaluated[i]) {\n                    continue;\n                }\n                const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: \"unevaluatedItems\",\n                        keywordLocation,\n                        error: `Items did not match unevaluated items schema.`,\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($uniqueItems) {\n            for (let j = 0; j < length; j++) {\n                const a = instance[j];\n                const ao = typeof a === \"object\" && a !== null;\n                for (let k = 0; k < length; k++) {\n                    if (j === k) {\n                        continue;\n                    }\n                    const b = instance[k];\n                    const bo = typeof b === \"object\" && b !== null;\n                    if (a === b || (ao && bo && deepCompareStrict(a, b))) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: \"uniqueItems\",\n                            keywordLocation: `${schemaLocation}/uniqueItems`,\n                            error: `Duplicate items at indexes ${j} and ${k}.`,\n                        });\n                        j = Number.MAX_SAFE_INTEGER;\n                        k = Number.MAX_SAFE_INTEGER;\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === \"number\") {\n        if (draft === \"4\") {\n            if ($minimum !== undefined &&\n                (($exclusiveMinimum === true && instance <= $minimum) ||\n                    instance < $minimum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minimum\",\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum ? \"or equal to \" : \"\"} ${$minimum}.`,\n                });\n            }\n            if ($maximum !== undefined &&\n                (($exclusiveMaximum === true && instance >= $maximum) ||\n                    instance > $maximum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"maximum\",\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$exclusiveMaximum ? \"or equal to \" : \"\"} ${$maximum}.`,\n                });\n            }\n        }\n        else {\n            if ($minimum !== undefined && instance < $minimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"minimum\",\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$minimum}.`,\n                });\n            }\n            if ($maximum !== undefined && instance > $maximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"maximum\",\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$maximum}.`,\n                });\n            }\n            if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"exclusiveMinimum\",\n                    keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum}.`,\n                });\n            }\n            if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"exclusiveMaximum\",\n                    keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                    error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`,\n                });\n            }\n        }\n        if ($multipleOf !== undefined) {\n            const remainder = instance % $multipleOf;\n            if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                errors.push({\n                    instanceLocation,\n                    keyword: \"multipleOf\",\n                    keywordLocation: `${schemaLocation}/multipleOf`,\n                    error: `${instance} is not a multiple of ${$multipleOf}.`,\n                });\n            }\n        }\n    }\n    else if (instanceType === \"string\") {\n        const length = $minLength === undefined && $maxLength === undefined\n            ? 0\n            : ucs2length(instance);\n        if ($minLength !== undefined && length < $minLength) {\n            errors.push({\n                instanceLocation,\n                keyword: \"minLength\",\n                keywordLocation: `${schemaLocation}/minLength`,\n                error: `String is too short (${length} < ${$minLength}).`,\n            });\n        }\n        if ($maxLength !== undefined && length > $maxLength) {\n            errors.push({\n                instanceLocation,\n                keyword: \"maxLength\",\n                keywordLocation: `${schemaLocation}/maxLength`,\n                error: `String is too long (${length} > ${$maxLength}).`,\n            });\n        }\n        if ($pattern !== undefined && !new RegExp($pattern).test(instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"pattern\",\n                keywordLocation: `${schemaLocation}/pattern`,\n                error: `String does not match pattern.`,\n            });\n        }\n        if ($format !== undefined &&\n            fastFormat[$format] &&\n            !fastFormat[$format](instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: \"format\",\n                keywordLocation: `${schemaLocation}/format`,\n                error: `String does not match format \"${$format}\".`,\n            });\n        }\n    }\n    return { valid: errors.length === 0, errors };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}