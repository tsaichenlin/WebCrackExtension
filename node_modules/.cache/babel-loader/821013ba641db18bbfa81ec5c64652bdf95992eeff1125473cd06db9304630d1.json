{"ast":null,"code":"import { Serializable } from \"../load/serializable.js\";\nfunction mergeContent(firstContent, secondContent) {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else {\n      return [{\n        type: \"text\",\n        text: firstContent\n      }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return [...firstContent, ...secondContent];\n    // If the first content is a list and second is a string\n  } else {\n    // Otherwise, add the second content as a new element of the list\n    return [...firstContent, {\n      type: \"text\",\n      text: secondContent\n    }];\n  }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport class BaseMessage extends Serializable {\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\"\n    };\n  }\n  /**\n   * @deprecated\n   * Use {@link BaseMessage.content} instead.\n   */\n  get text() {\n    return typeof this.content === \"string\" ? this.content : \"\";\n  }\n  constructor(fields, /** @deprecated */\n  kwargs) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        content: fields,\n        additional_kwargs: kwargs\n      };\n    }\n    // Make sure the default value for additional_kwargs is passed into super() for serialization\n    if (!fields.additional_kwargs) {\n      // eslint-disable-next-line no-param-reassign\n      fields.additional_kwargs = {};\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"messages\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    /** The content of the message. */\n    Object.defineProperty(this, \"content\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** The name of the message sender in a multi-user chat. */\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** Additional keyword arguments */\n    Object.defineProperty(this, \"additional_kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.content = fields.content;\n    this.additional_kwargs = fields.additional_kwargs;\n  }\n  toDict() {\n    return {\n      type: this._getType(),\n      data: this.toJSON().kwargs\n    };\n  }\n  toChunk() {\n    const type = this._getType();\n    if (type === \"human\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new HumanMessageChunk({\n        ...this\n      });\n    } else if (type === \"ai\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new AIMessageChunk({\n        ...this\n      });\n    } else if (type === \"system\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new SystemMessageChunk({\n        ...this\n      });\n    } else if (type === \"function\") {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new FunctionMessageChunk({\n        ...this\n      });\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    } else if (ChatMessage.isInstance(this)) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return new ChatMessageChunk({\n        ...this\n      });\n    } else {\n      throw new Error(\"Unknown message type.\");\n    }\n  }\n}\nfunction isOpenAIToolCallArray(value) {\n  return Array.isArray(value) && value.every(v => typeof v.index === \"number\");\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport class BaseMessageChunk extends BaseMessage {\n  static _mergeAdditionalKwargs(left, right) {\n    const merged = {\n      ...left\n    };\n    for (const [key, value] of Object.entries(right)) {\n      if (merged[key] === undefined) {\n        merged[key] = value;\n      } else if (typeof merged[key] !== typeof value) {\n        throw new Error(\"additional_kwargs[\".concat(key, \"] already exists in the message chunk, but with a different type.\"));\n      } else if (typeof merged[key] === \"string\") {\n        merged[key] = merged[key] + value;\n      } else if (!Array.isArray(merged[key]) && typeof merged[key] === \"object\") {\n        merged[key] = this._mergeAdditionalKwargs(merged[key], value);\n      } else if (key === \"tool_calls\" && isOpenAIToolCallArray(merged[key]) && isOpenAIToolCallArray(value)) {\n        for (const toolCall of value) {\n          var _merged$key;\n          if (((_merged$key = merged[key]) === null || _merged$key === void 0 ? void 0 : _merged$key[toolCall.index]) !== undefined) {\n            var _merged$key2;\n            merged[key] = (_merged$key2 = merged[key]) === null || _merged$key2 === void 0 ? void 0 : _merged$key2.map((value, i) => {\n              var _toolCall$function$na, _value$function$argum, _toolCall$function$ar;\n              if (i !== toolCall.index) {\n                return value;\n              }\n              return {\n                ...value,\n                ...toolCall,\n                function: {\n                  name: (_toolCall$function$na = toolCall.function.name) !== null && _toolCall$function$na !== void 0 ? _toolCall$function$na : value.function.name,\n                  arguments: ((_value$function$argum = value.function.arguments) !== null && _value$function$argum !== void 0 ? _value$function$argum : \"\") + ((_toolCall$function$ar = toolCall.function.arguments) !== null && _toolCall$function$ar !== void 0 ? _toolCall$function$ar : \"\")\n                }\n              };\n            });\n          } else {\n            merged[key][toolCall.index] = toolCall;\n          }\n        }\n      } else {\n        throw new Error(\"additional_kwargs[\".concat(key, \"] already exists in this message chunk.\"));\n      }\n    }\n    return merged;\n  }\n}\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage extends BaseMessage {\n  static lc_name() {\n    return \"HumanMessage\";\n  }\n  _getType() {\n    return \"human\";\n  }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"HumanMessageChunk\";\n  }\n  _getType() {\n    return \"human\";\n  }\n  concat(chunk) {\n    return new HumanMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: HumanMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)\n    });\n  }\n}\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n  static lc_name() {\n    return \"AIMessage\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n  concat(chunk) {\n    return new AIMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: AIMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)\n    });\n  }\n}\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage extends BaseMessage {\n  static lc_name() {\n    return \"SystemMessage\";\n  }\n  _getType() {\n    return \"system\";\n  }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"SystemMessageChunk\";\n  }\n  _getType() {\n    return \"system\";\n  }\n  concat(chunk) {\n    return new SystemMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: SystemMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)\n    });\n  }\n}\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage extends BaseMessage {\n  static lc_name() {\n    return \"FunctionMessage\";\n  }\n  constructor(fields, /** @deprecated */\n  name) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        name: name\n      };\n    }\n    super(fields);\n  }\n  _getType() {\n    return \"function\";\n  }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"FunctionMessageChunk\";\n  }\n  _getType() {\n    return \"function\";\n  }\n  concat(chunk) {\n    var _this$name;\n    return new FunctionMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: FunctionMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n      name: (_this$name = this.name) !== null && _this$name !== void 0 ? _this$name : \"\"\n    });\n  }\n}\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage extends BaseMessage {\n  static lc_name() {\n    return \"ToolMessage\";\n  }\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      tool_call_id: \"tool_call_id\"\n    };\n  }\n  constructor(fields, tool_call_id, name) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        name,\n        tool_call_id: tool_call_id\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"tool_call_id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_id = fields.tool_call_id;\n  }\n  _getType() {\n    return \"tool\";\n  }\n  static isInstance(message) {\n    return message._getType() === \"tool\";\n  }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk extends BaseMessageChunk {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"tool_call_id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_id = fields.tool_call_id;\n  }\n  static lc_name() {\n    return \"ToolMessageChunk\";\n  }\n  _getType() {\n    return \"tool\";\n  }\n  concat(chunk) {\n    return new ToolMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: ToolMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n      tool_call_id: this.tool_call_id\n    });\n  }\n}\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage extends BaseMessage {\n  static lc_name() {\n    return \"ChatMessage\";\n  }\n  static _chatMessageClass() {\n    return ChatMessage;\n  }\n  constructor(fields, role) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        role: role\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"role\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.role = fields.role;\n  }\n  _getType() {\n    return \"generic\";\n  }\n  static isInstance(message) {\n    return message._getType() === \"generic\";\n  }\n}\nexport function isBaseMessage(messageLike) {\n  return typeof (messageLike === null || messageLike === void 0 ? void 0 : messageLike._getType) === \"function\";\n}\nexport function isBaseMessageChunk(messageLike) {\n  return isBaseMessage(messageLike) && typeof messageLike.concat === \"function\";\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  const [type, content] = messageLike;\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage({\n      content\n    });\n  } else if (type === \"ai\" || type === \"assistant\") {\n    return new AIMessage({\n      content\n    });\n  } else if (type === \"system\") {\n    return new SystemMessage({\n      content\n    });\n  } else {\n    throw new Error(\"Unable to coerce message from array: only human, AI, or system message coercion is currently supported.\");\n  }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk extends BaseMessageChunk {\n  static lc_name() {\n    return \"ChatMessageChunk\";\n  }\n  constructor(fields, role) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = {\n        content: fields,\n        role: role\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"role\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.role = fields.role;\n  }\n  _getType() {\n    return \"generic\";\n  }\n  concat(chunk) {\n    return new ChatMessageChunk({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: ChatMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n      role: this.role\n    });\n  }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages) {\n  let humanPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Human\";\n  let aiPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"AI\";\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(\"Got unsupported message type: \".concat(m._getType()));\n    }\n    const nameStr = m.name ? \"\".concat(m.name, \", \") : \"\";\n    string_messages.push(\"\".concat(role, \": \").concat(nameStr).concat(m.content));\n  }\n  return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if (message.data !== undefined) {\n    return message;\n  } else {\n    const v1Message = message;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined\n      }\n    };\n  }\n}\nexport function mapStoredMessageToChatMessage(message) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data);\n    case \"chat\":\n      {\n        if (storedMessage.data.role === undefined) {\n          throw new Error(\"Role must be defined for chat messages\");\n        }\n        return new ChatMessage(storedMessage.data);\n      }\n    default:\n      throw new Error(\"Got unexpected type: \".concat(storedMessage.type));\n  }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n  return messages.map(message => message.toDict());\n}","map":{"version":3,"names":["Serializable","mergeContent","firstContent","secondContent","type","text","Array","isArray","BaseMessage","lc_aliases","additional_kwargs","content","constructor","fields","kwargs","Object","defineProperty","enumerable","configurable","writable","value","name","toDict","_getType","data","toJSON","toChunk","HumanMessageChunk","AIMessageChunk","SystemMessageChunk","FunctionMessageChunk","ChatMessage","isInstance","ChatMessageChunk","Error","isOpenAIToolCallArray","every","v","index","BaseMessageChunk","_mergeAdditionalKwargs","left","right","merged","key","entries","undefined","concat","toolCall","_merged$key","_merged$key2","map","i","_toolCall$function$na","_value$function$argum","_toolCall$function$ar","function","arguments","HumanMessage","lc_name","chunk","AIMessage","SystemMessage","FunctionMessage","_this$name","ToolMessage","tool_call_id","message","ToolMessageChunk","_chatMessageClass","role","isBaseMessage","messageLike","isBaseMessageChunk","coerceMessageLikeToMessage","getBufferString","messages","humanPrefix","length","aiPrefix","string_messages","m","nameStr","push","join","mapV1MessageToStoredMessage","v1Message","mapStoredMessageToChatMessage","storedMessage","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages"],"sources":["/Users/mandylin/Desktop/WebCrack React 2/webcrack/node_modules/@langchain/core/dist/messages/index.js"],"sourcesContent":["import { Serializable } from \"../load/serializable.js\";\nfunction mergeContent(firstContent, secondContent) {\n    // If first content is a string\n    if (typeof firstContent === \"string\") {\n        if (typeof secondContent === \"string\") {\n            return firstContent + secondContent;\n        }\n        else {\n            return [{ type: \"text\", text: firstContent }, ...secondContent];\n        }\n        // If both are arrays\n    }\n    else if (Array.isArray(secondContent)) {\n        return [...firstContent, ...secondContent];\n        // If the first content is a list and second is a string\n    }\n    else {\n        // Otherwise, add the second content as a new element of the list\n        return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n}\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport class BaseMessage extends Serializable {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { additional_kwargs: \"additional_kwargs\" };\n    }\n    /**\n     * @deprecated\n     * Use {@link BaseMessage.content} instead.\n     */\n    get text() {\n        return typeof this.content === \"string\" ? this.content : \"\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            fields = { content: fields, additional_kwargs: kwargs };\n        }\n        // Make sure the default value for additional_kwargs is passed into super() for serialization\n        if (!fields.additional_kwargs) {\n            // eslint-disable-next-line no-param-reassign\n            fields.additional_kwargs = {};\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"messages\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /** The content of the message. */\n        Object.defineProperty(this, \"content\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** The name of the message sender in a multi-user chat. */\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Additional keyword arguments */\n        Object.defineProperty(this, \"additional_kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.content = fields.content;\n        this.additional_kwargs = fields.additional_kwargs;\n    }\n    toDict() {\n        return {\n            type: this._getType(),\n            data: this.toJSON()\n                .kwargs,\n        };\n    }\n    toChunk() {\n        const type = this._getType();\n        if (type === \"human\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new HumanMessageChunk({ ...this });\n        }\n        else if (type === \"ai\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new AIMessageChunk({ ...this });\n        }\n        else if (type === \"system\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new SystemMessageChunk({ ...this });\n        }\n        else if (type === \"function\") {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new FunctionMessageChunk({ ...this });\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        }\n        else if (ChatMessage.isInstance(this)) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            return new ChatMessageChunk({ ...this });\n        }\n        else {\n            throw new Error(\"Unknown message type.\");\n        }\n    }\n}\nfunction isOpenAIToolCallArray(value) {\n    return (Array.isArray(value) &&\n        value.every((v) => typeof v.index === \"number\"));\n}\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport class BaseMessageChunk extends BaseMessage {\n    static _mergeAdditionalKwargs(left, right) {\n        const merged = { ...left };\n        for (const [key, value] of Object.entries(right)) {\n            if (merged[key] === undefined) {\n                merged[key] = value;\n            }\n            else if (typeof merged[key] !== typeof value) {\n                throw new Error(`additional_kwargs[${key}] already exists in the message chunk, but with a different type.`);\n            }\n            else if (typeof merged[key] === \"string\") {\n                merged[key] = merged[key] + value;\n            }\n            else if (!Array.isArray(merged[key]) &&\n                typeof merged[key] === \"object\") {\n                merged[key] = this._mergeAdditionalKwargs(merged[key], value);\n            }\n            else if (key === \"tool_calls\" &&\n                isOpenAIToolCallArray(merged[key]) &&\n                isOpenAIToolCallArray(value)) {\n                for (const toolCall of value) {\n                    if (merged[key]?.[toolCall.index] !== undefined) {\n                        merged[key] = merged[key]?.map((value, i) => {\n                            if (i !== toolCall.index) {\n                                return value;\n                            }\n                            return {\n                                ...value,\n                                ...toolCall,\n                                function: {\n                                    name: toolCall.function.name ?? value.function.name,\n                                    arguments: (value.function.arguments ?? \"\") +\n                                        (toolCall.function.arguments ?? \"\"),\n                                },\n                            };\n                        });\n                    }\n                    else {\n                        merged[key][toolCall.index] = toolCall;\n                    }\n                }\n            }\n            else {\n                throw new Error(`additional_kwargs[${key}] already exists in this message chunk.`);\n            }\n        }\n        return merged;\n    }\n}\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage extends BaseMessage {\n    static lc_name() {\n        return \"HumanMessage\";\n    }\n    _getType() {\n        return \"human\";\n    }\n}\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"HumanMessageChunk\";\n    }\n    _getType() {\n        return \"human\";\n    }\n    concat(chunk) {\n        return new HumanMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: HumanMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n        });\n    }\n}\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    concat(chunk) {\n        return new AIMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: AIMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n        });\n    }\n}\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage extends BaseMessage {\n    static lc_name() {\n        return \"SystemMessage\";\n    }\n    _getType() {\n        return \"system\";\n    }\n}\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"SystemMessageChunk\";\n    }\n    _getType() {\n        return \"system\";\n    }\n    concat(chunk) {\n        return new SystemMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: SystemMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n        });\n    }\n}\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage extends BaseMessage {\n    static lc_name() {\n        return \"FunctionMessage\";\n    }\n    constructor(fields, \n    /** @deprecated */\n    name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name: name };\n        }\n        super(fields);\n    }\n    _getType() {\n        return \"function\";\n    }\n}\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"FunctionMessageChunk\";\n    }\n    _getType() {\n        return \"function\";\n    }\n    concat(chunk) {\n        return new FunctionMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: FunctionMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n            name: this.name ?? \"\",\n        });\n    }\n}\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage extends BaseMessage {\n    static lc_name() {\n        return \"ToolMessage\";\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return { tool_call_id: \"tool_call_id\" };\n    }\n    constructor(fields, tool_call_id, name) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, name, tool_call_id: tool_call_id };\n        }\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    _getType() {\n        return \"tool\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"tool\";\n    }\n}\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk extends BaseMessageChunk {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tool_call_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_id = fields.tool_call_id;\n    }\n    static lc_name() {\n        return \"ToolMessageChunk\";\n    }\n    _getType() {\n        return \"tool\";\n    }\n    concat(chunk) {\n        return new ToolMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: ToolMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n            tool_call_id: this.tool_call_id,\n        });\n    }\n}\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage extends BaseMessage {\n    static lc_name() {\n        return \"ChatMessage\";\n    }\n    static _chatMessageClass() {\n        return ChatMessage;\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    static isInstance(message) {\n        return message._getType() === \"generic\";\n    }\n}\nexport function isBaseMessage(messageLike) {\n    return typeof messageLike?._getType === \"function\";\n}\nexport function isBaseMessageChunk(messageLike) {\n    return (isBaseMessage(messageLike) &&\n        typeof messageLike.concat === \"function\");\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new HumanMessage(messageLike);\n    }\n    else if (isBaseMessage(messageLike)) {\n        return messageLike;\n    }\n    const [type, content] = messageLike;\n    if (type === \"human\" || type === \"user\") {\n        return new HumanMessage({ content });\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        return new AIMessage({ content });\n    }\n    else if (type === \"system\") {\n        return new SystemMessage({ content });\n    }\n    else {\n        throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);\n    }\n}\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk extends BaseMessageChunk {\n    static lc_name() {\n        return \"ChatMessageChunk\";\n    }\n    constructor(fields, role) {\n        if (typeof fields === \"string\") {\n            // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n            fields = { content: fields, role: role };\n        }\n        super(fields);\n        Object.defineProperty(this, \"role\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.role = fields.role;\n    }\n    _getType() {\n        return \"generic\";\n    }\n    concat(chunk) {\n        return new ChatMessageChunk({\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: ChatMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),\n            role: this.role,\n        });\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nexport function mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new AIMessage(storedMessage.data);\n        case \"system\":\n            return new SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new ToolMessage(storedMessage.data);\n        case \"chat\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}